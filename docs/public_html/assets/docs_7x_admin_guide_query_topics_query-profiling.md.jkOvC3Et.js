import{_ as t,c as s,o as a,ag as n}from"./chunks/framework.Ds6Eueu6.js";const m=JSON.parse('{"title":"Query Profiling","description":"","frontmatter":{},"headers":[],"relativePath":"docs/7x/admin_guide/query/topics/query-profiling.md","filePath":"docs/7x/admin_guide/query/topics/query-profiling.md"}'),o={name:"docs/7x/admin_guide/query/topics/query-profiling.md"};function i(r,e,p,l,c,d){return a(),s("div",null,e[0]||(e[0]=[n(`<h1 id="query-profiling" tabindex="-1">Query Profiling <a class="header-anchor" href="#query-profiling" aria-label="Permalink to &quot;Query Profiling&quot;">​</a></h1><hr><p>Examine the query plans of poorly performing queries to identify possible performance tuning opportunities.</p><p>WarehousePG devises a <em>query plan</em> for each query. Choosing the right query plan to match the query and data structure is necessary for good performance. A query plan defines how WarehousePG will run the query in the parallel execution environment.</p><p>The query optimizer uses data statistics maintained by the database to choose a query plan with the lowest possible cost. Cost is measured in disk I/O, shown as units of disk page fetches. The goal is to minimize the total execution cost for the plan.</p><p>View the plan for a given query with the <code>EXPLAIN</code> command. <code>EXPLAIN</code> shows the query optimizer&#39;s estimated cost for the query plan. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>EXPLAIN SELECT * FROM names WHERE id=22;</span></span></code></pre></div><p><code>EXPLAIN ANALYZE</code> runs the statement in addition to displaying its plan. This is useful for determining how close the optimizer&#39;s estimates are to reality. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>EXPLAIN ANALYZE SELECT * FROM names WHERE id=22;</span></span></code></pre></div><blockquote><p><strong>Note</strong> In WarehousePG, the default GPORCA optimizer co-exists with the Postgres-based planner. The EXPLAIN output generated by GPORCA is different than the output generated by the Postgres-based planner.</p></blockquote><p>By default, WarehousePG uses GPORCA to generate an execution plan for a query when possible.</p><p>When the <code>EXPLAIN ANALYZE</code> command uses GPORCA, the <code>EXPLAIN</code> plan shows only the number of partitions that are being eliminated. The scanned partitions are not shown. To show name of the scanned partitions in the segment logs set the server configuration parameter <code>gp_log_dynamic_partition_pruning</code> to <code>on</code>. This example <code>SET</code> command enables the parameter.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SET gp_log_dynamic_partition_pruning = on;</span></span></code></pre></div><p>For information about GPORCA, see <a href="./query.html">SQL: Querying Data</a>.</p><p><strong>Parent topic:</strong> <a href="./../../query/topics/query.html">SQL: Querying Data</a></p><h2 id="reading-explain-output" tabindex="-1"><a id="topic40"></a>Reading EXPLAIN Output <a class="header-anchor" href="#reading-explain-output" aria-label="Permalink to &quot;&lt;a id=&quot;topic40&quot;&gt;&lt;/a&gt;Reading EXPLAIN Output&quot;">​</a></h2><p>A query plan is a tree of nodes. Each node in the plan represents a single operation, such as a table scan, join, aggregation, or sort.</p><p>Read plans from the bottom to the top: each node feeds rows into the node directly above it. The bottom nodes of a plan are usually table scan operations: sequential, index, or bitmap index scans. If the query requires joins, aggregations, sorts, or other operations on the rows, there are additional nodes above the scan nodes to perform these operations. The topmost plan nodes are usually WarehousePG motion nodes: redistribute, explicit redistribute, broadcast, or gather motions. These operations move rows between segment instances during query processing.</p><p>The output of <code>EXPLAIN</code> has one line for each node in the plan tree and shows the basic node type and the following execution cost estimates for that plan node:</p><ul><li><p><strong>cost</strong> —Measured in units of disk page fetches. 1.0 equals one sequential disk page read. The first estimate is the start-up cost of getting the first row and the second is the total cost of cost of getting all rows. The total cost assumes all rows will be retrieved, which is not always true; for example, if the query uses <code>LIMIT</code>, not all rows are retrieved.</p><blockquote><p><strong>Note</strong> The cost values generated by GPORCA and the Postgres-based planner are not directly comparable. The two optimizers use different cost models, as well as different algorithms, to determine the cost of an execution plan. Nothing can or should be inferred by comparing cost values between the two optimizers.</p></blockquote><p>In addition, the cost generated for any given optimizer is valid only for comparing plan alternatives for a given single query and set of statistics. Different queries can generate plans with different costs, even when keeping the optimizer a constant.</p><p>To summarize, the cost is essentially an internal number used by a given optimizer, and nothing should be inferred by examining only the cost value displayed in the <code>EXPLAIN</code> plans.</p></li><li><p><strong>rows</strong> —The total number of rows output by this plan node. This number is usually less than the number of rows processed or scanned by the plan node, reflecting the estimated selectivity of any <code>WHERE</code> clause conditions. Ideally, the estimate for the topmost node approximates the number of rows that the query actually returns, updates, or deletes.</p></li><li><p><strong>width</strong> —The total bytes of all the rows that this plan node outputs.</p></li></ul><p>Note the following:</p><ul><li>The cost of a node includes the cost of its child nodes. The topmost plan node has the estimated total execution cost for the plan. This is the number the optimizer intends to minimize.</li><li>The cost reflects only the aspects of plan execution that the query optimizer takes into consideration. For example, the cost does not reflect time spent transmitting result rows to the client.</li></ul><h3 id="explain-example" tabindex="-1"><a id="topic41"></a>EXPLAIN Example <a class="header-anchor" href="#explain-example" aria-label="Permalink to &quot;&lt;a id=&quot;topic41&quot;&gt;&lt;/a&gt;EXPLAIN Example&quot;">​</a></h3><p>The following example describes how to read an <code>EXPLAIN</code> query plan for a query:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>EXPLAIN SELECT * FROM names WHERE name = &#39;Joelle&#39;;</span></span>
<span class="line"><span>                     QUERY PLAN</span></span>
<span class="line"><span>------------------------------------------------------------</span></span>
<span class="line"><span>Gather Motion 2:1 (slice1) (cost=0.00..20.88 rows=1 width=13)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>   -&gt; Seq Scan on &#39;names&#39; (cost=0.00..20.88 rows=1 width=13)</span></span>
<span class="line"><span>         Filter: name::text ~~ &#39;Joelle&#39;::text</span></span></code></pre></div><p>Read the plan from the bottom to the top. To start, the query optimizer sequentially scans the <em>names</em> table. Notice the <code>WHERE</code> clause is applied as a <em>filter</em> condition. This means the scan operation checks the condition for each row it scans and outputs only the rows that satisfy the condition.</p><p>The results of the scan operation are passed to a <em>gather motion</em> operation. In WarehousePG, a gather motion is when segments send rows to the coordinator. In this example, we have two segment instances that send to one coordinator instance. This operation is working on <code>slice1</code> of the parallel query execution plan. A query plan is divided into <em>slices</em> so the segments can work on portions of the query plan in parallel.</p><p>The estimated startup cost for this plan is <code>00.00</code> (no cost) and a total cost of <code>20.88</code> disk page fetches. The optimizer estimates this query will return one row.</p><h2 id="reading-explain-analyze-output" tabindex="-1"><a id="topic42"></a>Reading EXPLAIN ANALYZE Output <a class="header-anchor" href="#reading-explain-analyze-output" aria-label="Permalink to &quot;&lt;a id=&quot;topic42&quot;&gt;&lt;/a&gt;Reading EXPLAIN ANALYZE Output&quot;">​</a></h2><p><code>EXPLAIN ANALYZE</code> plans and runs the statement. The <code>EXPLAIN ANALYZE</code> plan shows the actual execution cost along with the optimizer&#39;s estimates. This allows you to see if the optimizer&#39;s estimates are close to reality. <code>EXPLAIN ANALYZE</code> also shows the following:</p><ul><li><p>The total runtime (in milliseconds) in which the query ran.</p></li><li><p>The memory used by each slice of the query plan, as well as the memory reserved for the whole query statement.</p></li><li><p>The number of <em>workers</em> (segments) involved in a plan node operation. Only segments that return rows are counted.</p></li><li><p>The maximum number of rows returned by the segment that produced the most rows for the operation. If multiple segments produce an equal number of rows, <code>EXPLAIN ANALYZE</code> shows the segment with the longest <em>&lt;time&gt; to end</em>.</p></li><li><p>The segment id of the segment that produced the most rows for an operation.</p></li><li><p>For relevant operations, the amount of memory (<code>work_mem</code>) used by the operation. If the <code>work_mem</code> was insufficient to perform the operation in memory, the plan shows the amount of data spilled to disk for the lowest-performing segment. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Work_mem used: 64K bytes avg, 64K bytes max (seg0).</span></span>
<span class="line"><span>Work_mem wanted: 90K bytes avg, 90K byes max (seg0) to lessen </span></span>
<span class="line"><span>workfile I/O affecting 2 workers.</span></span></code></pre></div></li><li><p>The time (in milliseconds) in which the segment that produced the most rows retrieved the first row, and the time taken for that segment to retrieve all rows. The result may omit <em>&lt;time&gt; to first row</em> if it is the same as the <em>&lt;time&gt; to end</em>.</p></li></ul><h3 id="explain-analyze-examples" tabindex="-1"><a id="topic43"></a>EXPLAIN ANALYZE Examples <a class="header-anchor" href="#explain-analyze-examples" aria-label="Permalink to &quot;&lt;a id=&quot;topic43&quot;&gt;&lt;/a&gt;EXPLAIN ANALYZE Examples&quot;">​</a></h3><p>This example describes how to read an <code>EXPLAIN ANALYZE</code> query plan using the same query. The <code>bold</code> parts of the plan show actual timing and rows returned for each plan node, as well as memory and time statistics for the whole query.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>EXPLAIN ANALYZE SELECT * FROM names WHERE name = &#39;Joelle&#39;;</span></span>
<span class="line"><span>                     QUERY PLAN</span></span>
<span class="line"><span>------------------------------------------------------------</span></span>
<span class="line"><span>Gather Motion 2:1 (slice1; segments: 2) (cost=0.00..20.88 rows=1 width=13)</span></span>
<span class="line"><span>    Rows out: 1 rows at destination with 0.305 ms to first row, 0.537 ms to end, start offset by 0.289 ms.</span></span>
<span class="line"><span>        -&gt; Seq Scan on names (cost=0.00..20.88 rows=1 width=13)</span></span>
<span class="line"><span>             Rows out: Avg 1 rows x 2 workers. Max 1 rows (seg0) with 0.255 ms to first row, 0.486 ms to end, start offset by 0.968 ms.</span></span>
<span class="line"><span>                 Filter: name = &#39;Joelle&#39;::text</span></span>
<span class="line"><span> Slice statistics:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      (slice0) Executor memory: 135K bytes.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    (slice1) Executor memory: 151K bytes avg x 2 workers, 151K bytes max (seg0).</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Statement statistics:</span></span>
<span class="line"><span> Memory used: 128000K bytes</span></span>
<span class="line"><span> Total runtime: 22.548 ms</span></span></code></pre></div><p>Read the plan from the bottom to the top. The total elapsed time to run this query was <em>22.548</em> milliseconds.</p><p>The <em>sequential scan</em> operation had only one segment (<em>seg0</em>) that returned rows, and it returned just <em>1 row</em>. It took <em>0.255</em> milliseconds to find the first row and <em>0.486</em> to scan all rows. This result is close to the optimizer&#39;s estimate: the query optimizer estimated it would return one row for this query. The <em>gather motion</em> (segments sending data to the coordinator) received 1 row . The total elapsed time for this operation was <em>0.537</em> milliseconds.</p><h4 id="determining-the-query-optimizer" tabindex="-1"><a id="topic_idt_2ll_gr"></a>Determining the Query Optimizer <a class="header-anchor" href="#determining-the-query-optimizer" aria-label="Permalink to &quot;&lt;a id=&quot;topic_idt_2ll_gr&quot;&gt;&lt;/a&gt;Determining the Query Optimizer&quot;">​</a></h4><p>You can view EXPLAIN output to determine if GPORCA is enabled for the query plan and whether GPORCA or the Postgres-based planner generated the explain plan. The information appears at the end of the EXPLAIN output. The <code>Settings</code> line displays the setting of the server configuration parameter <code>OPTIMIZER</code>. The <code>Optimizer:</code> line displays whether GPORCA or the Postgres-based planner generated the explain plan.</p><p>For these two example query plans, GPORCA is enabled, the server configuration parameter <code>OPTIMIZER</code> is <code>on</code>. For the first plan, GPORCA generated the EXPLAIN plan. For the second plan, WarehousePG fell back to the Postgres-based planner to generate the query plan.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>                       QUERY PLAN</span></span>
<span class="line"><span>------------------------------------------------------------------------------------</span></span>
<span class="line"><span> Aggregate  (cost=0.00..296.14 rows=1 width=8)</span></span>
<span class="line"><span>   -&gt;  Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..295.10 rows=1 width=8)</span></span>
<span class="line"><span>         -&gt;  Aggregate  (cost=0.00..294.10 rows=1 width=8)</span></span>
<span class="line"><span>               -&gt;  Seq Scan on part  (cost=0.00..97.69 rows=100040 width=1)</span></span>
<span class="line"><span> Settings:  optimizer=on</span></span>
<span class="line"><span> Optimizer: GPORCA</span></span>
<span class="line"><span>(5 rows)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>explain select count(*) from part;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>                       QUERY PLAN</span></span>
<span class="line"><span>----------------------------------------------------------------------------------------</span></span>
<span class="line"><span> Aggregate  (cost=3519.05..3519.06 rows=1 width=8)</span></span>
<span class="line"><span>   -&gt;  Gather Motion 2:1  (slice1; segments: 2)  (cost=3518.99..3519.03 rows=1 width=8)</span></span>
<span class="line"><span>         -&gt;  Aggregate  (cost=3518.99..3519.00 rows=1 width=8)</span></span>
<span class="line"><span>               -&gt;  Seq Scan on part  (cost=0.00..3018.79 rows=100040 width=1)</span></span>
<span class="line"><span> Settings:  optimizer=on</span></span>
<span class="line"><span> Optimizer: Postgres-based planner</span></span>
<span class="line"><span>(5 rows)</span></span></code></pre></div><p>For this query, the server configuration parameter <code>OPTIMIZER</code> is <code>off</code>.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>explain select count(*) from part;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>                       QUERY PLAN</span></span>
<span class="line"><span>----------------------------------------------------------------------------------------</span></span>
<span class="line"><span> Aggregate  (cost=3519.05..3519.06 rows=1 width=8)</span></span>
<span class="line"><span>   -&gt;  Gather Motion 2:1  (slice1; segments: 2)  (cost=3518.99..3519.03 rows=1 width=8)</span></span>
<span class="line"><span>         -&gt;  Aggregate  (cost=3518.99..3519.00 rows=1 width=8)</span></span>
<span class="line"><span>               -&gt;  Seq Scan on part  (cost=0.00..3018.79 rows=100040 width=1)</span></span>
<span class="line"><span> Settings: optimizer=off</span></span>
<span class="line"><span> Optimizer: Postgres-based planner</span></span>
<span class="line"><span>(5 rows)</span></span></code></pre></div><h2 id="examining-query-plans-to-solve-problems" tabindex="-1"><a id="topic44"></a>Examining Query Plans to Solve Problems <a class="header-anchor" href="#examining-query-plans-to-solve-problems" aria-label="Permalink to &quot;&lt;a id=&quot;topic44&quot;&gt;&lt;/a&gt;Examining Query Plans to Solve Problems&quot;">​</a></h2><p>If a query performs poorly, examine its query plan and ask the following questions:</p><ul><li><p><strong>Do operations in the plan take an exceptionally long time?</strong> Look for an operation consumes the majority of query processing time. For example, if an index scan takes longer than expected, the index could be out-of-date and need to be reindexed. Or, adjust <code>enable_&lt;operator&gt;</code>parameters to see if you can force the Postgres-based planner to choose a different plan by deactivating a particular query plan operator for that query.</p></li><li><p><strong>Does the query planning time exceed query execution time?</strong> When the query involves many table joins, the Postgres-based planner uses a dynamic algorithm to plan the query that is in part based on the number of table joins. You can reduce the amount of time that the Postgres-based planner spends planning the query by setting the <code>join_collapse_limit</code> and <code>from_collapse_limit</code> server configuration parameters to a smaller value, such as <code>8</code>. Note that while smaller values reduce planning time, they may also yield inferior query plans.</p></li><li><p><strong>Are the optimizer&#39;s estimates close to reality?</strong> Run <code>EXPLAIN ANALYZE</code> and see if the number of rows the optimizer estimates is close to the number of rows the query operation actually returns. If there is a large discrepancy, collect more statistics on the relevant columns.</p><p>See the <em>WarehousePG Reference Guide</em> for more information on the <code>EXPLAIN ANALYZE</code> and <code>ANALYZE</code> commands.</p></li><li><p><strong>Are selective predicates applied early in the plan?</strong> Apply the most selective filters early in the plan so fewer rows move up the plan tree. If the query plan does not correctly estimate query predicate selectivity, collect more statistics on the relevant columns. See the <code>ANALYZE</code> command in the <em>WarehousePG Reference Guide</em> for more information collecting statistics.You can also try reordering the <code>WHERE</code> clause of your SQL statement.</p></li><li><p><strong>Does the optimizer choose the best join order?</strong> When you have a query that joins multiple tables, make sure that the optimizer chooses the most selective join order. Joins that eliminate the largest number of rows should be done earlier in the plan so fewer rows move up the plan tree.</p><p>If the plan is not choosing the optimal join order, set <code>join_collapse_limit=1</code> and use explicit <code>JOIN</code> syntax in your SQL statement to force the Postgres-based planner to the specified join order. You can also collect more statistics on the relevant join columns.</p><p>See the <code>ANALYZE</code> command in the <em>WarehousePG Reference Guide</em> for more information collecting statistics.</p></li><li><p><strong>Does the optimizer selectively scan partitioned tables?</strong> If you use table partitioning, is the optimizer selectively scanning only the child tables required to satisfy the query predicates? Scans of the parent tables should return 0 rows since the parent tables do not contain any data. See <a href="./../../ddl/ddl-partition.html#topic74">Verifying the Partition Strategy</a> for an example of a query plan that shows a selective partition scan.</p></li><li><p><strong>Does the optimizer choose hash aggregate and hash join operations where applicable?</strong> Hash operations are typically much faster than other types of joins or aggregations. Row comparison and sorting is done in memory rather than reading/writing from disk. To enable the query optimizer to choose hash operations, there must be sufficient memory available to hold the estimated number of rows. Try increasing work memory to improve performance for a query. If possible, run an <code>EXPLAIN ANALYZE</code> for the query to show which plan operations spilled to disk, how much work memory they used, and how much memory was required to avoid spilling to disk. For example:</p><p><code>Work_mem used: 23430K bytes avg, 23430K bytes max (seg0). Work_mem wanted: 33649K bytes avg, 33649K bytes max (seg0) to lessen workfile I/O affecting 2 workers.</code></p><p>The &quot;bytes wanted&quot; message from <code>EXPLAIN ANALYZE</code> is based on the amount of data written to work files and is not exact. The minimum <code>work_mem</code> needed can differ from the suggested value.</p></li></ul>`,46)]))}const u=t(o,[["render",i]]);export{m as __pageData,u as default};
