import{_ as a,c as t,o as s,ag as o}from"./chunks/framework.Ds6Eueu6.js";const h=JSON.parse('{"title":"Working with JSON Data","description":"","frontmatter":{},"headers":[],"relativePath":"docs/7x/admin_guide/query/topics/json-data.md","filePath":"docs/7x/admin_guide/query/topics/json-data.md"}'),n={name:"docs/7x/admin_guide/query/topics/json-data.md"};function i(c,e,r,d,p,l){return s(),t("div",null,e[0]||(e[0]=[o(`<h1 id="working-with-json-data" tabindex="-1">Working with JSON Data <a class="header-anchor" href="#working-with-json-data" aria-label="Permalink to &quot;Working with JSON Data&quot;">​</a></h1><hr><p>WarehousePG supports JSON as specified in the <a href="https://tools.ietf.org/html/rfc7159" target="_blank" rel="noreferrer">RFC 7159</a> document and enforces data validity according to the JSON rules. There are also JSON-specific functions and operators available for the <code>json</code> and <code>jsonb</code> data types. See <a href="./../../../ref_guide/function-summary.html#topic_gn4_x3w_mq">JSON Functions and Operators</a>.</p><p>WarehousePG offers two types for storing JSON (JavaScript Object Notation) data: <code>json</code> and <code>jsonb</code>. To implement efficient query mechanisms for these data types, WarehousePG also provides the <code>jsonpath</code> data type described in <a href="#topic_jsonpath">jsonpath Type</a> later in this topic.</p><p>This section contains the following topics:</p><ul><li><a href="#topic_upc_tcs_fz">About JSON Data</a></li><li><a href="#topic_isn_ltw_mq">JSON Input and Output Syntax</a></li><li><a href="#topic_eyt_3tw_mq">Designing JSON documents</a></li><li><a href="#topic_isx_2tw_mq">jsonb Containment and Existence</a></li><li><a href="#topic_aqt_1tw_mq">jsonb Indexing</a></li><li><a href="#topic_transforms">Transforms</a></li><li><a href="#topic_jsonpath">jsonpath Type</a></li></ul><p><strong>Parent topic:</strong> <a href="./../../query/topics/query.html">SQL: Querying Data</a></p><h2 id="about-json-data" tabindex="-1"><a id="topic_upc_tcs_fz"></a>About JSON Data <a class="header-anchor" href="#about-json-data" aria-label="Permalink to &quot;&lt;a id=&quot;topic_upc_tcs_fz&quot;&gt;&lt;/a&gt;About JSON Data&quot;">​</a></h2><p>The <code>json</code> and <code>jsonb</code> data types accept <em>almost</em> identical sets of values as input. The major difference is one of efficiency.</p><ul><li><p>The <code>json</code> data type stores an exact copy of the input text. This requires JSON processing functions to reparse <code>json</code> data on each execution. The <code>json</code> data type does not alter the input text.</p><ul><li>Semantically-insignificant white space between tokens is preserved, as well as the order of keys within JSON objects.</li><li>All key/value pairs are kept even if a JSON object contains duplicate keys. For duplicate keys, JSON processing functions consider the last value as the operative one.</li></ul></li><li><p>The <code>jsonb</code> data type stores a decomposed binary format of the input text. The conversion overhead makes data input slightly slower than the <code>json</code> data type. However, The JSON processing functions are significantly faster because reparsing <code>jsonb</code> data is not required. The <code>jsonb</code> data type alters the input text.</p><ul><li>White space is not preserved.</li><li>The order of object keys is not preserved.</li><li>Duplicate object keys are not kept. If the input includes duplicate keys, only the last value is kept.</li></ul></li><li><p>The <code>jsonb</code> data type supports indexing. See <a href="#topic_aqt_1tw_mq">jsonb Indexing</a>.</p></li></ul><p>In general, JSON data should be stored as the <code>jsonb</code> data type unless there are specialized needs, such as legacy assumptions about ordering of object keys.</p><p>WarehousePG allows only one character set encoding per database. It is therefore not possible for the JSON types to conform rigidly to the JSON specification unless the database encoding is UTF8. Attempts to directly include characters that cannot be represented in the database encoding will fail; conversely, characters that can be represented in the database encoding but not in UTF8 are allowed.</p><h3 id="about-unicode-characters-in-json-data" tabindex="-1"><a id="abuni"></a>About Unicode Characters in JSON Data <a class="header-anchor" href="#about-unicode-characters-in-json-data" aria-label="Permalink to &quot;&lt;a id=&quot;abuni&quot;&gt;&lt;/a&gt;About Unicode Characters in JSON Data&quot;">​</a></h3><p>The <a href="https://tools.ietf.org/html/rfc7159" target="_blank" rel="noreferrer">RFC 7159</a> document permits JSON strings to contain Unicode escape sequences denoted by <code>\\uXXXX</code>.</p><ul><li>The WarehousePG input function for the <code>json</code> data type allows Unicode escapes regardless of the database encoding and checks Unicode escapes only for syntactic correctness (a <code>\\u</code> followed by four hex digits).</li><li>The WarehousePG input function for the <code>jsonb</code> data type is more strict. It does not allow Unicode escapes for non-ASCII characters (those above <code>U+007F</code>) unless the database encoding is UTF8. The <code>jsonb</code> type also rejects <code>\\u0000</code>, which cannot be represented in the WarehousePG <code>text</code> type, and it requires that any use of Unicode surrogate pairs to designate characters outside the Unicode Basic Multilingual Plane be correct. Valid Unicode escapes, except for <code>\\u0000</code>, are converted to the equivalent ASCII or UTF8 character for storage; this includes folding surrogate pairs into a single character.</li></ul><blockquote><p><strong>Note</strong> Many of the JSON processing functions described in <a href="./../../../ref_guide/function-summary.html#topic_gn4_x3w_mq">JSON Functions and Operators</a> convert Unicode escapes to regular characters and will therefore throw the same types of errors just described even if their input is of type <code>json</code> not <code>jsonb</code>. The fact that the <code>json</code> input function does not make these checks may be considered a historical artifact, although it does allow for simple storage (without processing) of JSON Unicode escapes in a non-UTF8 database encoding. In general, it is best to avoid mixing Unicode escapes in JSON with a non-UTF8 database encoding, if possible.</p></blockquote><h3 id="mapping-json-data-types-to-warehousepg-data-types" tabindex="-1"><a id="mapjson"></a>Mapping JSON Data Types to WarehousePG Data Types <a class="header-anchor" href="#mapping-json-data-types-to-warehousepg-data-types" aria-label="Permalink to &quot;&lt;a id=&quot;mapjson&quot;&gt;&lt;/a&gt;Mapping JSON Data Types to WarehousePG Data Types&quot;">​</a></h3><p>When converting JSON text input into <code>jsonb</code> data, the primitive data types described by RFC 7159 are effectively mapped onto native WarehousePG data types, as shown in the following table.</p><table tabindex="0"><thead><tr><th>JSON primitive data type</th><th>WarehousePG data type</th><th>Notes</th></tr></thead><tbody><tr><td><code>string</code></td><td><code>text</code></td><td><code>\\u0000</code> is not allowed. Non-ASCII Unicode escapes are allowed only if database encoding is UTF8</td></tr><tr><td><code>number</code></td><td><code>numeric</code></td><td><code>NaN</code> and <code>infinity</code> values are disallowed</td></tr><tr><td><code>boolean</code></td><td><code>boolean</code></td><td>Only lowercase <code>true</code> and <code>false</code> spellings are accepted</td></tr><tr><td><code>null</code></td><td>(none)</td><td>The JSON <code>null</code> primitive type is different than the SQL <code>NULL</code></td></tr></tbody></table><p>There are some minor constraints on what constitutes valid <code>jsonb</code> data that do not apply to the <code>json</code> data type, nor to JSON in the abstract, corresponding to limits on what can be represented by the underlying data type. Notably, when converting data to the <code>jsonb</code> data type, numbers that are outside the range of the WarehousePG <code>numeric</code> data type are rejected, while the <code>json</code> data type does not reject such numbers.</p><p>Such implementation-defined restrictions are permitted by RFC 7159. However, in practice such problems might occur in other implementations, as it is common to represent the JSON <code>number</code> primitive type as IEEE 754 double precision floating point (which RFC 7159 explicitly anticipates and allows for).</p><p>When using JSON as an interchange format with other systems, be aware of the possibility of losing numeric precision compared to data originally stored by WarehousePG.</p><p>Also, as noted in the previous table, there are some minor restrictions on the input format of JSON primitive types that do not apply to the corresponding WarehousePG data types.</p><h2 id="json-input-and-output-syntax" tabindex="-1"><a id="topic_isn_ltw_mq"></a>JSON Input and Output Syntax <a class="header-anchor" href="#json-input-and-output-syntax" aria-label="Permalink to &quot;&lt;a id=&quot;topic_isn_ltw_mq&quot;&gt;&lt;/a&gt;JSON Input and Output Syntax&quot;">​</a></h2><p>The input and output syntax for the <code>json</code> data type is as specified in RFC 7159.</p><p>The following are all valid <code>json</code> (or <code>jsonb</code>) expressions:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>-- Simple scalar/primitive value</span></span>
<span class="line"><span>-- Primitive values can be numbers, quoted strings, true, false, or null</span></span>
<span class="line"><span>SELECT &#39;5&#39;::json;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-- Array of zero or more elements (elements need not be of same type)</span></span>
<span class="line"><span>SELECT &#39;[1, 2, &quot;foo&quot;, null]&#39;::json;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-- Object containing pairs of keys and values</span></span>
<span class="line"><span>-- Note that object keys must always be quoted strings</span></span>
<span class="line"><span>SELECT &#39;{&quot;bar&quot;: &quot;baz&quot;, &quot;balance&quot;: 7.77, &quot;active&quot;: false}&#39;::json;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-- Arrays and objects can be nested arbitrarily</span></span>
<span class="line"><span>SELECT &#39;{&quot;foo&quot;: [true, &quot;bar&quot;], &quot;tags&quot;: {&quot;a&quot;: 1, &quot;b&quot;: null}}&#39;::json;</span></span></code></pre></div><p>As previously stated, when a JSON value is input and then printed without any additional processing, the <code>json</code> data type outputs the same text that was input, while the <code>jsonb</code> data type does not preserve semantically-insignificant details such as whitespace. For example, note the differences here:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT &#39;{&quot;bar&quot;: &quot;baz&quot;, &quot;balance&quot;: 7.77, &quot;active&quot;:false}&#39;::json;</span></span>
<span class="line"><span>                      json                       </span></span>
<span class="line"><span>-------------------------------------------------</span></span>
<span class="line"><span> {&quot;bar&quot;: &quot;baz&quot;, &quot;balance&quot;: 7.77, &quot;active&quot;:false}</span></span>
<span class="line"><span>(1 row)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>SELECT &#39;{&quot;bar&quot;: &quot;baz&quot;, &quot;balance&quot;: 7.77, &quot;active&quot;:false}&#39;::jsonb;</span></span>
<span class="line"><span>                      jsonb                       </span></span>
<span class="line"><span>--------------------------------------------------</span></span>
<span class="line"><span> {&quot;bar&quot;: &quot;baz&quot;, &quot;active&quot;: false, &quot;balance&quot;: 7.77}</span></span>
<span class="line"><span>(1 row)</span></span></code></pre></div><p>One semantically-insignificant detail worth noting is that with the <code>jsonb</code> data type, numbers will be printed according to the behavior of the underlying <code>numeric</code> type. In practice, this means that numbers entered with <code>E</code> notation will be printed without it, for example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT &#39;{&quot;reading&quot;: 1.230e-5}&#39;::json, &#39;{&quot;reading&quot;: 1.230e-5}&#39;::jsonb;</span></span>
<span class="line"><span>         json          |          jsonb          </span></span>
<span class="line"><span>-----------------------+-------------------------</span></span>
<span class="line"><span> {&quot;reading&quot;: 1.230e-5} | {&quot;reading&quot;: 0.00001230}</span></span>
<span class="line"><span>(1 row)</span></span></code></pre></div><p>However, the <code>jsonb</code> data type preserves trailing fractional zeroes, as seen in previous example, even though those are semantically insignificant for purposes such as equality checks.</p><h2 id="designing-json-documents" tabindex="-1"><a id="topic_eyt_3tw_mq"></a>Designing JSON documents <a class="header-anchor" href="#designing-json-documents" aria-label="Permalink to &quot;&lt;a id=&quot;topic_eyt_3tw_mq&quot;&gt;&lt;/a&gt;Designing JSON documents&quot;">​</a></h2><p>Representing data as JSON can be considerably more flexible than the traditional relational data model, which is compelling in environments where requirements are fluid. It is quite possible for both approaches to co-exist and complement each other within the same application. However, even for applications where maximal flexibility is desired, it is still recommended that JSON documents have a somewhat fixed structure. The structure is typically unenforced (though enforcing some business rules declaratively is possible), but having a predictable structure makes it easier to write queries that usefully summarize a set of JSON documents (datums) in a table.</p><p>JSON data is subject to the same concurrency-control considerations as any other data type when stored in a table. Although storing large documents is practicable, keep in mind that any update acquires a row-level lock on the whole row. Consider limiting JSON documents to a manageable size in order to decrease lock contention among updating transactions. Ideally, JSON documents should each represent an atomic datum that business rules dictate cannot reasonably be further subdivided into smaller datums that could be modified independently.</p><h2 id="jsonb-containment-and-existence" tabindex="-1"><a id="topic_isx_2tw_mq"></a>jsonb Containment and Existence <a class="header-anchor" href="#jsonb-containment-and-existence" aria-label="Permalink to &quot;&lt;a id=&quot;topic_isx_2tw_mq&quot;&gt;&lt;/a&gt;jsonb Containment and Existence&quot;">​</a></h2><p>Testing <em>containment</em> is an important capability of <code>jsonb</code>. There is no parallel set of facilities for the <code>json</code> type. Containment tests whether one <code>jsonb</code> document has contained within it another one. These examples return <code>true</code> except as noted:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>-- Simple scalar/primitive values contain only the identical value:</span></span>
<span class="line"><span>SELECT &#39;&quot;foo&quot;&#39;::jsonb @&gt; &#39;&quot;foo&quot;&#39;::jsonb;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-- The array on the right side is contained within the one on the left:</span></span>
<span class="line"><span>SELECT &#39;[1, 2, 3]&#39;::jsonb @&gt; &#39;[1, 3]&#39;::jsonb;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-- Order of array elements is not significant, so this is also true:</span></span>
<span class="line"><span>SELECT &#39;[1, 2, 3]&#39;::jsonb @&gt; &#39;[3, 1]&#39;::jsonb;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-- Duplicate array elements don&#39;t matter either:</span></span>
<span class="line"><span>SELECT &#39;[1, 2, 3]&#39;::jsonb @&gt; &#39;[1, 2, 2]&#39;::jsonb;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-- The object with a single pair on the right side is contained</span></span>
<span class="line"><span>-- within the object on the left side:</span></span>
<span class="line"><span>SELECT &#39;{&quot;product&quot;: &quot;WarehousePG&quot;, &quot;version&quot;: &quot;7.0.0&quot;, &quot;jsonb&quot;:true}&#39;::jsonb @&gt; &#39;{&quot;version&quot;:&quot;7.0.0&quot;}&#39;::jsonb;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-- The array on the right side is not considered contained within the</span></span>
<span class="line"><span>-- array on the left, even though a similar array is nested within it:</span></span>
<span class="line"><span>SELECT &#39;[1, 2, [1, 3]]&#39;::jsonb @&gt; &#39;[1, 3]&#39;::jsonb;  -- yields false</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-- But with a layer of nesting, it is contained:</span></span>
<span class="line"><span>SELECT &#39;[1, 2, [1, 3]]&#39;::jsonb @&gt; &#39;[[1, 3]]&#39;::jsonb;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-- Similarly, containment is not reported here:</span></span>
<span class="line"><span>SELECT &#39;{&quot;foo&quot;: {&quot;bar&quot;: &quot;baz&quot;}}&#39;::jsonb @&gt; &#39;{&quot;bar&quot;: &quot;baz&quot;}&#39;::jsonb; -- yields false</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-- But with a layer of nesting, it is contained:</span></span>
<span class="line"><span>SELECT &#39;{&quot;foo&quot;: {&quot;bar&quot;: &quot;baz&quot;}}&#39;::jsonb @&gt; &#39;{&quot;foo&quot;: {}}&#39;::jsonb;</span></span></code></pre></div><p>The general principle is that the contained object must match the containing object as to structure and data contents, possibly after discarding some non-matching array elements or object key/value pairs from the containing object. For containment, the order of array elements is not significant when doing a containment match, and duplicate array elements are effectively considered only once.</p><p>As an exception to the general principle that the structures must match, an array may contain a primitive value:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>-- This array contains the primitive string value:</span></span>
<span class="line"><span>SELECT &#39;[&quot;foo&quot;, &quot;bar&quot;]&#39;::jsonb @&gt; &#39;&quot;bar&quot;&#39;::jsonb;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-- This exception is not reciprocal -- non-containment is reported here:</span></span>
<span class="line"><span>SELECT &#39;&quot;bar&quot;&#39;::jsonb @&gt; &#39;[&quot;bar&quot;]&#39;::jsonb;  -- yields false</span></span></code></pre></div><p><code>jsonb</code> also has an <em>existence</em> operator, which is a variation on the theme of containment: it tests whether a string (given as a <code>text</code> value) appears as an object key or array element at the top level of the <code>jsonb</code> value. These examples return <code>true</code> except as noted:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>-- String exists as array element:</span></span>
<span class="line"><span>SELECT &#39;[&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]&#39;::jsonb ? &#39;bar&#39;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-- String exists as object key:</span></span>
<span class="line"><span>SELECT &#39;{&quot;foo&quot;: &quot;bar&quot;}&#39;::jsonb ? &#39;foo&#39;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-- Object values are not considered:</span></span>
<span class="line"><span>SELECT &#39;{&quot;foo&quot;: &quot;bar&quot;}&#39;::jsonb ? &#39;bar&#39;;  -- yields false</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-- As with containment, existence must match at the top level:</span></span>
<span class="line"><span>SELECT &#39;{&quot;foo&quot;: {&quot;bar&quot;: &quot;baz&quot;}}&#39;::jsonb ? &#39;bar&#39;; -- yields false</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-- A string is considered to exist if it matches a primitive JSON string:</span></span>
<span class="line"><span>SELECT &#39;&quot;foo&quot;&#39;::jsonb ? &#39;foo&#39;;</span></span></code></pre></div><p>JSON objects are better suited than arrays for testing containment or existence when there are many keys or elements involved, because unlike arrays they are internally optimized for searching, and do not need to be searched linearly.</p><p>Because JSON containment is nested, an appropriate query can skip explicit selection of sub-objects. As an example, suppose that we have a <code>doc</code> column containing objects at the top level, with most objects containing <code>tags</code> fields that contain arrays of sub-objects. This query finds entries in which sub-objects containing both <code>&quot;term&quot;:&quot;paris&quot;</code> and <code>&quot;term&quot;:&quot;food&quot;</code> appear, while ignoring any such keys outside the <code>tags</code> array:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT doc-&gt;&#39;site_name&#39; FROM websites</span></span>
<span class="line"><span>  WHERE doc @&gt; &#39;{&quot;tags&quot;:[{&quot;term&quot;:&quot;paris&quot;}, {&quot;term&quot;:&quot;food&quot;}]}&#39;;</span></span></code></pre></div><p>The query with this predicate could accomplish the same thing:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT doc-&gt;&#39;site_name&#39; FROM websites</span></span>
<span class="line"><span>  WHERE doc-&gt;&#39;tags&#39; @&gt; &#39;[{&quot;term&quot;:&quot;paris&quot;}, {&quot;term&quot;:&quot;food&quot;}]&#39;;</span></span></code></pre></div><p>However, the second approach is less flexible and is often less efficient as well.</p><p>On the other hand, the JSON existence operator is not nested: it will only look for the specified key or array element at top level of the JSON value.</p><p>The various containment and existence operators, along with all other JSON operators and functions are documented in <a href="./../../../ref_guide/function-summary.html#topic_gn4_x3w_mq">JSON Functions and Operators</a>.</p><h2 id="jsonb-indexing" tabindex="-1"><a id="topic_aqt_1tw_mq"></a>jsonb Indexing <a class="header-anchor" href="#jsonb-indexing" aria-label="Permalink to &quot;&lt;a id=&quot;topic_aqt_1tw_mq&quot;&gt;&lt;/a&gt;jsonb Indexing&quot;">​</a></h2><p>The WarehousePG <code>jsonb</code> data type, supports GIN, btree, and hash indexes.</p><ul><li><a href="#topic_yjx_dq2_rfb">GIN Indexes on jsonb Data</a></li><li><a href="#topic_ahb_5ly_wq">Btree and Hash Indexes on jsonb Data</a></li></ul><h3 id="gin-indexes-on-jsonb-data" tabindex="-1"><a id="topic_yjx_dq2_rfb"></a>GIN Indexes on jsonb Data <a class="header-anchor" href="#gin-indexes-on-jsonb-data" aria-label="Permalink to &quot;&lt;a id=&quot;topic_yjx_dq2_rfb&quot;&gt;&lt;/a&gt;GIN Indexes on jsonb Data&quot;">​</a></h3><p>GIN indexes can be used to efficiently search for keys or key/value pairs occurring within a large number of <code>jsonb</code> documents (datums). Two GIN operator classes are provided, offering different performance and flexibility trade-offs.</p><p>The default GIN operator class for jsonb supports queries with the <code>@&gt;</code>, <code>?</code>, <code>?&amp;</code> and <code>?|</code> operators. (For details of the semantics that these operators implement, see <a href="./../../../ref_guide/function-summary.html#topic_o5y_14w_2z">JSON Operators</a>.) An example of creating an index with this operator class is:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE INDEX idxgin ON api USING GIN (jdoc);</span></span></code></pre></div><p>The non-default GIN operator class <code>jsonb_path_ops</code> does not support the key-exists operators, but it does support <code>@&gt;</code>, <code>@?</code>, and <code>@@.</code> An example of creating an index with this operator class is:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE INDEX idxginp ON api USING GIN (jdoc jsonb_path_ops);</span></span></code></pre></div><p>Consider the example of a table that stores JSON documents retrieved from a third-party web service, with a documented schema definition. This is a typical document:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>{</span></span>
<span class="line"><span>    &quot;guid&quot;: &quot;9c36adc1-7fb5-4d5b-83b4-90356a46061a&quot;,</span></span>
<span class="line"><span>    &quot;name&quot;: &quot;Angela Barton&quot;,</span></span>
<span class="line"><span>    &quot;is_active&quot;: true,</span></span>
<span class="line"><span>    &quot;company&quot;: &quot;Magnafone&quot;,</span></span>
<span class="line"><span>    &quot;address&quot;: &quot;178 Howard Place, Gulf, Washington, 702&quot;,</span></span>
<span class="line"><span>    &quot;registered&quot;: &quot;2009-11-07T08:53:22 +08:00&quot;,</span></span>
<span class="line"><span>    &quot;latitude&quot;: 19.793713,</span></span>
<span class="line"><span>    &quot;longitude&quot;: 86.513373,</span></span>
<span class="line"><span>    &quot;tags&quot;: [</span></span>
<span class="line"><span>        &quot;enim&quot;,</span></span>
<span class="line"><span>        &quot;aliquip&quot;,</span></span>
<span class="line"><span>        &quot;qui&quot;</span></span>
<span class="line"><span>    ]</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>The JSON documents are stored a table named <code>api</code>, in a <code>jsonb</code> column named <code>jdoc</code>. If a GIN index is created on this column, queries like the following can make use of the index:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>-- Find documents in which the key &quot;company&quot; has value &quot;Magnafone&quot;</span></span>
<span class="line"><span>SELECT jdoc-&gt;&#39;guid&#39;, jdoc-&gt;&#39;name&#39; FROM api WHERE jdoc @&gt; &#39;{&quot;company&quot;: &quot;Magnafone&quot;}&#39;;</span></span></code></pre></div><p>However, the index could not be used for queries like the following. The operator <code>?</code> is indexable, however, the comparison is not applied directly to the indexed column <code>jdoc</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>-- Find documents in which the key &quot;tags&quot; contains key or array element &quot;qui&quot;</span></span>
<span class="line"><span>SELECT jdoc-&gt;&#39;guid&#39;, jdoc-&gt;&#39;name&#39; FROM api WHERE jdoc -&gt; &#39;tags&#39; ? &#39;qui&#39;;</span></span></code></pre></div><p>With appropriate use of expression indexes, the above query can use an index. If querying for particular items within the <code>tags</code> key is common, defining an index like this might be worthwhile:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE INDEX idxgintags ON api USING GIN ((jdoc -&gt; &#39;tags&#39;));</span></span></code></pre></div><p>Now, the <code>WHERE</code> clause <code>jdoc -&gt; &#39;tags&#39; ? &#39;qui&#39;</code> is recognized as an application of the indexable operator <code>?</code> to the indexed expression <code>jdoc -&gt; &#39;tags&#39;</code>. For information about expression indexes, see <a href="./../../ddl/ddl-index.html">Indexes on Expressions</a>.</p><p>Another approach to querying JSON documents is to exploit containment, for example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>-- Find documents in which the key &quot;tags&quot; contains array element &quot;qui&quot;</span></span>
<span class="line"><span>SELECT jdoc-&gt;&#39;guid&#39;, jdoc-&gt;&#39;name&#39; FROM api WHERE jdoc @&gt; &#39;{&quot;tags&quot;: [&quot;qui&quot;]}&#39;;</span></span></code></pre></div><p>A simple GIN index on the <code>jdoc</code> column can support this query. However, the index will store copies of every key and value in the <code>jdoc</code> column, whereas the expression index of the previous example stores only data found under the <code>tags</code> key. While the simple-index approach is far more flexible (since it supports queries about any key), targeted expression indexes are likely to be smaller and faster to search than a simple index.</p><p>GIN indexes also support the <code>@?</code> and <code>@@</code> operators, which perform <code>jsonpath</code> matching. Examples are:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT jdoc-&gt;&#39;guid&#39;, jdoc-&gt;&#39;name&#39; FROM api WHERE jdoc @? &#39;$.tags[*] ? (@ == &quot;qui&quot;)&#39;;</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT jdoc-&gt;&#39;guid&#39;, jdoc-&gt;&#39;name&#39; FROM api WHERE jdoc @@ &#39;$.tags[*] == &quot;qui&quot;&#39;;</span></span></code></pre></div><p>For these operators, a GIN index extracts clauses of the form <code>accessors_chain = constant</code> out of the <code>jsonpath</code> pattern, and does the index search based on the keys and values mentioned in these clauses. The accessors chain may include <code>.key</code>, <code>[*],</code> and <code>[index]</code> accessors. The <code>jsonb_ops</code> operator class also supports <code>.*</code> and <code>.**</code> accessors, but the <code>jsonb_path_ops</code> operator class does not.</p><p>Although the <code>jsonb_path_ops</code> operator class supports only queries with the <code>@&gt;</code>, <code>@?</code> and <code>@@</code> operators, it has notable performance advantages over the default operator class <code>jsonb_ops</code>. A <code>jsonb_path_ops</code> index is usually much smaller than a <code>jsonb_ops</code> index over the same data, and the specificity of searches is better, particularly when queries contain keys that appear frequently in the data. Therefore search operations typically perform better than with the default operator class.</p><p>The technical difference between a <code>jsonb_ops</code> and a <code>jsonb_path_ops</code> GIN index is that the former creates independent index items for each key and value in the data, while the latter creates index items only for each value in the data.</p><blockquote><p><strong>Note</strong> For this discussion, the term <em>value</em> includes array elements, though JSON terminology sometimes considers array elements distinct from values within objects.</p></blockquote><p>Basically, each <code>jsonb_path_ops</code> index item is a hash of the value and the key(s) leading to it; for example to index <code>{&quot;foo&quot;: {&quot;bar&quot;: &quot;baz&quot;}}</code>, a single index item would be created incorporating all three of <code>foo</code>, <code>bar</code>, and <code>baz</code> into the hash value. Thus a containment query looking for this structure would result in an extremely specific index search; but there is no way at all to find out whether <code>foo</code> appears as a key. On the other hand, a <code>jsonb_ops</code> index would create three index items representing <code>foo</code>, <code>bar</code>, and <code>baz</code> separately; then to do the containment query, it would look for rows containing all three of these items. While GIN indexes can perform such an <code>AND</code> search fairly efficiently, it will still be less specific and slower than the equivalent <code>jsonb_path_ops</code> search, especially if there are a very large number of rows containing any single one of the three index items.</p><p>A disadvantage of the <code>jsonb_path_ops</code> approach is that it produces no index entries for JSON structures not containing any values, such as <code>{&quot;a&quot;: {}}</code>. If a search for documents containing such a structure is requested, it will require a full-index scan, which is quite slow. <code>jsonb_path_ops</code> is ill-suited for applications that often perform such searches.</p><h3 id="btree-and-hash-indexes-on-jsonb-data" tabindex="-1"><a id="topic_ahb_5ly_wq"></a>Btree and Hash Indexes on jsonb Data <a class="header-anchor" href="#btree-and-hash-indexes-on-jsonb-data" aria-label="Permalink to &quot;&lt;a id=&quot;topic_ahb_5ly_wq&quot;&gt;&lt;/a&gt;Btree and Hash Indexes on jsonb Data&quot;">​</a></h3><p><code>jsonb</code> also supports <code>btree</code> and <code>hash</code> indexes. These are usually useful only when it is important to check the equality of complete JSON documents.</p><p>For completeness, the <code>btree</code> ordering for <code>jsonb</code> datums is:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Object &gt; Array &gt; Boolean &gt; Number &gt; String &gt; Null</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Object with n pairs &gt; object with n - 1 pairs</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Array with n elements &gt; array with n - 1 elements</span></span></code></pre></div><p>Objects with equal numbers of pairs are compared in the order:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>key-1, value-1, key-2 ...</span></span></code></pre></div><p>Object keys are compared in their storage order. In particular, since shorter keys are stored before longer keys, this can lead to orderings that might not be intuitive, such as:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>{ &quot;aa&quot;: 1, &quot;c&quot;: 1} &gt; {&quot;b&quot;: 1, &quot;d&quot;: 1}</span></span></code></pre></div><p>Similarly, arrays with equal numbers of elements are compared in the order:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>element-1, element-2 ...</span></span></code></pre></div><p>Primitive JSON values are compared using the same comparison rules as for the underlying WarehousePG data type. Strings are compared using the default database collation.</p><h2 id="transforms" tabindex="-1"><a id="topic_transforms"></a>Transforms <a class="header-anchor" href="#transforms" aria-label="Permalink to &quot;&lt;a id=&quot;topic_transforms&quot;&gt;&lt;/a&gt;Transforms&quot;">​</a></h2><p>Additional extensions are available that implement transforms for the <code>jsonb</code> type for different procedural languages.</p><p>The extensions for PL/Perl are called <code>jsonb_plperl</code> and j<code>sonb_plperlu</code>. If you use them, <code>jsonb</code> values are mapped to Perl arrays, hashes, and scalars, as appropriate.</p><p>The extension for PL/Python is called <code>jsonb_plpython3u</code>. If you use it, <code>jsonb</code> values are mapped to Python dictionaries, lists, and scalars, as appropriate.</p><h2 id="jsonpath-type" tabindex="-1"><a id="topic_jsonpath"></a>jsonpath Type <a class="header-anchor" href="#jsonpath-type" aria-label="Permalink to &quot;&lt;a id=&quot;topic_jsonpath&quot;&gt;&lt;/a&gt;jsonpath Type&quot;">​</a></h2><p>The <code>jsonpath</code> type implements support for the SQL/JSON path language in WarehousePG to efficiently query JSON data. It provides a binary representation of the parsed SQL/JSON path expression that specifies the items to be retrieved by the path engine from the JSON data for further processing with the SQL/JSON query functions.</p><p>The semantics of SQL/JSON path predicates and operators generally follow SQL. At the same time, to provide a most natural way of working with JSON data, SQL/JSON path syntax uses some of the JavaScript conventions:</p><ul><li><p>Dot (<code>.</code>) is used for member access.</p></li><li><p>Square brackets (<code>[]</code>) are used for array access.</p></li><li><p>SQL/JSON arrays are 0-relative, unlike regular SQL arrays that start from 1.</p></li></ul><p>An SQL/JSON path expression is typically written in an SQL query as an SQL character string literal, so it must be enclosed in single quotes, and any single quotes desired within the value must be doubled. Some forms of path expressions require string literals within them. These embedded string literals follow JavaScript/ECMAScript conventions: they must be surrounded by double quotes, and backslash escapes may be used within them to represent otherwise-hard-to-type characters. In particular, the way to write a double quote within an embedded string literal is <code>\\&quot;</code>, and to write a backslash itself, you must write <code>\\\\</code>. Other special backslash sequences include those recognized in JSON strings: <code>\\b</code>, <code>\\f</code>, <code>\\n</code>, <code>\\r</code>, <code>\\t</code>, <code>\\v</code> for various ASCII control characters, and <code>\\uNNNN</code> for a Unicode character identified by its 4-hex-digit code point. The backslash syntax also includes two cases not allowed by JSON: <code>\\xNN</code> for a character code written with only two hex digits, and <code>\\u{N...}</code> for a character code written with 1 to 6 hex digits.</p><p>A path expression consists of a sequence of path elements, which can be the following:</p><ul><li><p>Path literals of JSON primitive types: Unicode text, numeric, true, false, or null.</p></li><li><p>Path variables listed in the <strong>jsonpath Variables</strong> table below.</p></li><li><p>Accessor operators listed in the <strong>jsonpath Accessors</strong> table below.</p></li><li><p><code>jsonpath</code> operators and methods listed in <a href="./../../../ref_guide/function-summary.html#topic_jsonpath_opsmeth">SQL/JSON Path Operators and Methods</a>.</p></li><li><p>Parentheses, which can be used to provide filter expressions or define the order of path evaluation.</p></li></ul><p>For details on using <code>jsonpath</code> expressions with SQL/JSON query functions, see <a href="./../../../ref_guide/function-summary.html#topic_jsonpath_filtexp">SQL/JSON Filter Expression Elements</a>.</p><div class="table" id="TYPE-JSONPATH-VARIABLES"><p class="title"><strong><code class="type">jsonpath</code> Variables</strong></p><div class="table-contents"><table class="table" summary="jsonpath Variables" border="1"><colgroup><col><col></colgroup><thead><tr class="row"><th class="entry nocellnorowborder">Variable</th><th class="entry nocellnorowborder">Description</th></tr></thead><tbody><tr class="row"><td class="entry nocellnorowborder"><code class="literal">$</code></td><td class="entry nocellnorowborder">A variable representing the JSON text to be queried (the <em class="firstterm">context item</em>).</td></tr><tr class="row"><td class="entry nocellnorowborder"><code class="literal">$varname</code></td><td class="entry nocellnorowborder">A named variable. Its value can be set by the parameter <em class="parameter"><code>vars</code></em> of several JSON processing functions. See <a href="../../../ref_guide/function-summary.html#topic_z5d_snw_2z">JSON Processing Functions</a> and its notes for details.</td></tr><tr><td class="entry nocellnorowborder"><code class="literal">@</code></td><td class="entry nocellnorowborder">A variable representing the result of path evaluation in filter expressions.</td></tr></tbody></table></div></div><div class="table" id="TYPE-JSONPATH-ACCESSORS"><p class="title"><strong><code class="type">jsonpath</code> Accessors</strong></p><div class="table-contents"><table class="table" summary="jsonpath Accessors" border="1"><colgroup><col><col></colgroup><thead><tr class="row"><th class="entry nocellnorowborder">Accessor Operator</th><th class="entry nocellnorowborder">Description</th></tr></thead><tbody><tr class="row"><td class="entry nocellnorowborder"><p><code class="literal">.<em class="replaceable"><code>key</code></em></code></p><p><code class="literal">.&quot;$<em class="replaceable"><code>varname</code></em>&quot;</code></p></td><td class="entry nocellnorowborder"><p>Member accessor that returns an object member with the specified key. If the key name is a named variable starting with <code class="literal">$</code> or does not meet the JavaScript rules of an identifier, it must be enclosed in double quotes as a character string literal.</p></td></tr><tr class="row"><td class="entry nocellnorowborder"><p><code class="literal">.*</code></p></td><td class="entry nocellnorowborder"><p>Wildcard member accessor that returns the values of all members located at the top level of the current object.</p></td></tr><tr class="row"><td class="entry nocellnorowborder"><p><code class="literal">.**</code></p></td><td class="entry nocellnorowborder"><p>Recursive wildcard member accessor that processes all levels of the JSON hierarchy of the current object and returns all the member values, regardless of their nesting level. This is a <span class="productname">WarehousePG</span> extension of the SQL/JSON standard.</p></td></tr><tr class="row"><td class="entry nocellnorowborder"><p><code class="literal">.**{<em class="replaceable"><code>level</code></em>}</code></p><p><code class="literal">.**{<em class="replaceable"><code>start_level</code></em> to <em class="replaceable"><code>end_level</code></em>}</code></p></td><td class="entry nocellnorowborder"><p>Same as <code class="literal">.**</code>, but with a filter over nesting levels of JSON hierarchy. Nesting levels are specified as integers. Zero level corresponds to the current object. To access the lowest nesting level, you can use the <code class="literal">last</code> keyword. This is a <span class="productname">WarehousePG</span> extension of the SQL/JSON standard.</p></td></tr><tr class="row"><td class="entry nocellnorowborder"><p><code class="literal">[<em class="replaceable"><code>subscript</code></em>, ...]</code></p></td><td class="entry nocellnorowborder"><p>Array element accessor. <code class="literal"><em class="replaceable"><code>subscript</code></em></code> can be given in two forms: <code class="literal"><em class="replaceable"><code>index</code></em></code> or <code class="literal"><em class="replaceable"><code>start_index</code></em> to <em class="replaceable"><code>end_index</code></em></code>. The first form returns a single array element by its index. The second form returns an array slice by the range of indexes, including the elements that correspond to the provided <em class="replaceable"><code>start_index</code></em> and <em class="replaceable"><code>end_index</code></em>.</p><p>The specified <em class="replaceable"><code>index</code></em> can be an integer, as well as an expression returning a single numeric value, which is automatically cast to integer. Zero index corresponds to the first array element. You can also use the <code class="literal">last</code> keyword to denote the last array element, which is useful for handling arrays of unknown length.</p></td></tr><tr class="row"><td class="entry nocellnorowborder"><p><code class="literal">[*]</code></p></td><td class="entry nocellnorowborder"><p>Wildcard array element accessor that returns all array elements.</p></td></tr></tbody></table></div></div>`,106)]))}const b=a(n,[["render",i]]);export{h as __pageData,b as default};
