import{_ as s,c as e,o as n,ag as t}from"./chunks/framework.Ds6Eueu6.js";const u=JSON.parse('{"title":"Working with XML Data","description":"","frontmatter":{},"headers":[],"relativePath":"docs/7x/admin_guide/query/topics/xml-data.md","filePath":"docs/7x/admin_guide/query/topics/xml-data.md"}'),p={name:"docs/7x/admin_guide/query/topics/xml-data.md"};function l(o,a,i,c,r,d){return n(),e("div",null,a[0]||(a[0]=[t(`<h1 id="working-with-xml-data" tabindex="-1">Working with XML Data <a class="header-anchor" href="#working-with-xml-data" aria-label="Permalink to &quot;Working with XML Data&quot;">​</a></h1><hr><p>WarehousePG supports the <code>xml</code> data type that stores XML data.</p><p>The <code>xml</code> data type checks the input values for well-formedness, providing an advantage over simply storing XML data in a text field. Additionally, support functions allow you to perform type-safe operations on this data; refer to <a href="#topic_gn4_x3w_mq">XML Function Reference</a>, below.</p><p>Use of this data type requires the installation to have been built with <code>configure --with-libxml</code>. This is enabled by default for WarehousePG builds.</p><p>The <code>xml</code> type can store well-formed &quot;documents&quot;, as defined by the XML standard, as well as &quot;content&quot; fragments, which are defined by reference to the more permissive <a href="https://www.w3.org/TR/2010/REC-xpath-datamodel-20101214/#DocumentNode" target="_blank" rel="noreferrer">document node</a> of the XQuery and XPath model. Roughly, this means that content fragments can have more than one top-level element or character node. The expression <code>xmlvalue IS DOCUMENT</code> can be used to evaluate whether a particular <code>xml</code> value is a full document or only a content fragment.</p><p>This section contains the following topics:</p><ul><li><a href="#topic_upc_tcs_fz">Creating XML Values</a></li><li><a href="#topic_eyt_3tw_mq">Encoding Handling</a></li><li><a href="#topic_kxv_4gq_vz">Accessing XML Values</a></li><li><a href="#topic_a4k_w33_xz">Processing XML</a></li><li><a href="#topic_ucn_mkp_xz">Mapping Tables to XML</a></li><li><a href="#topic_gn4_x3w_mq">Using XML Functions and Expressions</a></li></ul><p><strong>Parent topic:</strong> <a href="./../../query/topics/query.html">SQL: Querying Data</a></p><h2 id="creating-xml-values" tabindex="-1"><a id="topic_upc_tcs_fz"></a>Creating XML Values <a class="header-anchor" href="#creating-xml-values" aria-label="Permalink to &quot;&lt;a id=&quot;topic_upc_tcs_fz&quot;&gt;&lt;/a&gt;Creating XML Values&quot;">​</a></h2><p>To produce a value of type <code>xml</code> from character data, use the function <code>xmlparse</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>xmlparse ( { DOCUMENT | CONTENT } value)</span></span></code></pre></div><p>For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>XMLPARSE (DOCUMENT &#39;&lt;?xml version=&quot;1.0&quot;?&gt;&lt;book&gt;&lt;title&gt;Manual&lt;/title&gt;&lt;chapter&gt;...&lt;/chapter&gt;&lt;/book&gt;&#39;)</span></span>
<span class="line"><span>XMLPARSE (CONTENT &#39;abc&lt;foo&gt;bar&lt;/foo&gt;&lt;bar&gt;foo&lt;/bar&gt;&#39;)</span></span></code></pre></div><p>The above method converts character strings into XML values according to the SQL standard, but you can also use WarehousePG syntax like the following:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>xml &#39;&lt;foo&gt;bar&lt;/foo&gt;&#39;</span></span>
<span class="line"><span>&#39;&lt;foo&gt;bar&lt;/foo&gt;&#39;::xml</span></span></code></pre></div><p>The <code>xml</code> type does not validate input values against a document type declaration (DTD), even when the input value specifies a DTD. There is also currently no built-in support for validating against other XML schema languages such as XML schema.</p><p>The inverse operation, producing a character string value from <code>xml</code>, uses the function <code>xmlserialize</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>xmlserialize ( { DOCUMENT | CONTENT } &lt;value&gt; AS &lt;type&gt; )</span></span></code></pre></div><p>type can be <code>character</code>, <code>character varying</code>, or <code>text</code> (or an alias for one of those). Again, according to the SQL standard, this is the only way to convert between type <code>xml</code> and character types, but WarehousePG also allows you to simply cast the value.</p><p>When a character string value is cast to or from type <code>xml</code> without going through <code>XMLPARSE</code> or <code>XMLSERIALIZE</code>, respectively, the choice of <code>DOCUMENT</code> versus <code>CONTENT</code> is determined by the <code>XML OPTION</code> session configuration parameter, which can be set using the standard command:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SET XML OPTION { DOCUMENT | CONTENT };</span></span></code></pre></div><p>or simply like WarehousePG:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SET XML OPTION TO { DOCUMENT | CONTENT };</span></span></code></pre></div><p>The default is CONTENT, so all forms of XML data are allowed.</p><h2 id="encoding-handling" tabindex="-1"><a id="topic_eyt_3tw_mq"></a>Encoding Handling <a class="header-anchor" href="#encoding-handling" aria-label="Permalink to &quot;&lt;a id=&quot;topic_eyt_3tw_mq&quot;&gt;&lt;/a&gt;Encoding Handling&quot;">​</a></h2><p>Be careful when dealing with multiple character encodings on the client, server, and in the XML data passed through them. When using the text mode to pass queries to the server and query results to the client (which is the normal mode), WarehousePG converts all character data passed between the client and the server, and vice versa, to the character encoding of the respective endpoint; see <a href="./../../../ref_guide/character_sets.html#ig167937">Character Set Support</a>. This includes string representations of XML values, such as in the above examples. Ordinarily, this means that encoding declarations contained in XML data can become invalid, as the character data is converted to other encodings while travelling between client and server, because the embedded encoding declaration is not changed. To cope with this behavior, encoding declarations contained in character strings presented for input to the <code>xml</code> type are ignored, and content is assumed to be in the current server encoding. Consequently, for correct processing, character strings of XML data must be sent from the client in the current client encoding. It is the responsibility of the client to either convert documents to the current client encoding before sending them to the server, or to adjust the client encoding appropriately. On output, values of type <code>xml</code> will not have an encoding declaration, and clients should assume all data is in the current client encoding.</p><p>When using binary mode to pass query parameters to the server and query results back to the client, no character set conversion is performed, so the situation is different. In this case, an encoding declaration in the XML data will be observed, and if it is absent, the data will be assumed to be in UTF-8 (as required by the XML standard; note that WarehousePG does not support UTF-16). On output, data will have an encoding declaration specifying the client encoding, unless the client encoding is UTF-8, in which case it will be omitted.</p><blockquote><p><strong>Note</strong> Processing XML data with WarehousePG will be less error-prone and more efficient if the XML data encoding, client encoding, and server encoding are the same. Because XML data is internally processed in UTF-8, computations will be most efficient if the server encoding is also UTF-8.</p></blockquote><h2 id="accessing-xml-values" tabindex="-1"><a id="topic_kxv_4gq_vz"></a>Accessing XML Values <a class="header-anchor" href="#accessing-xml-values" aria-label="Permalink to &quot;&lt;a id=&quot;topic_kxv_4gq_vz&quot;&gt;&lt;/a&gt;Accessing XML Values&quot;">​</a></h2><p>The <code>xml</code> data type is unusual in that it does not provide any comparison operators. This is because there is no well-defined and universally useful comparison algorithm for XML data. One consequence of this is that you cannot retrieve rows by comparing an <code>xml</code> column against a search value. XML values should therefore typically be accompanied by a separate key field such as an ID. An alternative solution for comparing XML values is to convert them to character strings first, but note that character string comparison has little to do with a useful XML comparison method.</p><p>Because there are no comparison operators for the <code>xml</code> data type, it is not possible to create an index directly on a column of this type. If speedy searches in XML data are desired, possible workarounds include casting the expression to a character string type and indexing that, or indexing an XPath expression. Of course, the actual query would have to be adjusted to search by the indexed expression.</p><h2 id="processing-xml" tabindex="-1"><a id="topic_a4k_w33_xz"></a>Processing XML <a class="header-anchor" href="#processing-xml" aria-label="Permalink to &quot;&lt;a id=&quot;topic_a4k_w33_xz&quot;&gt;&lt;/a&gt;Processing XML&quot;">​</a></h2><p>To process values of data type <code>xml</code>, WarehousePG offers the functions <code>xpath</code> and <code>xpath_exists</code>, which evaluate XPath 1.0 expressions.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>xpath(&lt;xpath&gt;, &lt;xml&gt; [, &lt;nsarray&gt;])</span></span></code></pre></div><p>The function <code>xpath</code> evaluates the XPath expression <code>xpath</code> (a text value) against the XML value <code>xml</code>. It returns an array of XML values corresponding to the node set produced by the XPath expression.</p><p>The second argument must be a well formed XML document. In particular, it must have a single root node element.</p><p>The optional third argument of the function is an array of namespace mappings. This array should be a two-dimensional text array with the length of the second axis being equal to 2 (i.e., it should be an array of arrays, each of which consists of exactly 2 elements). The first element of each array entry is the namespace name (alias), the second the namespace URI. It is not required that aliases provided in this array be the same as those being used in the XML document itself (in other words, both in the XML document and in the <code>xpath</code> function context, aliases are local).</p><p>Example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT xpath(&#39;/my:a/&lt;text&gt;()&#39;, &#39;&lt;my:a xmlns:my=&quot;http://example.com&quot;&gt;test&lt;/my:a&gt;&#39;,</span></span>
<span class="line"><span>             ARRAY[ARRAY[&#39;my&#39;, &#39;http://example.com&#39;]]);</span></span>
<span class="line"><span></span></span>
<span class="line"><span> xpath  </span></span>
<span class="line"><span>--------</span></span>
<span class="line"><span> {test}</span></span>
<span class="line"><span>(1 row)</span></span></code></pre></div><p>To deal with default (anonymous) namespaces, do something like this:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT xpath(&#39;//mydefns:b/&lt;text&gt;()&#39;, &#39;&lt;a xmlns=&quot;http://example.com&quot;&gt;&lt;b&gt;test&lt;/b&gt;&lt;/a&gt;&#39;,</span></span>
<span class="line"><span>             ARRAY[ARRAY[&#39;mydefns&#39;, &#39;http://example.com&#39;]]);</span></span>
<span class="line"><span></span></span>
<span class="line"><span> xpath</span></span>
<span class="line"><span>--------</span></span>
<span class="line"><span> {test}</span></span>
<span class="line"><span>(1 row)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>xpath_exists(&lt;xpath&gt;, &lt;xml&gt; [, &lt;nsarray&gt;])</span></span></code></pre></div><p>The function <code>xpath_exists</code> is a specialized form of the <code>xpath</code> function. Instead of returning the individual XML values that satisfy the XPath, this function returns a Boolean indicating whether the query was satisfied or not. This function is equivalent to the standard <code>XMLEXISTS</code> predicate, except that it also offers support for a namespace mapping argument.</p><p>Example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT xpath_exists(&#39;/my:a/&lt;text&gt;()&#39;, &#39;&lt;my:a xmlns:my=&quot;http://example.com&quot;&gt;test&lt;/my:a&gt;&#39;,</span></span>
<span class="line"><span>                     ARRAY[ARRAY[&#39;my&#39;, &#39;http://example.com&#39;]]);</span></span>
<span class="line"><span></span></span>
<span class="line"><span> xpath_exists  </span></span>
<span class="line"><span>--------------</span></span>
<span class="line"><span> t</span></span>
<span class="line"><span>(1 row)</span></span></code></pre></div><h2 id="mapping-tables-to-xml" tabindex="-1"><a id="topic_ucn_mkp_xz"></a>Mapping Tables to XML <a class="header-anchor" href="#mapping-tables-to-xml" aria-label="Permalink to &quot;&lt;a id=&quot;topic_ucn_mkp_xz&quot;&gt;&lt;/a&gt;Mapping Tables to XML&quot;">​</a></h2><p>The following functions map the contents of relational tables to XML values. They can be thought of as XML export functionality:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>table_to_xml(tbl regclass, nulls boolean, tableforest boolean, targetns text)</span></span>
<span class="line"><span>query_to_xml(query &lt;text&gt;, nulls boolean, tableforest boolean, targetns text)</span></span>
<span class="line"><span>cursor_to_xml(cursor refcursor, count int, nulls boolean,</span></span>
<span class="line"><span>              tableforest boolean, targetns text)</span></span></code></pre></div><p>The return type of each function is <code>xml</code>.</p><p><code>table_to_xml</code> maps the content of the named table, passed as parameter <code>tbl</code>. The <code>regclass</code> type accepts strings identifying tables using the usual notation, including optional schema qualifications and double quotes. <code>query_to_xml</code> runs the query whose text is passed as parameter query and maps the result set. <code>cursor_to_xml</code> fetches the indicated number of rows from the cursor specified by the parameter cursor. This variant is recommended if large tables have to be mapped, because the result value is built up in memory by each function.</p><p>If <code>tableforest</code> is false, then the resulting XML document looks like this:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;tablename&gt;</span></span>
<span class="line"><span>  &lt;row&gt;</span></span>
<span class="line"><span>    &lt;columnname1&gt;data&lt;/columnname1&gt;</span></span>
<span class="line"><span>    &lt;columnname2&gt;data&lt;/columnname2&gt;</span></span>
<span class="line"><span>  &lt;/row&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  &lt;row&gt;</span></span>
<span class="line"><span>    ...</span></span>
<span class="line"><span>  &lt;/row&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  ...</span></span>
<span class="line"><span>&lt;/tablename&gt;</span></span></code></pre></div><p>If <code>tableforest</code> is true, the result is an XML content fragment that looks like this:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;tablename&gt;</span></span>
<span class="line"><span>  &lt;columnname1&gt;data&lt;/columnname1&gt;</span></span>
<span class="line"><span>  &lt;columnname2&gt;data&lt;/columnname2&gt;</span></span>
<span class="line"><span>&lt;/tablename&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&lt;tablename&gt;</span></span>
<span class="line"><span>  ...</span></span>
<span class="line"><span>&lt;/tablename&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>...</span></span></code></pre></div><p>If no table name is available, that is, when mapping a query or a cursor, the string <code>table</code> is used in the first format, <code>row</code> in the second format.</p><p>The choice between these formats is up to the user. The first format is a proper XML document, which will be important in many applications. The second format tends to be more useful in the <code>cursor_to_xml</code> function if the result values are to be later reassembled into one document. The functions for producing XML content discussed above, in particular <code>xmlelement</code>, can be used to alter the results as desired.</p><p>The data values are mapped in the same way as described for the function <code>xmlelement</code>, above.</p><p>The parameter nulls determines whether null values should be included in the output. If true, null values in columns are represented as:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;columnname xsi:nil=&quot;true&quot;/&gt;</span></span></code></pre></div><p>where <code>xsi</code> is the XML namespace prefix for XML schema Instance. An appropriate namespace declaration will be added to the result value. If false, columns containing null values are simply omitted from the output.</p><p>The parameter <code>targetns</code> specifies the desired XML namespace of the result. If no particular namespace is wanted, an empty string should be passed.</p><p>The following functions return XML schema documents describing the mappings performed by the corresponding functions above:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>able_to_xmlschema(tbl regclass, nulls boolean, tableforest boolean, targetns text)</span></span>
<span class="line"><span>query_to_xmlschema(query &lt;text&gt;, nulls boolean, tableforest boolean, targetns text)</span></span>
<span class="line"><span>cursor_to_xmlschema(cursor refcursor, nulls boolean, tableforest boolean, targetns text)</span></span></code></pre></div><p>It is essential that the same parameters are passed in order to obtain matching XML data mappings and XML schema documents.</p><p>The following functions produce XML data mappings and the corresponding XML schema in one document (or <code>forest</code>), linked together. They can be useful where self-contained and self-describing results are desired:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>table_to_xml_and_xmlschema(tbl regclass, nulls boolean, tableforest boolean, targetns text)</span></span>
<span class="line"><span>query_to_xml_and_xmlschema(query &lt;text&gt;, nulls boolean, tableforest boolean, targetns text)</span></span></code></pre></div><p>In addition, the following functions are available to produce analogous mappings of entire schemas or the entire current database:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>schema_to_xml(schema name, nulls boolean, tableforest boolean, targetns text)</span></span>
<span class="line"><span>schema_to_xmlschema(schema name, nulls boolean, tableforest boolean, targetns text)</span></span>
<span class="line"><span>schema_to_xml_and_xmlschema(schema name, nulls boolean, tableforest boolean, targetns text)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>database_to_xml(nulls boolean, tableforest boolean, targetns text)</span></span>
<span class="line"><span>database_to_xmlschema(nulls boolean, tableforest boolean, targetns text)</span></span>
<span class="line"><span>database_to_xml_and_xmlschema(nulls boolean, tableforest boolean, targetns text)</span></span></code></pre></div><p>Note that these potentially produce large amounts of data, which needs to be built up in memory. When requesting content mappings of large schemas or databases, consider mapping the tables separately instead, possibly even through a cursor.</p><p>The result of a schema content mapping looks like this:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;schemaname&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>table1-mapping</span></span>
<span class="line"><span></span></span>
<span class="line"><span>table2-mapping</span></span>
<span class="line"><span></span></span>
<span class="line"><span>...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&lt;/schemaname&gt;</span></span></code></pre></div><p>where the format of a table mapping depends on the <code>tableforest</code> parameter, as explained above.</p><p>The result of a database content mapping looks like this:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;dbname&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&lt;schema1name&gt;</span></span>
<span class="line"><span>  ...</span></span>
<span class="line"><span>&lt;/schema1name&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&lt;schema2name&gt;</span></span>
<span class="line"><span>  ...</span></span>
<span class="line"><span>&lt;/schema2name&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&lt;/dbname&gt;</span></span></code></pre></div><p>where the schema mapping is as above.</p><p>The example below demonstrates using the output produced by these functions, The example shows an XSLT stylesheet that converts the output of <code>table_to_xml_and_xmlschema</code> to an HTML document containing a tabular rendition of the table data. In a similar manner, the results from these functions can be converted into other XML-based formats.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;?xml version=&quot;1.0&quot;?&gt;</span></span>
<span class="line"><span>&lt;xsl:stylesheet version=&quot;1.0&quot;</span></span>
<span class="line"><span>    xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;</span></span>
<span class="line"><span>    xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;</span></span>
<span class="line"><span>    xmlns=&quot;http://www.w3.org/1999/xhtml&quot;</span></span>
<span class="line"><span>&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  &lt;xsl:output method=&quot;xml&quot;</span></span>
<span class="line"><span>      doctype-system=&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;</span></span>
<span class="line"><span>      doctype-public=&quot;-//W3C/DTD XHTML 1.0 Strict//EN&quot;</span></span>
<span class="line"><span>      indent=&quot;yes&quot;/&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  &lt;xsl:template match=&quot;/*&quot;&gt;</span></span>
<span class="line"><span>    &lt;xsl:variable name=&quot;schema&quot; select=&quot;//xsd:schema&quot;/&gt;</span></span>
<span class="line"><span>    &lt;xsl:variable name=&quot;tabletypename&quot;</span></span>
<span class="line"><span>                  select=&quot;$schema/xsd:element[@name=name(current())]/@type&quot;/&gt;</span></span>
<span class="line"><span>    &lt;xsl:variable name=&quot;rowtypename&quot;</span></span>
<span class="line"><span>                  select=&quot;$schema/xsd:complexType[@name=$tabletypename]/xsd:sequence/xsd:element[@name=&#39;row&#39;]/@type&quot;/&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    &lt;html&gt;</span></span>
<span class="line"><span>      &lt;head&gt;</span></span>
<span class="line"><span>        &lt;title&gt;&lt;xsl:value-of select=&quot;name(current())&quot;/&gt;&lt;/title&gt;</span></span>
<span class="line"><span>      &lt;/head&gt;</span></span>
<span class="line"><span>      &lt;body&gt;</span></span>
<span class="line"><span>        &lt;table&gt;</span></span>
<span class="line"><span>          &lt;tr&gt;</span></span>
<span class="line"><span>            &lt;xsl:for-each select=&quot;$schema/xsd:complexType[@name=$rowtypename]/xsd:sequence/xsd:element/@name&quot;&gt;</span></span>
<span class="line"><span>              &lt;th&gt;&lt;xsl:value-of select=&quot;.&quot;/&gt;&lt;/th&gt;</span></span>
<span class="line"><span>            &lt;/xsl:for-each&gt;</span></span>
<span class="line"><span>          &lt;/tr&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>          &lt;xsl:for-each select=&quot;row&quot;&gt;</span></span>
<span class="line"><span>            &lt;tr&gt;</span></span>
<span class="line"><span>              &lt;xsl:for-each select=&quot;*&quot;&gt;</span></span>
<span class="line"><span>                &lt;td&gt;&lt;xsl:value-of select=&quot;.&quot;/&gt;&lt;/td&gt;</span></span>
<span class="line"><span>              &lt;/xsl:for-each&gt;</span></span>
<span class="line"><span>            &lt;/tr&gt;</span></span>
<span class="line"><span>          &lt;/xsl:for-each&gt;</span></span>
<span class="line"><span>        &lt;/table&gt;</span></span>
<span class="line"><span>      &lt;/body&gt;</span></span>
<span class="line"><span>    &lt;/html&gt;</span></span>
<span class="line"><span>  &lt;/xsl:template&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&lt;/xsl:stylesheet&gt;</span></span></code></pre></div><h2 id="xml-function-reference" tabindex="-1"><a id="topic_gn4_x3w_mq"></a>XML Function Reference <a class="header-anchor" href="#xml-function-reference" aria-label="Permalink to &quot;&lt;a id=&quot;topic_gn4_x3w_mq&quot;&gt;&lt;/a&gt;XML Function Reference&quot;">​</a></h2><p>The functions described in this section operate on values of type <code>xml</code>. The section <a href="#topic_zpg_jl2_wz">XML Predicates</a>also contains information about the <code>xml</code> functions and function-like expressions.</p><p><strong>Function:</strong></p><p><code>xmlcomment</code></p><p><strong>Synopsis:</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>xmlcomment(&lt;text&gt;)</span></span></code></pre></div><p>The function <code>xmlcomment</code> creates an XML value containing an XML comment with the specified text as content. The text cannot contain &quot;--&quot; or end with a &quot;-&quot; so that the resulting construct is a valid XML comment. If the argument is null, the result is null.</p><p>Example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT xmlcomment(&#39;hello&#39;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  xmlcomment</span></span>
<span class="line"><span>--------------</span></span>
<span class="line"><span> &lt;!--hello--&gt;</span></span></code></pre></div><p><strong>Function:</strong></p><p><code>xmlconcat</code></p><p><strong>Synopsis:</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>xmlconcat(xml[, …])</span></span></code></pre></div><p>The function <code>xmlconcat</code> concatenates a list of individual XML values to create a single value containing an XML content fragment. Null values are omitted; the result is only null if there are no nonnull arguments.</p><p>Example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT xmlconcat(&#39;&lt;abc/&gt;&#39;, &#39;&lt;bar&gt;foo&lt;/bar&gt;&#39;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      xmlconcat</span></span>
<span class="line"><span>----------------------</span></span>
<span class="line"><span> &lt;abc/&gt;&lt;bar&gt;foo&lt;/bar&gt;</span></span></code></pre></div><p>XML declarations, if present, are combined as follows:</p><ul><li>If all argument values have the same XML version declaration, that version is used in the result, else no version is used.</li><li>If all argument values have the standalone declaration value &quot;yes&quot;, then that value is used in the result.</li><li>If all argument values have a standalone declaration value and at least one is &quot;no&quot;, then that is used in the result. Otherwise, the result will have no standalone declaration.</li><li>If the result is determined to require a standalone declaration but no version declaration, a version declaration with version 1.0 will be used because XML requires an XML declaration to contain a version declaration.</li></ul><p>Encoding declarations are ignored and removed in all cases.</p><p>Example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT xmlconcat(&#39;&lt;?xml version=&quot;1.1&quot;?&gt;&lt;foo/&gt;&#39;, &#39;&lt;?xml version=&quot;1.1&quot; standalone=&quot;no&quot;?&gt;&lt;bar/&gt;&#39;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>             xmlconcat</span></span>
<span class="line"><span>-----------------------------------</span></span>
<span class="line"><span> &lt;?xml version=&quot;1.1&quot;?&gt;&lt;foo/&gt;&lt;bar/&gt;</span></span></code></pre></div><p><strong>Function:</strong></p><p><code>xmlelement</code></p><p><strong>Synopsis:</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>xmlelement(name name [, xmlattributes(value [AS attname] [, ... ])] [, content, ...])</span></span></code></pre></div><p>The <code>xmlelement</code> expression produces an XML element with the given name, attributes, and content.</p><p>Examples:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT xmlelement(name foo);</span></span>
<span class="line"><span></span></span>
<span class="line"><span> xmlelement</span></span>
<span class="line"><span>------------</span></span>
<span class="line"><span> &lt;foo/&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>SELECT xmlelement(name foo, xmlattributes(&#39;xyz&#39; as bar));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    xmlelement</span></span>
<span class="line"><span>------------------</span></span>
<span class="line"><span> &lt;foo bar=&quot;xyz&quot;/&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>SELECT xmlelement(name foo, xmlattributes(current_date as bar), &#39;cont&#39;, &#39;ent&#39;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>             xmlelement</span></span>
<span class="line"><span>-------------------------------------</span></span>
<span class="line"><span> &lt;foo bar=&quot;2017-01-26&quot;&gt;content&lt;/foo&gt;</span></span></code></pre></div><p>Element and attribute names that are not valid XML names are escaped by replacing the offending characters by the sequence <code>_xHHHH_</code>, where HHHH is the character&#39;s Unicode codepoint in hexadecimal notation. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT xmlelement(name &quot;foo$bar&quot;, xmlattributes(&#39;xyz&#39; as &quot;a&amp;b&quot;));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            xmlelement</span></span>
<span class="line"><span>----------------------------------</span></span>
<span class="line"><span> &lt;foo_x0024_bar a_x0026_b=&quot;xyz&quot;/&gt;</span></span></code></pre></div><p>An explicit attribute name need not be specified if the attribute value is a column reference, in which case the column&#39;s name will be used as the attribute name by default. In other cases, the attribute must be given an explicit name. So this example is valid:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE TABLE test (a xml, b xml);</span></span>
<span class="line"><span>SELECT xmlelement(name test, xmlattributes(a, b)) FROM test;</span></span></code></pre></div><p>But these are not:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT xmlelement(name test, xmlattributes(&#39;constant&#39;), a, b) FROM test;</span></span>
<span class="line"><span>SELECT xmlelement(name test, xmlattributes(func(a, b))) FROM test;</span></span></code></pre></div><p>Element content, if specified, will be formatted according to its data type. If the content is itself of type <code>xml</code>, complex XML documents can be constructed. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT xmlelement(name foo, xmlattributes(&#39;xyz&#39; as bar),</span></span>
<span class="line"><span>                            xmlelement(name abc),</span></span>
<span class="line"><span>                            xmlcomment(&#39;test&#39;),</span></span>
<span class="line"><span>                            xmlelement(name xyz));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>                  xmlelement</span></span>
<span class="line"><span>----------------------------------------------</span></span>
<span class="line"><span> &lt;foo bar=&quot;xyz&quot;&gt;&lt;abc/&gt;&lt;!--test--&gt;&lt;xyz/&gt;&lt;/foo&gt;</span></span></code></pre></div><p>Content of other types will be formatted into valid XML character data. This means in particular that the characters <code>&lt;</code>, <code>&gt;</code>, and <code>&amp;</code> will be converted to entities. Binary data (data type <code>bytea</code>) will be represented in base64 or hex encoding, depending on the setting of the configuration parameter <a href="https://www.postgresql.org/docs/12/runtime-config-client.html#GUC-XMLBINARY" target="_blank" rel="noreferrer">xmlbinary</a>. The particular behavior for individual data types is expected to evolve in order to align the SQL and WarehousePG data types with the XML schema specification, at which point a more precise description will appear.</p><p><strong>Function:</strong></p><p><code>xmlforest</code></p><p><strong>Synopsis:</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>xmlforest(&lt;content&gt; [AS &lt;name&gt;] [, ...])</span></span></code></pre></div><p>The <code>xmlforest</code> expression produces an XML forest (sequence) of elements using the given names and content.</p><p>Examples:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT xmlforest(&#39;abc&#39; AS foo, 123 AS bar);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>          xmlforest</span></span>
<span class="line"><span>------------------------------</span></span>
<span class="line"><span> &lt;foo&gt;abc&lt;/foo&gt;&lt;bar&gt;123&lt;/bar&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>SELECT xmlforest(table_name, column_name)</span></span>
<span class="line"><span>FROM information_schema.columns</span></span>
<span class="line"><span>WHERE table_schema = &#39;pg_catalog&#39;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>                                         xmlforest</span></span>
<span class="line"><span>-------------------------------------------------------------------------------------------</span></span>
<span class="line"><span> &lt;table_name&gt;pg_authid&lt;/table_name&gt;&lt;column_name&gt;rolname&lt;/column_name&gt;</span></span>
<span class="line"><span> &lt;table_name&gt;pg_authid&lt;/table_name&gt;&lt;column_name&gt;rolsuper&lt;/column_name&gt;</span></span></code></pre></div><p>As seen in the second example, the element name can be omitted if the content value is a column reference, in which case the column name is used by default. Otherwise, a name must be specified.</p><p>Element names that are not valid XML names are escaped as shown for <code>xmlelement</code> above. Similarly, content data is escaped to make valid XML content, unless it is already of type <code>xml</code>.</p><p>Note that XML forests are not valid XML documents if they consist of more than one element, so it might be useful to wrap <code>xmlforest</code> expressions in <code>xmlelement</code>.</p><p><strong>Function:</strong></p><p><code>xmlpi</code></p><p><strong>Synopsis:</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>xmlpi(name &lt;target&gt; [, &lt;content&gt;])</span></span></code></pre></div><p>The <code>xmlpi</code> expression creates an XML processing instruction. The content, if present, must not contain the character sequence <code>?&gt;</code>.</p><p>Example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT xmlpi(name php, &#39;echo &quot;hello world&quot;;&#39;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            xmlpi</span></span>
<span class="line"><span>-----------------------------</span></span>
<span class="line"><span> &lt;?php echo &quot;hello world&quot;;?&gt;</span></span></code></pre></div><p><strong>Function:</strong></p><p><code>xmlroot</code></p><p><strong>Synopsis:</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>xmlroot(&lt;xml&gt;, version &lt;text&gt; | no value [, standalone yes|no|no value])</span></span></code></pre></div><p>The <code>xmlroot</code> expression alters the properties of the root node of an XML value. If a version is specified, it replaces the value in the root node&#39;s version declaration; if a standalone setting is specified, it replaces the value in the root node&#39;s standalone declaration.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT xmlroot(xmlparse(document &#39;&lt;?xml version=&quot;1.1&quot;?&gt;&lt;content&gt;abc&lt;/content&gt;&#39;),</span></span>
<span class="line"><span>               version &#39;1.0&#39;, standalone yes);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>                xmlroot</span></span>
<span class="line"><span>----------------------------------------</span></span>
<span class="line"><span> &lt;?xml version=&quot;1.0&quot; standalone=&quot;yes&quot;?&gt;</span></span>
<span class="line"><span> &lt;content&gt;abc&lt;/content&gt;</span></span></code></pre></div><p><strong>Function:</strong></p><p><code>xmlagg</code></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>xmlagg (&lt;xml&gt;)</span></span></code></pre></div><p>The function <code>xmlagg</code> is, unlike the other functions described here, an aggregate function. It concatenates the input values to the aggregate function call, much like <code>xmlconcat</code> does, except that concatenation occurs across rows rather than across expressions in a single row. See <a href="./functions-operators.html#in151167">Using Functions and Operators</a> for additional information about aggregate functions.</p><p>Example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE TABLE test (y int, x xml);</span></span>
<span class="line"><span>INSERT INTO test VALUES (1, &#39;&lt;foo&gt;abc&lt;/foo&gt;&#39;);</span></span>
<span class="line"><span>INSERT INTO test VALUES (2, &#39;&lt;bar/&gt;&#39;);</span></span>
<span class="line"><span>SELECT xmlagg(x) FROM test;</span></span>
<span class="line"><span>        xmlagg</span></span>
<span class="line"><span>----------------------</span></span>
<span class="line"><span> &lt;foo&gt;abc&lt;/foo&gt;&lt;bar/&gt;</span></span></code></pre></div><p>To determine the order of the concatenation, an <code>ORDER BY</code> clause may be added to the aggregate call. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT xmlagg(x ORDER BY y DESC) FROM test;</span></span>
<span class="line"><span>        xmlagg</span></span>
<span class="line"><span>----------------------</span></span>
<span class="line"><span> &lt;bar/&gt;&lt;foo&gt;abc&lt;/foo&gt;</span></span></code></pre></div><p>The following non-standard approach used to be recommended in previous versions, and may still be useful in specific cases:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT xmlagg(x) FROM (SELECT * FROM test ORDER BY y DESC) AS tab;</span></span>
<span class="line"><span>        xmlagg</span></span>
<span class="line"><span>----------------------</span></span>
<span class="line"><span> &lt;bar/&gt;&lt;foo&gt;abc&lt;/foo&gt;</span></span></code></pre></div><h2 id="xml-predicates" tabindex="-1"><a id="topic_zpg_jl2_wz"></a>XML Predicates <a class="header-anchor" href="#xml-predicates" aria-label="Permalink to &quot;&lt;a id=&quot;topic_zpg_jl2_wz&quot;&gt;&lt;/a&gt;XML Predicates&quot;">​</a></h2><p>The expressions described in this section check properties of <code>xml</code> values.</p><p><strong>Expression:</strong></p><p><code>IS DOCUMENT</code></p><p><strong>Synopsis:</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;xml&gt; IS DOCUMENT</span></span></code></pre></div><p>The expression <code>IS DOCUMENT</code> returns true if the argument XML value is a proper XML document, false if it is not (that is, it is a content fragment), or null if the argument is null.</p><p><strong>Expression:</strong></p><p><code>XMLEXISTS</code></p><p><strong>Synopsis:</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>XMLEXISTS(&lt;text&gt; PASSING [BY REF] &lt;xml&gt; [BY REF])</span></span></code></pre></div><p>The function <code>xmlexists</code> returns true if the XPath expression in the first argument returns any nodes, and false otherwise. (If either argument is null, the result is null.)</p><p>Example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT xmlexists(&#39;//town[&lt;text&gt;() = &#39;&#39;Toronto&#39;&#39;]&#39; PASSING BY REF &#39;&lt;towns&gt;&lt;town&gt;Toronto&lt;/town&gt;&lt;town&gt;Ottawa&lt;/town&gt;&lt;/towns&gt;&#39;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span> xmlexists</span></span>
<span class="line"><span>------------</span></span>
<span class="line"><span> t</span></span>
<span class="line"><span>(1 row)</span></span></code></pre></div><p>The <code>BY REF</code> clauses have no effect in WarehousePG, but are allowed for SQL conformance and compatibility with other implementations. Per SQL standard, the first <code>BY REF</code> is required, the second is optional. Also note that the SQL standard specifies the <code>xmlexists</code> construct to take an XQuery expression as first argument, but WarehousePG currently only supports XPath, which is a subset of XQuery.</p><p><strong>Expression:</strong></p><p><code>xml_is_well_formed</code></p><p><strong>Synopsis:</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>xml_is_well_formed(&lt;text&gt;)</span></span>
<span class="line"><span>xml_is_well_formed_document(&lt;text&gt;)</span></span>
<span class="line"><span>xml_is_well_formed_content(&lt;text&gt;)</span></span></code></pre></div><p>These functions check whether a text string is well-formed XML, returning a Boolean result. <code>xml_is_well_formed_document</code> checks for a well-formed document, while <code>xml_is_well_formed_content</code> checks for well-formed content. <code>xml_is_well_formed</code> does the former if the <code>xmloption</code> configuration parameter is set to <code>DOCUMENT</code>, or the latter if it is set to <code>CONTENT</code>. This means that <code>xml_is_well_formed</code> is useful for seeing whether a simple cast to type <code>xml</code> will succeed, whereas the other two functions are useful for seeing whether the corresponding variants of <code>XMLPARSE</code> will succeed.</p><p>Examples:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SET xmloption TO DOCUMENT;</span></span>
<span class="line"><span>SELECT xml_is_well_formed(&#39;&lt;&gt;&#39;);</span></span>
<span class="line"><span> xml_is_well_formed </span></span>
<span class="line"><span>--------------------</span></span>
<span class="line"><span> f</span></span>
<span class="line"><span>(1 row)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>SELECT xml_is_well_formed(&#39;&lt;abc/&gt;&#39;);</span></span>
<span class="line"><span> xml_is_well_formed </span></span>
<span class="line"><span>--------------------</span></span>
<span class="line"><span> t</span></span>
<span class="line"><span>(1 row)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>SET xmloption TO CONTENT;</span></span>
<span class="line"><span>SELECT xml_is_well_formed(&#39;abc&#39;);</span></span>
<span class="line"><span> xml_is_well_formed </span></span>
<span class="line"><span>--------------------</span></span>
<span class="line"><span> t</span></span>
<span class="line"><span>(1 row)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>SELECT xml_is_well_formed_document(&#39;&lt;pg:foo xmlns:pg=&quot;http://postgresql.org/stuff&quot;&gt;bar&lt;/pg:foo&gt;&#39;);</span></span>
<span class="line"><span> xml_is_well_formed_document </span></span>
<span class="line"><span>-----------------------------</span></span>
<span class="line"><span> t</span></span>
<span class="line"><span>(1 row)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>SELECT xml_is_well_formed_document(&#39;&lt;pg:foo xmlns:pg=&quot;http://postgresql.org/stuff&quot;&gt;bar&lt;/my:foo&gt;&#39;);</span></span>
<span class="line"><span> xml_is_well_formed_document </span></span>
<span class="line"><span>-----------------------------</span></span>
<span class="line"><span> f</span></span>
<span class="line"><span>(1 row)</span></span></code></pre></div><p>The last example shows that the checks include whether namespaces are correctly matched.</p>`,171)]))}const m=s(p,[["render",l]]);export{u as __pageData,m as default};
