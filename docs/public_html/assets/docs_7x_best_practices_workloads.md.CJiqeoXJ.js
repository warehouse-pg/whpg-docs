import{_ as t,c as o,o as r,ag as s}from"./chunks/framework.Ds6Eueu6.js";const h=JSON.parse('{"title":"Memory and Resource Management with Resource Queues","description":"","frontmatter":{},"headers":[],"relativePath":"docs/7x/best_practices/workloads.md","filePath":"docs/7x/best_practices/workloads.md"}'),i={name:"docs/7x/best_practices/workloads.md"};function a(n,e,u,m,l,c){return r(),o("div",null,e[0]||(e[0]=[s(`<h1 id="memory-and-resource-management-with-resource-queues" tabindex="-1">Memory and Resource Management with Resource Queues <a class="header-anchor" href="#memory-and-resource-management-with-resource-queues" aria-label="Permalink to &quot;Memory and Resource Management with Resource Queues&quot;">​</a></h1><hr><p>Avoid memory errors and manage WarehousePG resources.</p><blockquote><p><strong>Note</strong> Resource groups are a newer resource management scheme that enforces memory, CPU, and concurrent transaction limits in WarehousePG. The <a href="./../admin_guide/wlmgmt.html">Managing Resources</a> topic provides a comparison of the resource queue and the resource group management schemes. Refer to <a href="./../admin_guide/workload_mgmt_resgroups.html">Using Resource Groups</a> for configuration and usage information for this resource management scheme.</p></blockquote><p>Memory management has a significant impact on performance in a WarehousePG cluster. The default settings are suitable for most environments. Do not change the default settings until you understand the memory characteristics and usage on your system.</p><ul><li><a href="#section_jqw_qbl_zt">Resolving Out of Memory Errors</a></li><li><a href="#section113x">Low Memory Queries</a></li><li><a href="#section_r52_rbl_zt">Configuring Memory for WarehousePG</a></li><li><a href="#configuring_rq">Configuring Resource Queues</a></li></ul><h2 id="resolving-out-of-memory-errors" tabindex="-1"><a id="section_jqw_qbl_zt"></a>Resolving Out of Memory Errors <a class="header-anchor" href="#resolving-out-of-memory-errors" aria-label="Permalink to &quot;&lt;a id=&quot;section_jqw_qbl_zt&quot;&gt;&lt;/a&gt;Resolving Out of Memory Errors&quot;">​</a></h2><p>An out of memory error message identifies the WarehousePG segment, host, and process that experienced the out of memory error. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Out of memory (seg27 host.example.com pid=47093)</span></span>
<span class="line"><span>VM Protect failed to allocate 4096 bytes, 0 MB available</span></span></code></pre></div><p>Some common causes of out-of-memory conditions in WarehousePG are:</p><ul><li>Insufficient system memory (RAM) available on the cluster</li><li>Improperly configured memory parameters</li><li>Data skew at the segment level</li><li>Operational skew at the query level</li></ul><p>Following are possible solutions to out of memory conditions:</p><ul><li>Tune the query to require less memory</li><li>Reduce query concurrency using a resource queue</li><li>Validate the <code>gp_vmem_protect_limit</code> configuration parameter at the database level. See calculations for the maximum safe setting in <a href="#section_r52_rbl_zt">Configuring Memory for WarehousePG</a>.</li><li>Set the memory quota on a resource queue to limit the memory used by queries run within the resource queue</li><li>Use a session setting to reduce the <code>statement_mem</code> used by specific queries</li><li>Decrease <code>statement_mem</code> at the database level</li><li>Decrease the number of segments per host in the WarehousePG cluster. This solution requires a re-initializing WarehousePG and reloading your data.</li><li>Increase memory on the host, if possible. (Additional hardware may be required.)</li></ul><p>Adding segment hosts to the cluster will not in itself alleviate out of memory problems. The memory used by each query is determined by the <code>statement_mem</code> parameter and it is set when the query is invoked. However, if adding more hosts allows decreasing the number of segments per host, then the amount of memory allocated in <code>gp_vmem_protect_limit</code> can be raised.</p><h2 id="low-memory-queries" tabindex="-1"><a id="section113x"></a>Low Memory Queries <a class="header-anchor" href="#low-memory-queries" aria-label="Permalink to &quot;&lt;a id=&quot;section113x&quot;&gt;&lt;/a&gt;Low Memory Queries&quot;">​</a></h2><p>A low <code>statement_mem</code> setting (for example, in the 1-3MB range) has been shown to increase the performance of queries with low memory requirements. Use the <code>statement_mem</code> server configuration parameter to override the setting on a per-query basis. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SET statement_mem=&#39;2MB&#39;;</span></span></code></pre></div><h2 id="configuring-memory-for-warehousepg" tabindex="-1"><a id="section_r52_rbl_zt"></a>Configuring Memory for WarehousePG <a class="header-anchor" href="#configuring-memory-for-warehousepg" aria-label="Permalink to &quot;&lt;a id=&quot;section_r52_rbl_zt&quot;&gt;&lt;/a&gt;Configuring Memory for WarehousePG&quot;">​</a></h2><p>Most out of memory conditions can be avoided if memory is thoughtfully managed.</p><p>It is not always possible to increase system memory, but you can prevent out-of-memory conditions by configuring memory use correctly and setting up resource queues to manage expected workloads.</p><p>It is important to include memory requirements for mirror segments that become primary segments during a failure to ensure that the cluster can continue when primary segments or segment hosts fail.</p><p>The following are recommended operating system and WarehousePG memory settings:</p><ul><li><p>Do not configure the OS to use huge pages.</p></li><li><p><strong>vm.overcommit_memory</strong></p><p>This is a Linux kernel parameter, set in <code>/etc/sysctl.conf</code> and it should always be set to 2. It determines the method the OS uses for determining how much memory can be allocated to processes and 2 is the only safe setting for WarehousePG. Please review the sysctl parameters in the <a href="./../install_guide/config_os.html#topic3__sysctl_file">WarehousePG Installation Guide</a>.</p></li><li><p><strong>vm.overcommit_ratio</strong></p><p>This is a Linux kernel parameter, set in <a href="./../install_guide/config_os.html#topic3__sysctl_file"><code>/etc/sysctl.conf</code></a>. It is the percentage of RAM that is used for application processes. The remainder is reserved for the operating system. The default on Red Hat is 50.</p><p>Setting <code>vm.overcommit_ratio</code> too high may result in not enough memory being reserved for the operating system, which can result in segment host failure or database failure. Setting the value too low reduces the amount of concurrency and query complexity that can be run by reducing the amount of memory available to WarehousePG. When increasing the setting it is important to remember to always reserve some memory for operating system activities.</p><p>See <a href="./../admin_guide/wlmgmt_intro.html">WarehousePG Memory Overview</a> for instructions to calculate a value for <code>vm.overcommit_ratio</code>.</p></li><li><p><strong>gp_vmem_protect_limit</strong></p><p>Use <code>gp_vmem_protect_limit</code> to set the maximum memory that the instance can allocate for <em>all</em> work being done in each segment database. Never set this value larger than the physical RAM on the system. If <code>gp_vmem_protect_limit</code> is too high, it is possible for memory to become exhausted on the system and normal operations may fail, causing segment failures. If <code>gp_vmem_protect_limit</code> is set to a safe lower value, true memory exhaustion on the system is prevented; queries may fail for hitting the limit, but system disruption and segment failures are avoided, which is the desired behavior.</p><p>See <a href="./sysconfig.html#segment_mem_config">Resource Queue Segment Memory Configuration</a> for instructions to calculate a safe value for <code>gp_vmem_protect_limit</code>.</p></li><li><p><strong>runaway_detector_activation_percent</strong></p><p>Runaway Query Termination, prevents out of memory conditions. The <code>runaway_detector_activation_percent</code> system parameter controls the percentage of <code>gp_vmem_protect_limit</code> memory utilized that triggers termination of queries. It is set on by default at 90%. If the percentage of <code>gp_vmem_protect_limit</code> memory that is utilized for a segment exceeds the specified value, WarehousePG terminates queries based on memory usage, beginning with the query consuming the largest amount of memory. Queries are terminated until the utilized percentage of <code>gp_vmem_protect_limit</code> is below the specified percentage.</p></li><li><p><strong>statement_mem</strong></p><p>Use <code>statement_mem</code> to allocate memory used for a query per segment database. If additional memory is required it will spill to disk. Set the optimal value for <code>statement_mem</code> as follows:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(vmprotect * .9) / max_expected_concurrent_queries</span></span></code></pre></div><p>The default value of <code>statement_mem</code> is 125MB. For example, on a system that is configured with 8 segments per host, a query uses 1GB of memory on each segment server (8 segments ⨉ 125MB) with the default <code>statement_mem</code> setting. Set <code>statement_mem</code> at the session level for specific queries that require additional memory to complete. This setting works well to manage query memory on clusters with low concurrency. For clusters with high concurrency also use resource queues to provide additional control on what and how much is running on the system.</p></li><li><p><strong>gp_workfile_limit_files_per_query</strong></p><p>Set <code>gp_workfile_limit_files_per_query</code> to limit the maximum number of temporary spill files (workfiles) allowed per query. Spill files are created when a query requires more memory than it is allocated. When the limit is exceeded the query is terminated. The default is zero, which allows an unlimited number of spill files and may fill up the file system.</p></li><li><p><strong>gp_workfile_compression</strong></p><p>If there are numerous spill files then set <code>gp_workfile_compression</code> to compress the spill files. Compressing spill files may help to avoid overloading the disk subsystem with IO operations.</p></li></ul><h2 id="configuring-resource-queues" tabindex="-1"><a id="configuring_rq"></a>Configuring Resource Queues <a class="header-anchor" href="#configuring-resource-queues" aria-label="Permalink to &quot;&lt;a id=&quot;configuring_rq&quot;&gt;&lt;/a&gt;Configuring Resource Queues&quot;">​</a></h2><p>WarehousePG resource queues provide a powerful mechanism for managing the workload of the cluster. Queues can be used to limit both the numbers of active queries and the amount of memory that can be used by queries in the queue. When a query is submitted to WarehousePG, it is added to a resource queue, which determines if the query should be accepted and when the resources are available to run it.</p><ul><li><p>Associate all roles with an administrator-defined resource queue.</p><p>Each login user (role) is associated with a single resource queue; any query the user submits is handled by the associated resource queue. If a queue is not explicitly assigned the user&#39;s queries are handed by the default queue, <code>pg_default</code>.</p></li><li><p>Do not run queries with the gpadmin role or other superuser roles.</p><p>Superusers are exempt from resource queue limits, therefore superuser queries always run regardless of the limits set on their assigned queue.</p></li><li><p>Use the <code>ACTIVE_STATEMENTS</code> resource queue parameter to limit the number of active queries that members of a particular queue can run concurrently.</p></li><li><p>Use the <code>MEMORY_LIMIT</code> parameter to control the total amount of memory that queries running through the queue can utilize. By combining the <code>ACTIVE_STATEMENTS</code> and <code>MEMORY_LIMIT</code> attributes an administrator can fully control the activity emitted from a given resource queue.</p><p>The allocation works as follows: Suppose a resource queue, <code>sample_queue</code>, has <code>ACTIVE_STATEMENTS</code> set to 10 and <code>MEMORY_LIMIT</code> set to 2000MB. This limits the queue to approximately 2 gigabytes of memory per segment. For a cluster with 8 segments per server, the total usage per server is 16 GB for <code>sample_queue</code> (2GB * 8 segments/server). If a segment server has 64GB of RAM, there could be no more than four of this type of resource queue on the system before there is a chance of running out of memory (4 queues * 16GB per queue).</p><p>Note that by using <code>STATEMENT_MEM</code>, individual queries running in the queue can allocate more than their &quot;share&quot; of memory, thus reducing the memory available for other queries in the queue.</p></li><li><p>Resource queue priorities can be used to align workloads with desired outcomes. Queues with <code>MAX</code> priority throttle activity in all other queues until the <code>MAX</code> queue completes running all queries.</p></li><li><p>Alter resource queues dynamically to match the real requirements of the queue for the workload and time of day. You can script an operational flow that changes based on the time of day and type of usage of the system and add <code>crontab</code> entries to run the scripts.</p></li><li><p>Use gptoolkit to view resource queue usage and to understand how the queues are working.</p></li></ul><p><strong>Parent topic:</strong> <a href="./intro.html">WarehousePG Best Practices</a></p>`,27)]))}const p=t(i,[["render",a]]);export{h as __pageData,p as default};
