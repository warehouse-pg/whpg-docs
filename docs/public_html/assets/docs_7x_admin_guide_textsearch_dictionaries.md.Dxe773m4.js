import{_ as s,c as a,o as n,ag as i}from"./chunks/framework.Ds6Eueu6.js";const u=JSON.parse('{"title":"Text Search Dictionaries","description":"","frontmatter":{},"headers":[],"relativePath":"docs/7x/admin_guide/textsearch/dictionaries.md","filePath":"docs/7x/admin_guide/textsearch/dictionaries.md"}'),t={name:"docs/7x/admin_guide/textsearch/dictionaries.md"};function o(p,e,l,r,c,d){return n(),a("div",null,e[0]||(e[0]=[i(`<h1 id="text-search-dictionaries" tabindex="-1">Text Search Dictionaries <a class="header-anchor" href="#text-search-dictionaries" aria-label="Permalink to &quot;Text Search Dictionaries&quot;">​</a></h1><hr><p>Tokens produced by the WarehousePG full text search parser are passed through a chain of dictionaries to produce a normalized term or &quot;lexeme&quot;. Different kinds of dictionaries are available to filter and transform tokens in different ways and for different languages.</p><p>This section contains the following subtopics:</p><ul><li><a href="#section_j2z_lzw_4fb">About Text Search Dictionaries</a></li><li><a href="#stop-words">Stop Words</a></li><li><a href="#simple">Simple Dictionary</a></li><li><a href="#synonym">Synonym Dictionary</a></li><li><a href="#thesaurus-dictionary">Thesaurus Dictionary</a></li><li><a href="#ispell">Ispell Dictionary</a></li><li><a href="#section_xgc_2zw_4fb">SnowBall Dictionary</a></li></ul><h2 id="about-text-search-dictionaries" tabindex="-1"><a id="section_j2z_lzw_4fb"></a>About Text Search Dictionaries <a class="header-anchor" href="#about-text-search-dictionaries" aria-label="Permalink to &quot;&lt;a id=&quot;section_j2z_lzw_4fb&quot;&gt;&lt;/a&gt;About Text Search Dictionaries&quot;">​</a></h2><p>Dictionaries are used to eliminate words that should not be considered in a search (<em>stop words</em>), and to <em>normalize</em> words so that different derived forms of the same word will match. A successfully normalized word is called a <em>lexeme</em>. Aside from improving search quality, normalization and removal of stop words reduces the size of the <code>tsvector</code> representation of a document, thereby improving performance. Normalization does not always have linguistic meaning and usually depends on application semantics.</p><p>Some examples of normalization:</p><ul><li>Linguistic - Ispell dictionaries try to reduce input words to a normalized form; stemmer dictionaries remove word endings</li><li>URL locations can be canonicalized to make equivalent URLs match: <ul><li><code>http://www.pgsql.ru/db/mw/index.html</code></li><li><code>http://www.pgsql.ru/db/mw/</code></li><li><code>http://www.pgsql.ru/db/../db/mw/index.html</code></li></ul></li><li>Color names can be replaced by their hexadecimal values, e.g., <code>red</code>, <code>green</code>, <code>blue</code>, <code>magenta</code> -&gt; <code>FF0000</code>, <code>00FF00</code>, <code>0000FF</code>, <code>FF00FF</code></li><li>If indexing numbers, we can remove some fractional digits to reduce the range of possible numbers, so for example 3.14159265359, 3.1415926, 3.14 will be the same after normalization if only two digits are kept after the decimal point.</li></ul><p>A dictionary is a program that accepts a token as input and returns:</p><ul><li>an array of lexemes if the input token is known to the dictionary (notice that one token can produce more than one lexeme)</li><li>a single lexeme with the <code>TSL_FILTER</code> flag set, to replace the original token with a new token to be passed to subsequent dictionaries (a dictionary that does this is called a <em>filtering dictionary</em>)</li><li>an empty array if the dictionary knows the token, but it is a stop word</li><li><code>NULL</code> if the dictionary does not recognize the input token</li></ul><p>WarehousePG provides predefined dictionaries for many languages. There are also several predefined templates that can be used to create new dictionaries with custom parameters. Each predefined dictionary template is described below. If no existing template is suitable, it is possible to create new ones; see the <code>contrib/</code> area of the WarehousePG distribution for examples.</p><p>A text search configuration binds a parser together with a set of dictionaries to process the parser&#39;s output tokens. For each token type that the parser can return, a separate list of dictionaries is specified by the configuration. When a token of that type is found by the parser, each dictionary in the list is consulted in turn, until some dictionary recognizes it as a known word. If it is identified as a stop word, or if no dictionary recognizes the token, it will be discarded and not indexed or searched for. Normally, the first dictionary that returns a <code>non-NULL</code> output determines the result, and any remaining dictionaries are not consulted; but a filtering dictionary can replace the given word with a modified word, which is then passed to subsequent dictionaries.</p><p>The general rule for configuring a list of dictionaries is to place first the most narrow, most specific dictionary, then the more general dictionaries, finishing with a very general dictionary, like a Snowball stemmer or <code>simple</code>, which recognizes everything. For example, for an astronomy-specific search (<code>astro_en</code> configuration) one could bind token type <code>asciiword</code> (ASCII word) to a synonym dictionary of astronomical terms, a general English dictionary and a Snowball English stemmer:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ALTER TEXT SEARCH CONFIGURATION astro_en</span></span>
<span class="line"><span>    ADD MAPPING FOR asciiword WITH astrosyn, english_ispell, english_stem;</span></span></code></pre></div><p>A filtering dictionary can be placed anywhere in the list, except at the end where it&#39;d be useless. Filtering dictionaries are useful to partially normalize words to simplify the task of later dictionaries. For example, a filtering dictionary could be used to remove accents from accented letters, as is done by the <a href="https://www.postgresql.org/docs/12/unaccent.html" target="_blank" rel="noreferrer">unaccent</a> module.</p><h2 id="stop-words" tabindex="-1"><a id="stop-words"></a>Stop Words <a class="header-anchor" href="#stop-words" aria-label="Permalink to &quot;&lt;a id=&quot;stop-words&quot;&gt;&lt;/a&gt;Stop Words&quot;">​</a></h2><p>Stop words are words that are very common, appear in almost every document, and have no discrimination value. Therefore, they can be ignored in the context of full text searching. For example, every English text contains words like <code>a</code> and <code>the</code>, so it is useless to store them in an index. However, stop words do affect the positions in <code>tsvector</code>, which in turn affect ranking:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT to_tsvector(&#39;english&#39;, &#39;in the list of stop words&#39;);</span></span>
<span class="line"><span>        to_tsvector</span></span>
<span class="line"><span>----------------------------</span></span>
<span class="line"><span> &#39;list&#39;:3 &#39;stop&#39;:5 &#39;word&#39;:6</span></span></code></pre></div><p>The missing positions 1,2,4 are because of stop words. Ranks calculated for documents with and without stop words are quite different:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT ts_rank_cd (to_tsvector(&#39;english&#39;, &#39;in the list of stop words&#39;), to_tsquery(&#39;list &amp; stop&#39;));</span></span>
<span class="line"><span> ts_rank_cd</span></span>
<span class="line"><span>------------</span></span>
<span class="line"><span>       0.05</span></span>
<span class="line"><span></span></span>
<span class="line"><span>SELECT ts_rank_cd (to_tsvector(&#39;english&#39;, &#39;list stop words&#39;), to_tsquery(&#39;list &amp; stop&#39;));</span></span>
<span class="line"><span> ts_rank_cd</span></span>
<span class="line"><span>------------</span></span>
<span class="line"><span>        0.1</span></span></code></pre></div><p>It is up to the specific dictionary how it treats stop words. For example, <code>ispell</code> dictionaries first normalize words and then look at the list of stop words, while <code>Snowball</code> stemmers first check the list of stop words. The reason for the different behavior is an attempt to decrease noise.</p><h2 id="simple-dictionary" tabindex="-1"><a id="simple"></a>Simple Dictionary <a class="header-anchor" href="#simple-dictionary" aria-label="Permalink to &quot;&lt;a id=&quot;simple&quot;&gt;&lt;/a&gt;Simple Dictionary&quot;">​</a></h2><p>The simple dictionary template operates by converting the input token to lower case and checking it against a file of stop words. If it is found in the file then an empty array is returned, causing the token to be discarded. If not, the lower-cased form of the word is returned as the normalized lexeme. Alternatively, the dictionary can be configured to report non-stop-words as unrecognized, allowing them to be passed on to the next dictionary in the list.</p><p>Here is an example of a dictionary definition using the simple template:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE TEXT SEARCH DICTIONARY public.simple_dict (</span></span>
<span class="line"><span>    TEMPLATE = pg_catalog.simple,</span></span>
<span class="line"><span>    STOPWORDS = english</span></span>
<span class="line"><span>);</span></span></code></pre></div><p>Here, <code>english</code> is the base name of a file of stop words. The file&#39;s full name will be <code>$SHAREDIR/tsearch_data/english.stop</code>, where <code>$SHAREDIR</code> means the WarehousePG installation&#39;s shared-data directory, often <code>/usr/local/greenplum-db-&lt;version&gt;/share/postgresql</code> (use <code>pg_config --sharedir</code> to determine it if you&#39;re not sure). The file format is simply a list of words, one per line. Blank lines and trailing spaces are ignored, and upper case is folded to lower case, but no other processing is done on the file contents.</p><p>Now we can test our dictionary:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT ts_lexize(&#39;public.simple_dict&#39;, &#39;YeS&#39;);</span></span>
<span class="line"><span> ts_lexize</span></span>
<span class="line"><span>-----------</span></span>
<span class="line"><span> {yes}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>SELECT ts_lexize(&#39;public.simple_dict&#39;, &#39;The&#39;);</span></span>
<span class="line"><span> ts_lexize</span></span>
<span class="line"><span>-----------</span></span>
<span class="line"><span> {}</span></span></code></pre></div><p>We can also choose to return <code>NULL</code>, instead of the lower-cased word, if it is not found in the stop words file. This behavior is selected by setting the dictionary&#39;s <code>Accept</code> parameter to false. Continuing the example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ALTER TEXT SEARCH DICTIONARY public.simple_dict ( Accept = false );</span></span>
<span class="line"><span></span></span>
<span class="line"><span>SELECT ts_lexize(&#39;public.simple_dict&#39;, &#39;YeS&#39;);</span></span>
<span class="line"><span> ts_lexize</span></span>
<span class="line"><span>-----------</span></span>
<span class="line"><span> {yes}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>SELECT ts_lexize(&#39;public.simple_dict&#39;, &#39;The&#39;);</span></span>
<span class="line"><span> ts_lexize</span></span>
<span class="line"><span>-----------</span></span>
<span class="line"><span> {}</span></span></code></pre></div><p>With the default setting of <code>Accept = true</code>, it is only useful to place a simple dictionary at the end of a list of dictionaries, since it will never pass on any token to a following dictionary. Conversely, <code>Accept = false</code> is only useful when there is at least one following dictionary.</p><p>CAUTION:</p><p>Most types of dictionaries rely on configuration files, such as files of stop words. These files <em>must</em> be stored in UTF-8 encoding. They will be translated to the actual database encoding, if that is different, when they are read into the server.</p><p>CAUTION:</p><p>Normally, a database session will read a dictionary configuration file only once, when it is first used within the session. If you modify a configuration file and want to force existing sessions to pick up the new contents, issue an <code>ALTER TEXT SEARCH DICTIONARY</code>command on the dictionary. This can be a &quot;dummy&quot; update that doesn&#39;t actually change any parameter values.</p><h2 id="synonym-dictionary" tabindex="-1"><a id="synonym"></a>Synonym Dictionary <a class="header-anchor" href="#synonym-dictionary" aria-label="Permalink to &quot;&lt;a id=&quot;synonym&quot;&gt;&lt;/a&gt;Synonym Dictionary&quot;">​</a></h2><p>This dictionary template is used to create dictionaries that replace a word with a synonym. Phrases are not supported—use the thesaurus template (<a href="#thesaurus-dictionary">Thesaurus Dictionary</a>) for that. A synonym dictionary can be used to overcome linguistic problems, for example, to prevent an English stemmer dictionary from reducing the word &quot;Paris&quot; to &quot;pari&quot;. It is enough to have a <code>Paris paris</code> line in the synonym dictionary and put it before the <code>english_stem</code> dictionary. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT * FROM ts_debug(&#39;english&#39;, &#39;Paris&#39;);</span></span>
<span class="line"><span>   alias   |   description   | token |  dictionaries  |  dictionary  | lexemes </span></span>
<span class="line"><span>-----------+-----------------+-------+----------------+--------------+---------</span></span>
<span class="line"><span> asciiword | Word, all ASCII | Paris | {english_stem} | english_stem | {pari}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>CREATE TEXT SEARCH DICTIONARY my_synonym (</span></span>
<span class="line"><span>    TEMPLATE = synonym,</span></span>
<span class="line"><span>    SYNONYMS = my_synonyms</span></span>
<span class="line"><span>);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>ALTER TEXT SEARCH CONFIGURATION english</span></span>
<span class="line"><span>    ALTER MAPPING FOR asciiword</span></span>
<span class="line"><span>    WITH my_synonym, english_stem;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>SELECT * FROM ts_debug(&#39;english&#39;, &#39;Paris&#39;);</span></span>
<span class="line"><span>   alias   |   description   | token |       dictionaries        | dictionary | lexemes </span></span>
<span class="line"><span>-----------+-----------------+-------+---------------------------+------------+---------</span></span>
<span class="line"><span> asciiword | Word, all ASCII | Paris | {my_synonym,english_stem} | my_synonym | {paris}</span></span></code></pre></div><p>The only parameter required by the synonym template is <code>SYNONYMS</code>, which is the base name of its configuration file — <code>my_synonyms</code> in the above example. The file&#39;s full name will be <code>$SHAREDIR/tsearch_data/my_synonyms.syn</code> (where <code>$SHAREDIR</code> means the WarehousePG installation&#39;s shared-data directory). The file format is just one line per word to be substituted, with the word followed by its synonym, separated by white space. Blank lines and trailing spaces are ignored.</p><p>The synonym template also has an optional parameter <code>CaseSensitive</code>, which defaults to <code>false</code>. When <code>CaseSensitive</code> is <code>false</code>, words in the synonym file are folded to lower case, as are input tokens. When it is <code>true</code>, words and tokens are not folded to lower case, but are compared as-is.</p><p>An asterisk (*) can be placed at the end of a synonym in the configuration file. This indicates that the synonym is a prefix. The asterisk is ignored when the entry is used in <code>to_tsvector()</code>, but when it is used in <code>to_tsquery()</code>, the result will be a query item with the prefix match marker (see <a href="./controlling.html#parsing-queries">Parsing Queries</a>). For example, suppose we have these entries in <code>$SHAREDIR/tsearch_data/synonym_sample.syn</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>postgres pgsql postgresql pgsql postgre pgsql </span></span>
<span class="line"><span>gogle googl </span></span>
<span class="line"><span>indices index*</span></span></code></pre></div><p>Then we will get these results:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>mydb=# CREATE TEXT SEARCH DICTIONARY syn (template=synonym, synonyms=&#39;synonym_sample&#39;);</span></span>
<span class="line"><span>mydb=# SELECT ts_lexize(&#39;syn&#39;, &#39;indices&#39;);</span></span>
<span class="line"><span> ts_lexize</span></span>
<span class="line"><span>-----------</span></span>
<span class="line"><span> {index}</span></span>
<span class="line"><span>(1 row)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>mydb=# CREATE TEXT SEARCH CONFIGURATION tst (copy=simple);</span></span>
<span class="line"><span>mydb=# ALTER TEXT SEARCH CONFIGURATION tst ALTER MAPPING FOR asciiword WITH syn;</span></span>
<span class="line"><span>mydb=# SELECT to_tsvector(&#39;tst&#39;, &#39;indices&#39;);</span></span>
<span class="line"><span> to_tsvector</span></span>
<span class="line"><span>-------------</span></span>
<span class="line"><span> &#39;index&#39;:1</span></span>
<span class="line"><span>(1 row)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>mydb=# SELECT to_tsquery(&#39;tst&#39;, &#39;indices&#39;);</span></span>
<span class="line"><span> to_tsquery</span></span>
<span class="line"><span>------------</span></span>
<span class="line"><span> &#39;index&#39;:*</span></span>
<span class="line"><span>(1 row)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>mydb=# SELECT &#39;indexes are very useful&#39;::tsvector;</span></span>
<span class="line"><span>            tsvector             </span></span>
<span class="line"><span>---------------------------------</span></span>
<span class="line"><span> &#39;are&#39; &#39;indexes&#39; &#39;useful&#39; &#39;very&#39;</span></span>
<span class="line"><span>(1 row)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>mydb=# SELECT &#39;indexes are very useful&#39;::tsvector @@ to_tsquery(&#39;tst&#39;, &#39;indices&#39;);</span></span>
<span class="line"><span> ?column?</span></span>
<span class="line"><span>----------</span></span>
<span class="line"><span> t</span></span>
<span class="line"><span>(1 row)</span></span></code></pre></div><h2 id="thesaurus-dictionary" tabindex="-1"><a id="thesaurus-dictionary"></a>Thesaurus Dictionary <a class="header-anchor" href="#thesaurus-dictionary" aria-label="Permalink to &quot;&lt;a id=&quot;thesaurus-dictionary&quot;&gt;&lt;/a&gt;Thesaurus Dictionary&quot;">​</a></h2><p>A thesaurus dictionary (sometimes abbreviated as TZ) is a collection of words that includes information about the relationships of words and phrases, i.e., broader terms (BT), narrower terms (NT), preferred terms, non-preferred terms, related terms, etc.</p><p>Basically a thesaurus dictionary replaces all non-preferred terms by one preferred term and, optionally, preserves the original terms for indexing as well. WarehousePG&#39;s current implementation of the thesaurus dictionary is an extension of the synonym dictionary with added <em>phrase</em> support. A thesaurus dictionary requires a configuration file of the following format:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># this is a comment</span></span>
<span class="line"><span>sample word(s) : indexed word(s)</span></span>
<span class="line"><span>more sample word(s) : more indexed word(s)</span></span>
<span class="line"><span>...</span></span></code></pre></div><p>where the colon (<code>:</code>) symbol acts as a delimiter between a phrase and its replacement.</p><p>A thesaurus dictionary uses a <em>subdictionary</em> (which is specified in the dictionary&#39;s configuration) to normalize the input text before checking for phrase matches. It is only possible to select one subdictionary. An error is reported if the subdictionary fails to recognize a word. In that case, you should remove the use of the word or teach the subdictionary about it. You can place an asterisk (<code>*</code>) at the beginning of an indexed word to skip applying the subdictionary to it, but all sample words <strong>must</strong> be known to the subdictionary.</p><p>The thesaurus dictionary chooses the longest match if there are multiple phrases matching the input, and ties are broken by using the last definition.</p><p>Specific stop words recognized by the subdictionary cannot be specified; instead use <code>?</code> to mark the location where any stop word can appear. For example, assuming that <code>a</code> and <code>the</code> are stop words according to the subdictionary:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>? one ? two : swsw</span></span></code></pre></div><p>matches <code>a one the two</code> and <code>the one a two</code>; both would be replaced by <code>swsw</code>.</p><p>Since a thesaurus dictionary has the capability to recognize phrases it must remember its state and interact with the parser. A thesaurus dictionary uses these assignments to check if it should handle the next word or stop accumulation. The thesaurus dictionary must be configured carefully. For example, if the thesaurus dictionary is assigned to handle only the <code>asciiword</code> token, then a thesaurus dictionary definition like <code>one 7</code> will not work since token type <code>uint</code> is not assigned to the thesaurus dictionary.</p><p>CAUTION:</p><p>Thesauruses are used during indexing so any change in the thesaurus dictionary&#39;s parameters requires reindexing. For most other dictionary types, small changes such as adding or removing stopwords does not force reindexing.</p><p><strong>Thesaurus Configuration</strong></p><p>To define a new thesaurus dictionary, use the <code>thesaurus</code> template. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE TEXT SEARCH DICTIONARY thesaurus_simple (</span></span>
<span class="line"><span>    TEMPLATE = thesaurus,</span></span>
<span class="line"><span>    DictFile = mythesaurus,</span></span>
<span class="line"><span>    Dictionary = pg_catalog.english_stem</span></span>
<span class="line"><span>);</span></span></code></pre></div><p>Here:</p><ul><li><code>thesaurus_simple</code> is the new dictionary&#39;s name</li><li><code>mythesaurus</code> is the base name of the thesaurus configuration file. (Its full name will be <code>$SHAREDIR/tsearch_data/mythesaurus.ths</code>, where <code>$SHAREDIR</code> means the installation shared-data directory.)</li><li><code>pg_catalog.english_stem</code> is the subdictionary (here, a Snowball English stemmer) to use for thesaurus normalization. Notice that the subdictionary will have its own configuration (for example, stop words), which is not shown here.</li></ul><p>Now it is possible to bind the thesaurus dictionary <code>thesaurus_simple</code> to the desired token types in a configuration, for example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ALTER TEXT SEARCH CONFIGURATION russian</span></span>
<span class="line"><span>    ALTER MAPPING FOR asciiword, asciihword, hword_asciipart</span></span>
<span class="line"><span>    WITH thesaurus_simple;</span></span></code></pre></div><p><strong>Thesaurus Example</strong></p><p>Consider a simple astronomical thesaurus <code>thesaurus_astro</code>, which contains some astronomical word combinations:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>supernovae stars : sn</span></span>
<span class="line"><span>crab nebulae : crab</span></span></code></pre></div><p>Below we create a dictionary and bind some token types to an astronomical thesaurus and English stemmer:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE TEXT SEARCH DICTIONARY thesaurus_astro (</span></span>
<span class="line"><span>    TEMPLATE = thesaurus,</span></span>
<span class="line"><span>    DictFile = thesaurus_astro,</span></span>
<span class="line"><span>    Dictionary = english_stem</span></span>
<span class="line"><span>);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>ALTER TEXT SEARCH CONFIGURATION russian</span></span>
<span class="line"><span>    ALTER MAPPING FOR asciiword, asciihword, hword_asciipart</span></span>
<span class="line"><span>    WITH thesaurus_astro, english_stem;</span></span></code></pre></div><p>Now we can see how it works. <code>ts_lexize</code> is not very useful for testing a thesaurus, because it treats its input as a single token. Instead we can use <code>plainto_tsquery</code> and <code>to_tsvector</code>, which will break their input strings into multiple tokens:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT plainto_tsquery(&#39;supernova star&#39;);</span></span>
<span class="line"><span> plainto_tsquery</span></span>
<span class="line"><span>-----------------</span></span>
<span class="line"><span> &#39;supernova&#39; &amp; &#39;star&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>SELECT to_tsvector(&#39;supernova star&#39;);</span></span>
<span class="line"><span> to_tsvector</span></span>
<span class="line"><span>-------------</span></span>
<span class="line"><span> &#39;star&#39;:2 &#39;supernova&#39;:1</span></span></code></pre></div><p>In principle, one can use <code>to_tsquery</code> if you quote the argument:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT to_tsquery(&#39;&#39;&#39;supernova star&#39;&#39;&#39;);</span></span>
<span class="line"><span> to_tsquery</span></span>
<span class="line"><span>------------</span></span>
<span class="line"><span> &#39;supernova&#39; &amp; &#39;star&#39;</span></span></code></pre></div><p>Notice that <code>supernova star</code> matches <code>supernovae stars</code> in <code>thesaurus_astro</code> because we specified the <code>english_stem</code> stemmer in the <code>thesaurus</code> definition. The stemmer removed the <code>e</code> and <code>s</code>.</p><p>To index the original phrase as well as the substitute, just include it in the right-hand part of the definition:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>supernovae stars : sn supernovae stars</span></span>
<span class="line"><span></span></span>
<span class="line"><span>SELECT plainto_tsquery(&#39;supernova star&#39;);</span></span>
<span class="line"><span>       plainto_tsquery</span></span>
<span class="line"><span>-----------------------------</span></span>
<span class="line"><span> &#39;supernova&#39; &amp; &#39;star&#39;</span></span></code></pre></div><h2 id="ispell-dictionary" tabindex="-1"><a id="ispell"></a>Ispell Dictionary <a class="header-anchor" href="#ispell-dictionary" aria-label="Permalink to &quot;&lt;a id=&quot;ispell&quot;&gt;&lt;/a&gt;Ispell Dictionary&quot;">​</a></h2><p>The Ispell dictionary template supports <em>morphological dictionaries</em>, which can normalize many different linguistic forms of a word into the same lexeme. For example, an English Ispell dictionary can match all declensions and conjugations of the search term <code>bank</code>, e.g., <code>banking</code>, <code>banked</code>, <code>banks</code>, <code>banks</code>&#39;, and <code>bank&#39;s</code>.</p><p>The standard WarehousePG distribution does not include any Ispell configuration files. Dictionaries for a large number of languages are available from <a href="https://www.cs.hmc.edu/~geoff/ispell.html" target="_blank" rel="noreferrer">Ispell</a>. Also, some more modern dictionary file formats are supported — <a href="http://en.wikipedia.org/wiki/MySpell" target="_blank" rel="noreferrer">MySpell</a> (OO &lt; 2.0.1) and <a href="http://sourceforge.net/projects/hunspell/" target="_blank" rel="noreferrer">Hunspell</a> (OO &gt;= 2.0.2). A large list of dictionaries is available on the <a href="http://wiki.services.openoffice.org/wiki/Dictionaries" target="_blank" rel="noreferrer">OpenOffice Wiki</a>.</p><p>To create an Ispell dictionary perform these steps:</p><ol><li><p>Download dictionary configuration files. OpenOffice extension files have the <code>.oxt</code> extension. It is necessary to extract <code>.aff</code> and <code>.dic</code> files, change extensions to <code>.affix</code> and <code>.dict</code>. For some dictionary files it is also needed to convert characters to the UTF-8 encoding with commands (for example, for a Norwegian language dictionary):</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>iconv -f ISO_8859-1 -t UTF-8 -o nn_no.affix nn_NO.aff</span></span>
<span class="line"><span>iconv -f ISO_8859-1 -t UTF-8 -o nn_no.dict nn_NO.dic</span></span></code></pre></div></li><li><p>Copy files to the <code>$SHAREDIR/tsearch_data</code> directory.</p></li><li><p>Load files into PostgreSQL with the following command:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE TEXT SEARCH DICTIONARY english_hunspell (</span></span>
<span class="line"><span>TEMPLATE = ispell,</span></span>
<span class="line"><span>DictFile = en_us,</span></span>
<span class="line"><span>AffFile = en_us,</span></span>
<span class="line"><span>Stopwords = english);</span></span></code></pre></div></li></ol><p>Here, <code>DictFile</code>, <code>AffFile</code>, and <code>StopWords</code> specify the base names of the dictionary, affixes, and stop-words files. The stop-words file has the same format explained above for the <code>simple</code> dictionary type. The format of the other files is not specified here but is available from the above-mentioned web sites.</p><p>Ispell dictionaries usually recognize a limited set of words, so they should be followed by another broader dictionary; for example, a Snowball dictionary, which recognizes everything.</p><p>The <code>.affix</code> file of Ispell has the following structure:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>prefixes</span></span>
<span class="line"><span>flag *A:</span></span>
<span class="line"><span>    .           &gt;   RE      # As in enter &gt; reenter</span></span>
<span class="line"><span>suffixes</span></span>
<span class="line"><span>flag T:</span></span>
<span class="line"><span>    E           &gt;   ST      # As in late &gt; latest</span></span>
<span class="line"><span>    [^AEIOU]Y   &gt;   -Y,IEST # As in dirty &gt; dirtiest</span></span>
<span class="line"><span>    [AEIOU]Y    &gt;   EST     # As in gray &gt; grayest</span></span>
<span class="line"><span>    [^EY]       &gt;   EST     # As in small &gt; smallest</span></span></code></pre></div><p>And the <code>.dict</code> file has the following structure:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>lapse/ADGRS</span></span>
<span class="line"><span>lard/DGRS</span></span>
<span class="line"><span>large/PRTY</span></span>
<span class="line"><span>lark/MRS</span></span></code></pre></div><p>Format of the <code>.dict</code> file is:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>basic_form/affix_class_name</span></span></code></pre></div><p>In the <code>.affix</code> file every affix flag is described in the following format:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>condition &gt; [-stripping_letters,] adding_affix</span></span></code></pre></div><p>Here, condition has a format similar to the format of regular expressions. It can use groupings <code>[...]</code> and <code>[^...]</code>. For example, <code>[AEIOU]Y</code> means that the last letter of the word is &quot;y&quot; and the penultimate letter is &quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot; or &quot;u&quot;. <code>[^EY]</code> means that the last letter is neither &quot;e&quot; nor &quot;y&quot;.</p><p>Ispell dictionaries support splitting compound words; a useful feature. Notice that the affix file should specify a special flag using the <code>compoundwords controlled</code> statement that marks dictionary words that can participate in compound formation:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>compoundwords  controlled z</span></span></code></pre></div><p>Here are some examples for the Norwegian language:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT ts_lexize(&#39;norwegian_ispell&#39;, &#39;overbuljongterningpakkmesterassistent&#39;);</span></span>
<span class="line"><span>   {over,buljong,terning,pakk,mester,assistent}</span></span>
<span class="line"><span>SELECT ts_lexize(&#39;norwegian_ispell&#39;, &#39;sjokoladefabrikk&#39;);</span></span>
<span class="line"><span>   {sjokoladefabrikk,sjokolade,fabrikk}</span></span></code></pre></div><p>MySpell format is a subset of Hunspell. The <code>.affix</code> file of Hunspell has the following structure:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>PFX A Y 1</span></span>
<span class="line"><span>PFX A   0     re         .</span></span>
<span class="line"><span>SFX T N 4</span></span>
<span class="line"><span>SFX T   0     st         e</span></span>
<span class="line"><span>SFX T   y     iest       [^aeiou]y</span></span>
<span class="line"><span>SFX T   0     est        [aeiou]y</span></span>
<span class="line"><span>SFX T   0     est        [^ey]</span></span></code></pre></div><p>The first line of an affix class is the header. Fields of an affix rules are listed after the header:</p><ul><li><p>parameter name (PFX or SFX)</p></li><li><p>flag (name of the affix class)</p></li><li><p>stripping characters from beginning (at prefix) or end (at suffix) of the word</p></li><li><p>adding affix</p></li><li><p>condition that has a format similar to the format of regular expressions.</p></li></ul><p>The <code>.dict</code> file looks like the <code>.dict</code> file of Ispell:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>larder/M</span></span>
<span class="line"><span>lardy/RT</span></span>
<span class="line"><span>large/RSPMYT</span></span>
<span class="line"><span>largehearted</span></span></code></pre></div><blockquote><p><strong>Note</strong> MySpell does not support compound words. Hunspell has sophisticated support for compound words. At present, WarehousePG implements only the basic compound word operations of Hunspell.</p></blockquote><h2 id="snowball-dictionary" tabindex="-1"><a id="section_xgc_2zw_4fb"></a>SnowBall Dictionary <a class="header-anchor" href="#snowball-dictionary" aria-label="Permalink to &quot;&lt;a id=&quot;section_xgc_2zw_4fb&quot;&gt;&lt;/a&gt;SnowBall Dictionary&quot;">​</a></h2><p>The Snowball dictionary template is based on a project by Martin Porter, inventor of the popular Porter&#39;s stemming algorithm for the English language. Snowball now provides stemming algorithms for many languages (see the <a href="http://snowballstem.org/" target="_blank" rel="noreferrer">Snowball site</a> for more information). Each algorithm understands how to reduce common variant forms of words to a base, or stem, spelling within its language. A Snowball dictionary requires a language parameter to identify which stemmer to use, and optionally can specify a stopword file name that gives a list of words to eliminate. (WarehousePG&#39;s standard stopword lists are also provided by the Snowball project.) For example, there is a built-in definition equivalent to</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE TEXT SEARCH DICTIONARY english_stem (</span></span>
<span class="line"><span>    TEMPLATE = snowball,</span></span>
<span class="line"><span>    Language = english,</span></span>
<span class="line"><span>    StopWords = english</span></span>
<span class="line"><span>);</span></span></code></pre></div><p>The stopword file format is the same as already explained.</p><p>A Snowball dictionary recognizes everything, whether or not it is able to simplify the word, so it should be placed at the end of the dictionary list. It is useless to have it before any other dictionary because a token will never pass through it to the next dictionary.</p><p><strong>Parent topic:</strong> <a href="./../textsearch/full-text-search.html">Using Full Text Search</a></p>`,110)]))}const m=s(t,[["render",o]]);export{u as __pageData,m as default};
