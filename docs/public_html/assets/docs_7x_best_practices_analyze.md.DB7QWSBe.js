import{_ as e,c as a,o,ag as i}from"./chunks/framework.Ds6Eueu6.js";const p=JSON.parse('{"title":"Updating Statistics with ANALYZE","description":"","frontmatter":{},"headers":[],"relativePath":"docs/7x/best_practices/analyze.md","filePath":"docs/7x/best_practices/analyze.md"}'),n={name:"docs/7x/best_practices/analyze.md"};function s(c,t,d,r,l,u){return o(),a("div",null,t[0]||(t[0]=[i('<h1 id="updating-statistics-with-analyze" tabindex="-1">Updating Statistics with ANALYZE <a class="header-anchor" href="#updating-statistics-with-analyze" aria-label="Permalink to &quot;Updating Statistics with ANALYZE&quot;">​</a></h1><hr><p>The most important prerequisite for good query performance is to begin with accurate statistics for the tables. Updating statistics with the <code>ANALYZE</code> statement enables the query planner to generate optimal query plans. When a table is analyzed, information about the data is stored in the system catalog tables. If the stored information is out of date, the planner can generate inefficient plans.</p><h2 id="generating-statistics-selectively" tabindex="-1"><a id="genstat"></a>Generating Statistics Selectively <a class="header-anchor" href="#generating-statistics-selectively" aria-label="Permalink to &quot;&lt;a id=&quot;genstat&quot;&gt;&lt;/a&gt;Generating Statistics Selectively&quot;">​</a></h2><p>Running <a href="./../ref_guide/sql_commands/ANALYZE.html">ANALYZE</a> with no arguments updates statistics for all tables in the database. This can be a very long-running process and it is not recommended. You should <code>ANALYZE</code> tables selectively when data has changed or use the <a href="./../utility_guide/ref/analyzedb.html">analyzedb</a> utility.</p><p>Running <code>ANALYZE</code> on a large table can take a long time. If it is not feasible to run <code>ANALYZE</code> on all columns of a very large table, you can generate statistics for selected columns only using <code>ANALYZE table(column, ...)</code>. Be sure to include columns used in joins, <code>WHERE</code> clauses, <code>SORT</code> clauses, <code>GROUP BY</code> clauses, or <code>HAVING</code> clauses.</p><p>For a partitioned table, you can run <code>ANALYZE</code> just on partitions that have changed, for example, if you add a new partition. Note that for partitioned tables, you can run <code>ANALYZE</code> on the root partitioned table, or on the leaf partitions (files where data and statistics are actually stored). The intermediate files for sub-partitioned tables store no data or statistics, so running <code>ANALYZE</code> on them does not work. You can find the names of the leaf partitions using the <code>pg_partition_tree()</code> function:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT * FROM pg_partition_tree( &#39;parent_table&#39; );</span></span></code></pre></div><h2 id="improving-statistics-quality" tabindex="-1"><a id="impstat"></a>Improving Statistics Quality <a class="header-anchor" href="#improving-statistics-quality" aria-label="Permalink to &quot;&lt;a id=&quot;impstat&quot;&gt;&lt;/a&gt;Improving Statistics Quality&quot;">​</a></h2><p>There is a trade-off between the amount of time it takes to generate statistics and the quality, or accuracy, of the statistics.</p><p>To allow large tables to be analyzed in a reasonable amount of time, <code>ANALYZE</code> takes a random sample of the table contents, rather than examining every row. To increase the number of sample values for all table columns adjust the <code>default_statistics_target</code> configuration parameter. The target value ranges from 1 to 1000; the default target value is 100. The <code>default_statistics_target</code> variable applies to all columns by default, and specifies the number of values that are stored in the list of common values. A larger target may improve the quality of the query planner’s estimates, especially for columns with irregular data patterns. <code>default_statistics_target</code> can be set at the coordinator/session level and requires a reload.</p><h2 id="when-to-run-analyze" tabindex="-1"><a id="whenrun"></a>When to Run ANALYZE <a class="header-anchor" href="#when-to-run-analyze" aria-label="Permalink to &quot;&lt;a id=&quot;whenrun&quot;&gt;&lt;/a&gt;When to Run ANALYZE&quot;">​</a></h2><p>Run <code>ANALYZE</code>:</p><ul><li>after loading data,</li><li>after <code>CREATE INDEX</code> operations,</li><li>and after <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> operations that significantly change the underlying data.</li></ul><p><code>ANALYZE</code> requires only a read lock on the table, so it may be run in parallel with other database activity, but do not run <code>ANALYZE</code> while performing loads, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, and <code>CREATE INDEX</code> operations.</p><h2 id="configuring-automatic-statistics-collection" tabindex="-1"><a id="conauto"></a>Configuring Automatic Statistics Collection <a class="header-anchor" href="#configuring-automatic-statistics-collection" aria-label="Permalink to &quot;&lt;a id=&quot;conauto&quot;&gt;&lt;/a&gt;Configuring Automatic Statistics Collection&quot;">​</a></h2><p>The <code>gp_autostats_mode</code> configuration parameter, together with the <code>gp_autostats_on_change_threshold</code> parameter, determines when an automatic analyze operation is triggered. When automatic statistics collection is triggered, the planner adds an <code>ANALYZE</code> step to the query.</p><p>By default, <code>gp_autostats_mode</code> is <code>on_no_stats</code>, which triggers statistics collection for <code>CREATE TABLE AS SELECT</code>, <code>INSERT</code>, or <code>COPY</code> operations invoked by the table owner on any table that has no existing statistics.</p><p>Setting <code>gp_autostats_mode</code> to <code>on_change</code> triggers statistics collection only when the number of rows affected exceeds the threshold defined by <code>gp_autostats_on_change_threshold</code>, which has a default value of 2147483647. The following operations invoked on a table by its owner can trigger automatic statistics collection with <code>on_change</code>: <code>CREATE TABLE AS SELECT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>INSERT</code>, and <code>COPY</code>.</p><p>Setting the <code>gp_autostats_allow_nonowner</code> server configuration parameter to <code>true</code> also instructs WarehousePG to trigger automatic statistics collection on a table when:</p><ul><li><code>gp_autostats_mode=on_change</code> and the table is modified by a non-owner.</li><li><code>gp_autostats_mode=on_no_stats</code> and the first user to <code>INSERT</code> or <code>COPY</code> into the table is a non-owner.</li></ul><p>Setting <code>gp_autostats_mode</code> to <code>none</code> deactivates automatics statistics collection.</p><p>For partitioned tables, automatic statistics collection is not triggered if data is inserted from the top-level parent table of a partitioned table. But automatic statistics collection <em>is</em> triggered if data is inserted directly in a leaf table (where the data is stored) of the partitioned table.</p><p><strong>Parent topic:</strong> <a href="./maintenance.html">System Monitoring and Maintenance</a></p>',24)]))}const g=e(n,[["render",s]]);export{p as __pageData,g as default};
