import{_ as a,c as e,o as n,ag as i}from"./chunks/framework.Ds6Eueu6.js";const g=JSON.parse('{"title":"Migrating Partition Maintenance Scripts to the New WarehousePG 7 Partitioning Catalogs","description":"","frontmatter":{},"headers":[],"relativePath":"docs/7x/install_guide/migrate-classic-partitioning.md","filePath":"docs/7x/install_guide/migrate-classic-partitioning.md"}'),s={name:"docs/7x/install_guide/migrate-classic-partitioning.md"};function p(o,t,r,l,d,c){return n(),e("div",null,t[0]||(t[0]=[i(`<h1 id="migrating-partition-maintenance-scripts-to-the-new-warehousepg-7-partitioning-catalogs" tabindex="-1">Migrating Partition Maintenance Scripts to the New WarehousePG 7 Partitioning Catalogs <a class="header-anchor" href="#migrating-partition-maintenance-scripts-to-the-new-warehousepg-7-partitioning-catalogs" aria-label="Permalink to &quot;Migrating Partition Maintenance Scripts to the New WarehousePG 7 Partitioning Catalogs&quot;">​</a></h1><hr><p>This topic provides guidance on migrating partition maintenance scripts that you may have written for WarehousePG 6 to use the new partitioning system catalogs in WarehousePG 7.</p><h2 id="about-the-warehousepg-6-and-7-partitioning-catalogs" tabindex="-1"><a id="about_removed"></a> About the WarehousePG 6 and 7 Partitioning Catalogs <a class="header-anchor" href="#about-the-warehousepg-6-and-7-partitioning-catalogs" aria-label="Permalink to &quot;&lt;a id=&quot;about_removed&quot;&gt;&lt;/a&gt; About the WarehousePG 6 and 7 Partitioning Catalogs&quot;">​</a></h2><p>The following partitioning-related catalog tables, views, and functions available in WarehousePG 6 are removed in WarehousePG 7:</p><ul><li><code>pg_partition</code></li><li><code>pg_partition_columns</code></li><li><code>pg_partition_encoding</code></li><li><code>pg_partition_rule</code></li><li><code>pg_partition_templates</code></li><li><code>pg_partitions</code></li><li><code>pg_stat_partition_operations</code></li><li><code>pg_partition_def()</code></li></ul><p>WarehousePG 7 adds the following new catalog table and functions:</p><ul><li><a href="./../ref_guide/system_catalogs/gp_partition_template.html">gp_partition_template</a></li><li><a href="./../ref_guide/system_catalogs/pg_partitioned_table.html">pg_partitioned_table</a></li><li><a href="./../admin_guide/ddl/ddl-partition.html#topic76">pg_partition_tree()</a></li><li><a href="./../admin_guide/ddl/ddl-partition.html#topic76">pg_partition_ancestors()</a></li><li><a href="./../admin_guide/ddl/ddl-partition.html#topic76">pg_partition_root()</a></li></ul><h2 id="why-are-migration-tasks-required" tabindex="-1"><a id="why"></a> Why are Migration Tasks Required? <a class="header-anchor" href="#why-are-migration-tasks-required" aria-label="Permalink to &quot;&lt;a id=&quot;why&quot;&gt;&lt;/a&gt; Why are Migration Tasks Required?&quot;">​</a></h2><p>Because partitioning-related system catalog, view, and function definitions have changed in WarehousePG 7, you must update any partition maintenance scripts that you have been using in WarehousePG 6.</p><p>The following sections identify, for each WarehousePG 6 partitioning catalog column, how to obtain similar information in WarehousePG 7. These mappings should help ease your partition maintenance migration effort.</p><p>In some cases, there is an equivalent field in, or query of, a WarehousePG 7 system catalog or view. In other cases, there may be no direct mapping because WarehousePG 7 no longer stores the information in the catalog.</p><h2 id="pg-partitions" tabindex="-1"><a id="pg_partitions"></a> pg_partitions <a class="header-anchor" href="#pg-partitions" aria-label="Permalink to &quot;&lt;a id=&quot;pg_partitions&quot;&gt;&lt;/a&gt; pg_partitions&quot;">​</a></h2><p>The WarehousePG 6 <code>pg_partitions</code> view displays all leaf partitions in the current database.</p><table tabindex="0"><thead><tr><th>Column Name</th><th>WarehousePG 6 Description</th><th>WarehousePG 7 Equivalent</th></tr></thead><tbody><tr><td>schemaname</td><td>The name of the schema in which the root partitioned table resides.</td><td>Use <code>pg_partition_root()</code> to obtain the root object identifier, and then query <a href="./../ref_guide/system_catalogs/pg_namespace.html">pg_namespace</a>.</td></tr><tr><td>tablename</td><td>The name of the root partitioned table.</td><td>Use <code>pg_partition_root()</code> to obtain the root object identifier, and then query <a href="./../ref_guide/system_catalogs/pg_class.html">pg_class</a>.</td></tr><tr><td>partitionschemaname</td><td>The namespace of the leaf partition.</td><td><a href="./../ref_guide/system_catalogs/pg_namespace.html">pg_namespace</a></td></tr><tr><td>partitiontablename</td><td>The table name of the leaf partition (the table name you use to access the partition directly).</td><td><a href="./../ref_guide/system_catalogs/pg_class.html">pg_class</a></td></tr><tr><td>partitionname</td><td>The partition name of the leaf partition (the name you use to refer to the partition in an <code>ALTER TABLE</code> command).</td><td>N/A</td></tr><tr><td>parentpartitiontablename</td><td>The table name of the parent table of this partition.</td><td>Get the parent object identifier via <a href="./../ref_guide/system_catalogs/pg_inherits.html">pg_inherits</a> and then query <a href="./../ref_guide/system_catalogs/pg_class.html">pg_class</a>.</td></tr><tr><td>parentpartitionname</td><td>The partition name of the parent table of this partition.</td><td>N/A</td></tr><tr><td>partitiontype</td><td>The type of partition (range or list).</td><td>Get the parent object identifier via <a href="./../ref_guide/system_catalogs/pg_inherits.html">pg_inherits</a> and then query <a href="./../ref_guide/system_catalogs/pg_partitioned_table.html">pg_partitioned_table</a>.</td></tr><tr><td>partitionlevel</td><td>The level of this partition in the partition hierarchy.</td><td>Get the level from <code>pg_partition_tree()</code> using the root object identifier.Note that the level differs in WarehousePG 6 and 7. In WarehousePG 6, the level of the immediate child of a partitioned table is 0. In WarehousePG 7, the level of the partitioned table itself is 0, and the level of its immediate child is 1.</td></tr><tr><td>partitionrank</td><td>For range partitions, the rank of the partition compared to other partitions at the same level.</td><td>N/A</td></tr><tr><td>partitionposition</td><td>The rule order position of this partition.</td><td>N/A</td></tr><tr><td>partitionlistvalues</td><td>For list partitions, the list value(s) associated with this partition.</td><td>Get the partition boundary via <code>pg_get_expr()</code> and then filter the text.</td></tr><tr><td>partitionrangestart</td><td>For range partitions, the start value of this partition.</td><td>Get the partition boundary via <code>pg_get_expr()</code> and then filter the text.</td></tr><tr><td>partitionstartinclusive</td><td>Whether or not the start value is included in this partition. <code>true</code> if the start value is included.</td><td>always inclusive</td></tr><tr><td>partitionrangeend</td><td>For range partitions, the end value of this partition.</td><td>Get the partition boundary via <code>pg_get_expr()</code> and then filter the text.</td></tr><tr><td>partitionendinclusive</td><td>Whether or not the end value is included in this partition. <code>true</code> if the end value is included.</td><td>always exclusive</td></tr><tr><td>partitioneveryclause</td><td>The <code>EVERY</code> clause (interval) of this partition.</td><td>N/A</td></tr><tr><td>partitionisdefault</td><td>Whether or not this is a default partition. <code>true</code> if this is the default, otherwise <code>false</code>.</td><td>Get the partition boundary via <code>pg_get_expr()</code> and check if it is <code>DEFAULT</code>. Alternatively, use <code>pg_partitioned_table.partdefid</code>.</td></tr><tr><td>partitionboundary</td><td>The entire partition specification for this partition.</td><td><code>pg_get_expr()</code>, but note that it is returned in modern syntax.</td></tr><tr><td>parenttablespace</td><td>The tablespace of the parent table of this partition.</td><td>Get the parent object identifier via <a href="./../ref_guide/system_catalogs/pg_inherits.html">pg_inherits</a> and then query <a href="./../ref_guide/system_catalogs/pg_tablespace.html">pg_tablespace</a>.</td></tr><tr><td>partitiontablespace</td><td>The tablespace of this partition.</td><td><a href="./../ref_guide/system_catalogs/pg_tablespace.html">pg_tablespace</a></td></tr></tbody></table><h3 id="examples-retrieving-similar-information-in-warehousepg-7" tabindex="-1"><a id="pgparts_retrieve"></a> Examples Retrieving Similar Information in WarehousePG 7 <a class="header-anchor" href="#examples-retrieving-similar-information-in-warehousepg-7" aria-label="Permalink to &quot;&lt;a id=&quot;pgparts_retrieve&quot;&gt;&lt;/a&gt; Examples Retrieving Similar Information in WarehousePG 7&quot;">​</a></h3><p>Some of the information is quite trivial to retrieve in WarehousePG 7, while other information is not. The following sections provide examples for specific WarehousePG 6 system catalog columns.</p><h4 id="partitionname-parentpartitionname" tabindex="-1"><a id="pnppn"></a> partitionname / parentpartitionname <a class="header-anchor" href="#partitionname-parentpartitionname" aria-label="Permalink to &quot;&lt;a id=&quot;pnppn&quot;&gt;&lt;/a&gt; partitionname / parentpartitionname&quot;">​</a></h4><p>The <code>partitionname</code> and <code>parentpartitionname</code> columns provide the WarehousePG 6 &quot;partition name&quot; in constrast to the actual table name. Because WarehousePG 7 no longer stores the partition name in the catalog (previously in <code>pg_partition_rule</code>), it cannot retrieve that information now. Use the table names directly to refer to the partitions. However, if you really need the partition name, you can achieve that via some text massaging:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT</span></span>
<span class="line"><span>    c.relname AS table_name,</span></span>
<span class="line"><span>    split_part(substr(c.relname, position(inh.inhparent::regclass::text in c.relname) + length(inh.inhparent::regclass::text)), &#39;_&#39;, 4) AS partition_name</span></span>
<span class="line"><span>FROM</span></span>
<span class="line"><span>    pg_class c</span></span>
<span class="line"><span>LEFT JOIN</span></span>
<span class="line"><span>    pg_inherits inh ON inh.inhrelid = c.oid</span></span>
<span class="line"><span>WHERE</span></span>
<span class="line"><span>    c.relname LIKE concat(inh.inhparent::regclass::text, &#39;%&#39;)</span></span>
<span class="line"><span>    AND c.relname LIKE &#39;&lt;your_partition_name&gt;&#39;;</span></span></code></pre></div><p>This query is valid only if the table name is implicitly generated by WarehousePG from the partition name and is in the form of <code>&lt;parent_tablename&gt;_prt_&lt;level&gt;_&lt;partition_name&gt;</code>. This query will not work for a partitioned table created with modern syntax (where you always specify the table name when adding a partition) or for a partitioned table created with classic syntax where you explicitly specify the table name in a <code>WITH</code> clause for the partition.</p><h4 id="partitionposition-partitionrank" tabindex="-1"><a id="pppr"></a> partitionposition / partitionrank <a class="header-anchor" href="#partitionposition-partitionrank" aria-label="Permalink to &quot;&lt;a id=&quot;pppr&quot;&gt;&lt;/a&gt; partitionposition / partitionrank&quot;">​</a></h4><p>The <code>partitionposition</code> and <code>partitionrank</code> columns in the WarehousePG 6 <code>pg_partitions</code> view are based on the &quot;order&quot; number for each partition in the <code>pg_partition_rule</code> catalog, but that catalog is removed in WarehousePG 7. However, if you are simply interested in retrieving the sorted order for range partitions, you can order the range value. For example, if the WarehousePG 6 query below provides the highest rank partition:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT </span></span>
<span class="line"><span>    CASE </span></span>
<span class="line"><span>        WHEN partitionstartinclusive THEN partitionrangestart</span></span>
<span class="line"><span>        ELSE partitionrangeend</span></span>
<span class="line"><span>    END AS old_part_value</span></span>
<span class="line"><span>FROM </span></span>
<span class="line"><span>    pg_catalog.pg_partitions p</span></span>
<span class="line"><span>WHERE </span></span>
<span class="line"><span>    p.schemaname = &#39;&quot; + cfg.schema + &quot;&#39;</span></span>
<span class="line"><span>    AND p.tablename = &#39;&quot; + cfg.table + &quot;&#39;</span></span>
<span class="line"><span>    AND p.partitiontype = &#39;range&#39;</span></span>
<span class="line"><span>    AND p.partitionlevel = &quot; + str(cfg.partition_level) + &quot;</span></span>
<span class="line"><span>    AND &quot; + chk + &quot;</span></span>
<span class="line"><span>ORDER BY </span></span>
<span class="line"><span>    partitionrank</span></span>
<span class="line"><span>LIMIT 1;</span></span></code></pre></div><p>A similar query in WarehousePG 7 follows:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT</span></span>
<span class="line"><span>   rank() OVER (</span></span>
<span class="line"><span>       PARTITION BY pc.oid</span></span>
<span class="line"><span>       ORDER BY CAST(</span></span>
<span class="line"><span>           (regexp_matches(pg_get_expr(c.relpartbound, c.oid), &#39;FOR VALUES FROM \\(([0-9]+)\\) TO \\(([0-9]+)\\)&#39;))[1]</span></span>
<span class="line"><span>           AS INTEGER</span></span>
<span class="line"><span>       )</span></span>
<span class="line"><span>   ) AS rank,</span></span>
<span class="line"><span>    (regexp_matches(pg_get_expr(c.relpartbound, c.oid), &#39;FOR VALUES FROM \\(([0-9]+)\\) TO \\(([0-9]+)\\)&#39;))[1] AS old_part_value</span></span>
<span class="line"><span>FROM</span></span>
<span class="line"><span>    pg_class c</span></span>
<span class="line"><span>LEFT JOIN</span></span>
<span class="line"><span>    pg_inherits inh ON inh.inhrelid = c.oid</span></span>
<span class="line"><span>LEFT JOIN</span></span>
<span class="line"><span>    pg_partitioned_table pt ON inh.inhparent = pt.partrelid</span></span>
<span class="line"><span>LEFT JOIN</span></span>
<span class="line"><span>    pg_class pc ON pc.oid = pt.partrelid</span></span>
<span class="line"><span>WHERE</span></span>
<span class="line"><span>    c.relispartition = &#39;t&#39; AND pc.relname LIKE (&#39;&lt;partition_root_schema&gt;.&lt;partition_root_name&gt;&#39;)</span></span>
<span class="line"><span>ORDER BY</span></span>
<span class="line"><span>    rank</span></span>
<span class="line"><span>LIMIT 1;</span></span></code></pre></div><p>Assuming that the partitioning method for the partitioned table is <code>RANGE</code>, the above query calculates the ranks for each child partition, and prints the range <code>START</code> value (which is always inclusive) with the highest rank.</p><p>You cannot retrieve the order number for list partitions with this query, however, because the order is based on the time the partition is added, and WarehousePG 7 does not store that information. A query for list partitions must not be dependent on order information.</p><h4 id="partitioneveryclause" tabindex="-1"><a id="pec"></a> partitioneveryclause <a class="header-anchor" href="#partitioneveryclause" aria-label="Permalink to &quot;&lt;a id=&quot;pec&quot;&gt;&lt;/a&gt; partitioneveryclause&quot;">​</a></h4><p>Because WarehousePG 7 does not store the use of the <code>EVERY</code> clause in the catalog, it can not discern if a partition was created with the clause. The main use of this column is to reconstruct a partition definition clause using the classic-syntax for display or <code>pg_dump</code> purposes. No mapping is provided at this time.</p><h4 id="partitionstartinclusive-partitionendinclusive" tabindex="-1"><a id="psipei"></a> partitionstartinclusive / partitionendinclusive <a class="header-anchor" href="#partitionstartinclusive-partitionendinclusive" aria-label="Permalink to &quot;&lt;a id=&quot;psipei&quot;&gt;&lt;/a&gt; partitionstartinclusive / partitionendinclusive&quot;">​</a></h4><p>WarehousePG 7 supports the classic syntax <code>INCLUSIVE</code> and <code>EXCLUSIVE</code> clauses through the adjustment of <code>START</code> and <code>END</code> values. It dos not record whether a range <code>START</code> or <code>END</code> is inclusive or not, because the <code>START</code> is always inclusive and the <code>END</code> is always exclusive. So the <code>partitionstartinclusive</code> and <code>partitionendinclusive</code> columns are simply redundant.</p><h4 id="partitionboundary" tabindex="-1"><a id="pb"></a> partitionboundary <a class="header-anchor" href="#partitionboundary" aria-label="Permalink to &quot;&lt;a id=&quot;pb&quot;&gt;&lt;/a&gt; partitionboundary&quot;">​</a></h4><p>You can retrieve the partition boundary definition in WarehousePG 7 via the <code>pg_get_expr()</code> function:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT </span></span>
<span class="line"><span>    pg_get_expr(relpartbound, oid)</span></span>
<span class="line"><span>FROM </span></span>
<span class="line"><span>    pg_class </span></span>
<span class="line"><span>WHERE </span></span>
<span class="line"><span>    relispartition = &#39;t&#39;;</span></span></code></pre></div><h3 id="composing-a-similar-view-in-warehousepg-7" tabindex="-1"><a id="pgparts_compose"></a> Composing a Similar View in WarehousePG 7 <a class="header-anchor" href="#composing-a-similar-view-in-warehousepg-7" aria-label="Permalink to &quot;&lt;a id=&quot;pgparts_compose&quot;&gt;&lt;/a&gt; Composing a Similar View in WarehousePG 7&quot;">​</a></h3><p>An approximate <code>pg_partitions</code> view follows. This view, given all limitations addressed above, prints the information that is possible to retrieve in WarehousePG 7.</p><blockquote><p><strong>Caution</strong> This example is for illustrative purposes only, not for practical use.</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT</span></span>
<span class="line"><span>    (SELECT relnamespace::regnamespace FROM pg_class WHERE oid = pg_partition_root(c.oid)) AS schemaname,</span></span>
<span class="line"><span>    (SELECT pg_partition_root(c.oid)::regclass) AS tablename,</span></span>
<span class="line"><span>    n.nspname AS partitionschemaname,</span></span>
<span class="line"><span>    c.relname AS partitiontablename,</span></span>
<span class="line"><span>    -- assuming the table name is implicitly generated like &lt;parent&gt;_prt_&lt;id&gt;_&lt;partition&gt;</span></span>
<span class="line"><span>    split_part(</span></span>
<span class="line"><span>        substr(c.relname, position(pc.relname in c.relname) + length(pc.relname)),</span></span>
<span class="line"><span>        &#39;_&#39;,</span></span>
<span class="line"><span>        4</span></span>
<span class="line"><span>    ) AS partitionname,</span></span>
<span class="line"><span>    pc.relname AS parentpartitiontablename,</span></span>
<span class="line"><span>    -- same assumption as above</span></span>
<span class="line"><span>    split_part(</span></span>
<span class="line"><span>        substr(pc.relname, position(ppc.relname in pc.relname) + length(ppc.relname)),</span></span>
<span class="line"><span>        &#39;_&#39;,</span></span>
<span class="line"><span>        4</span></span>
<span class="line"><span>    ) AS parentpartitionname,</span></span>
<span class="line"><span>    CASE</span></span>
<span class="line"><span>        WHEN pt.partstrat = &#39;r&#39; THEN &#39;range&#39;</span></span>
<span class="line"><span>        ELSE &#39;list&#39;</span></span>
<span class="line"><span>    END AS partitiontype,</span></span>
<span class="line"><span>    (SELECT level FROM pg_partition_tree(pg_partition_root(c.oid)) WHERE relid = c.oid) AS partitionlevel,</span></span>
<span class="line"><span>    -- can be calculated like a previous example</span></span>
<span class="line"><span>    NULL AS partitionrank,</span></span>
<span class="line"><span>    -- cannot be trusted because no real order for list partitions</span></span>
<span class="line"><span>    NULL AS partitionposition,</span></span>
<span class="line"><span>    (regexp_matches(pg_get_expr(c.relpartbound, c.oid), &#39;FOR VALUES IN \\((.*?)\\)&#39;))[1] AS partitionlistvalues,</span></span>
<span class="line"><span>    -- assuming range values are normal integers instead of expressions which WarehousePG 7 supports</span></span>
<span class="line"><span>    (regexp_matches(pg_get_expr(c.relpartbound, c.oid), &#39;FOR VALUES FROM \\(([0-9]+)\\) TO \\(([0-9]+)\\)&#39;))[1] AS partitionrangestart,</span></span>
<span class="line"><span>    &#39;t&#39; AS partitionstartinclusive,</span></span>
<span class="line"><span>    (regexp_matches(pg_get_expr(c.relpartbound, c.oid), &#39;FOR VALUES FROM \\(([0-9]+)\\) TO \\(([0-9]+)\\)&#39;))[2] AS partitionrangeend,</span></span>
<span class="line"><span>    &#39;f&#39; AS partitionendinclusive,</span></span>
<span class="line"><span>    -- information cannot be retrieved</span></span>
<span class="line"><span>    NULL AS partitioneveryclause,</span></span>
<span class="line"><span>    CASE</span></span>
<span class="line"><span>        WHEN pg_get_expr(c.relpartbound, c.oid) = &#39;DEFAULT&#39; THEN &#39;t&#39;</span></span>
<span class="line"><span>        ELSE &#39;f&#39;</span></span>
<span class="line"><span>    END AS partitionisdefault,</span></span>
<span class="line"><span>    (regexp_matches(pg_get_expr(c.relpartbound, c.oid), &#39;.+&#39;))[1] AS partitionboundary,</span></span>
<span class="line"><span>    CASE</span></span>
<span class="line"><span>        WHEN pc.reltablespace = 0 THEN &#39;pg_default&#39;</span></span>
<span class="line"><span>        ELSE (SELECT spcname FROM pg_tablespace WHERE oid = pc.reltablespace)</span></span>
<span class="line"><span>    END AS parenttablespace,</span></span>
<span class="line"><span>    CASE</span></span>
<span class="line"><span>        WHEN c.reltablespace = 0 THEN &#39;pg_default&#39;</span></span>
<span class="line"><span>        ELSE (SELECT spcname FROM pg_tablespace WHERE oid = c.reltablespace)</span></span>
<span class="line"><span>    END AS partitiontablespace</span></span>
<span class="line"><span>FROM</span></span>
<span class="line"><span>    pg_class c</span></span>
<span class="line"><span>LEFT JOIN</span></span>
<span class="line"><span>    pg_namespace n ON n.oid = c.relnamespace</span></span>
<span class="line"><span>LEFT JOIN</span></span>
<span class="line"><span>    pg_inherits inh ON inh.inhrelid = c.oid</span></span>
<span class="line"><span>LEFT JOIN</span></span>
<span class="line"><span>    pg_partitioned_table pt ON inh.inhparent = pt.partrelid</span></span>
<span class="line"><span>LEFT JOIN</span></span>
<span class="line"><span>    pg_class pc ON pc.oid = pt.partrelid</span></span>
<span class="line"><span>LEFT JOIN</span></span>
<span class="line"><span>    pg_inherits pinh ON pinh.inhrelid = pc.oid</span></span>
<span class="line"><span>LEFT JOIN</span></span>
<span class="line"><span>    pg_partitioned_table ppt ON pinh.inhparent = ppt.partrelid</span></span>
<span class="line"><span>LEFT JOIN</span></span>
<span class="line"><span>    pg_class ppc ON ppc.oid = ppt.partrelid</span></span>
<span class="line"><span>WHERE</span></span>
<span class="line"><span>    c.relispartition = &#39;t&#39;;</span></span></code></pre></div><h2 id="pg-partition-columns" tabindex="-1"><a id="pg_partition_columns"></a> pg_partition_columns <a class="header-anchor" href="#pg-partition-columns" aria-label="Permalink to &quot;&lt;a id=&quot;pg_partition_columns&quot;&gt;&lt;/a&gt; pg_partition_columns&quot;">​</a></h2><p>The WarehousePG 6 <code>pg_partition_columns</code> view displays the partition key columns of a partitioned table.</p><table tabindex="0"><thead><tr><th>Column Name</th><th>WarehousePG 6 Description</th><th>WarehousePG 7 Equivalent</th></tr></thead><tbody><tr><td>schemaname</td><td>The name of the schema in which the partitioned table resides.</td><td>Get the root partitioned table object identifier via <code>pg_partition_root()</code> and then query <a href="./../ref_guide/system_catalogs/pg_namespace.html">pg_namespace</a>.</td></tr><tr><td>tablename</td><td>The table name of the partitioned table.</td><td><a href="./../ref_guide/system_catalogs/pg_class.html">pg_class</a></td></tr><tr><td>columnname</td><td>The name of the partition key column.</td><td><a href="./../ref_guide/system_catalogs/pg_attribute.html">pg_attribute</a></td></tr><tr><td>partitionlevel</td><td>The level of this subpartition in the partition hierarchy.</td><td>Get the level from <code>pg_partition_tree() </code>using the parent object identifier.</td></tr><tr><td>position_in_partition_key</td><td>List partitions can have a composite (multi-column) partition key. This attribute identifies the position of the column in a composite key.</td><td>always 1</td></tr></tbody></table><p>The <code>position_in_partition_key</code> column is no longer relevant in WarehousePG 7. WarehousePG 7 supports a multi-column partition key via multi-column type, so the relative position of the column in the partition key will always be one. Another reason that this no longer holds true in WarehousePG 7: the <code>pg_partition_columnns</code> view assumes a homogenous partition structure, while WarehousePG 7 also supports heterogenous partition structures.</p><h3 id="composing-a-similar-view-in-warehousepg-7-1" tabindex="-1"><a id="pgpartcols_compose"></a> Composing a Similar View in WarehousePG 7 <a class="header-anchor" href="#composing-a-similar-view-in-warehousepg-7-1" aria-label="Permalink to &quot;&lt;a id=&quot;pgpartcols_compose&quot;&gt;&lt;/a&gt; Composing a Similar View in WarehousePG 7&quot;">​</a></h3><p>As long as these two assumptions hold:</p><ol><li>The partitioned table does not have a multi-column partition key.</li><li>All partition structures are a homogeneous.</li></ol><p>A query to generate a comparable view in WarehousePG 7 follows:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT </span></span>
<span class="line"><span>    c.relnamespace::regnamespace AS schemaname,</span></span>
<span class="line"><span>    c.relname AS tablename,</span></span>
<span class="line"><span>    att.attname AS columnname,</span></span>
<span class="line"><span>    (</span></span>
<span class="line"><span>        SELECT level </span></span>
<span class="line"><span>        FROM pg_partition_tree(pg_partition_root(c.oid)) </span></span>
<span class="line"><span>        WHERE relid = c.oid</span></span>
<span class="line"><span>    ) AS partitionlevel,</span></span>
<span class="line"><span>    1 AS position_in_partition_key</span></span>
<span class="line"><span>FROM </span></span>
<span class="line"><span>    pg_partitioned_table pt </span></span>
<span class="line"><span>LEFT JOIN </span></span>
<span class="line"><span>    pg_class c ON c.oid = pt.partrelid </span></span>
<span class="line"><span>JOIN </span></span>
<span class="line"><span>    pg_attribute att ON c.oid = att.attrelid AND att.attnum = pt.partattrs[0];</span></span></code></pre></div><h2 id="pg-partition-rule" tabindex="-1"><a id="pg_partition_rule"></a> pg_partition_rule <a class="header-anchor" href="#pg-partition-rule" aria-label="Permalink to &quot;&lt;a id=&quot;pg_partition_rule&quot;&gt;&lt;/a&gt; pg_partition_rule&quot;">​</a></h2><p>The WarehousePG 6 <code>pg_partition_rule</code> table tracks partitioned tables, their check constraints, and their data containment rules.</p><table tabindex="0"><thead><tr><th>Column Name</th><th>WarehousePG 6 Description</th><th>WarehousePG 7 Equivalent</th></tr></thead><tbody><tr><td>paroid</td><td>The row identifier of the partitioning level (from <code>pg_partition</code>) to which this partition belongs. In the case of a branch partition, the corresponding table (identified by <code>pg_partition_rule</code>) is an empty container table. In the case of a leaf partition, the table contains the rows for that partition containment rule.</td><td>N/A (removed object)</td></tr><tr><td>parchildrelid</td><td>The table identifier of the partition.</td><td><a href="./../ref_guide/system_catalogs/pg_class.html">pg_class</a></td></tr><tr><td>parparentrule</td><td>The row identifier of the rule associated with the parent table of this partition.</td><td>N/A (removed object)</td></tr><tr><td>parname</td><td>The given name of this partition.</td><td><a href="./../ref_guide/system_catalogs/pg_class.html">pg_class</a></td></tr><tr><td>parisdefault</td><td>Specifies whether or not this partition is a default partition.</td><td>See <a href="#pg_partitions">pg_partitions</a>.partitionisdefault.</td></tr><tr><td>parruleord</td><td>For range partitioned tables, the rank of this partition in this level of the partition hierarchy.</td><td>N/A (See the explanation for the <code>partitionposition</code>/<code>partitionrank</code> columns in <a href="#pg_partitions">pg_partitions</a>.)</td></tr><tr><td>parrangestartincl</td><td>For range partitioned tables, specifies whether or not the starting value is inclusive.</td><td>always inclusive</td></tr><tr><td>parrangeendincl</td><td>For range partitioned tables, specifies whether or not the ending value is inclusive.</td><td>always exclusive</td></tr><tr><td>parrangestart</td><td>For range partitioned tables, the starting value of the range.</td><td>See <a href="#pg_partitions">pg_partitions</a>.partitionrangestart.</td></tr><tr><td>parrangeend</td><td>For range partitioned tables, the ending value of the range.</td><td>See <a href="#pg_partitions">pg_partitions</a>.partitionrangeend.</td></tr><tr><td>parrangeevery</td><td>For range partitioned tables, the interval value of the <code>EVERY</code> clause.</td><td>N/A (See <a href="#pg_partitions">pg_partitions</a>.partitioneveryclause.)</td></tr><tr><td>parlistvalues</td><td>For list partitioned tables, the list of values assigned to this partition.</td><td>See <a href="#pg_partitions">pg_partitions</a>.partitionlistvalues.</td></tr><tr><td>parreloptions</td><td>An array describing the storage characteristics of the particular partition.</td><td><a href="./../ref_guide/system_catalogs/pg_class.html">pg_class</a>.reloptions</td></tr></tbody></table><h2 id="pg-partition" tabindex="-1"><a id="pg_partition"></a> pg_partition <a class="header-anchor" href="#pg-partition" aria-label="Permalink to &quot;&lt;a id=&quot;pg_partition&quot;&gt;&lt;/a&gt; pg_partition&quot;">​</a></h2><p>The WarehousePG 6 <code>pg_partition</code> system catalog table tracks partitioned tables and their inheritance level relationships.</p><p>The majority of this information resides in <a href="./../ref_guide/system_catalogs/pg_partitioned_table.html">pg_partitioned_table</a> in WarehousePG 7.</p><table tabindex="0"><thead><tr><th>Column Name</th><th>WarehousePG 6 Description</th><th>WarehousePG 7 Equivalent</th></tr></thead><tbody><tr><td>parrelid</td><td>The object identifier of the table.</td><td><a href="./../ref_guide/system_catalogs/pg_partitioned_table.html">pg_partitioned_table</a>.partrelid</td></tr><tr><td>parkind</td><td>The partition type - R for range or L for list.</td><td><a href="./../ref_guide/system_catalogs/pg_partitioned_table.html">pg_partitioned_table</a>.partstrat</td></tr><tr><td>parlevel</td><td>The partition level of this row: 0 for the top-level parent table, 1 for the first level under the parent table, 2 for the second level, and so on.</td><td>Cross-check <a href="./../ref_guide/system_catalogs/pg_partitioned_table.html">pg_partitioned_table</a> and <code>pg_partition_root()/pg_partition_tree()</code>, similar to how you retrieve <a href="#pg_partitions">pg_partitions</a>.partitionlevel.</td></tr><tr><td>paristemplate</td><td>Whether or not this row represents a subpartition template definition (<code>true</code>) or an actual partitioning level (<code>false</code>).</td><td>Cross-check <a href="./../ref_guide/system_catalogs/pg_partitioned_table.html">pg_partitioned_table</a>.partrelid with <a href="./../ref_guide/system_catalogs/gp_partition_template.html">gp_partition_template</a>.</td></tr><tr><td>parnatts</td><td>The number of attributes that define this level.</td><td><a href="./../ref_guide/system_catalogs/pg_partitioned_table.html">pg_partitioned_table</a>.partnatts</td></tr><tr><td>paratts</td><td>An array of the attribute numbers (as in <code>pg_attribute.attnum</code>) of the attributes that participate in defining this level.</td><td><a href="./../ref_guide/system_catalogs/pg_partitioned_table.html">pg_partitioned_table</a>.partattrs</td></tr><tr><td>parclass</td><td>The operator class identifier(s) of the partition columns.</td><td><a href="./../ref_guide/system_catalogs/pg_partitioned_table.html">pg_partitioned_table</a>.partclass</td></tr></tbody></table><h2 id="pg-partition-templates" tabindex="-1"><a id="pg_partition_templates"></a> pg_partition_templates <a class="header-anchor" href="#pg-partition-templates" aria-label="Permalink to &quot;&lt;a id=&quot;pg_partition_templates&quot;&gt;&lt;/a&gt; pg_partition_templates&quot;">​</a></h2><p>The WarehousePG 6 <code>pg_partition_templates</code> view displays the subpartitions that were created using a subpartition template.</p><p>While the information is same as that of the <code>pg_partitions</code> view, <code>pg_partition_templates</code> displays only those subpartitions created by a subpartition template (cross-check with <code>pg_partition.paristemplate</code> of the root partitioned table).</p><blockquote><p><strong>Note</strong> WarehousePG 6 assumes that if the root partitioned table has a subpartition template, then all of its subpartitions are created by this subpartition template. In WarehousePG 7 this assumption no longer holds true - you can add any table to a partitioned table with <code>ATTACH PARTITION</code>. Ensure that you take this into account when you rewrite your scripts.</p></blockquote><table tabindex="0"><thead><tr><th>Column Name</th><th>WarehousePG 6 Description</th><th>WarehousePG 7 Equivalent</th></tr></thead><tbody><tr><td>schemaname</td><td>The name of the schema in which the partitioned table resides.</td><td>See <a href="#pg_partitions">pg_partitions</a>.schemaname.</td></tr><tr><td>tablename</td><td>The table name of the top-level parent table.</td><td>See <a href="#pg_partitions">pg_partitions</a>.tablename.</td></tr><tr><td>partitionname</td><td>The name of the subpartition (this is the name to use if referring to the partition in an <code>ALTER TABLE</code> command). NULL if the partition was not given a name at create time or generated by an <code>EVERY</code> clause.</td><td>See <a href="#pg_partitions">pg_partitions</a>.partitionname.</td></tr><tr><td>partitiontype</td><td>The type of subpartition (range or list).</td><td>See <a href="#pg_partitions">pg_partitions</a>.partitiontype.</td></tr><tr><td>partitionlevel</td><td>The level of this subpartition in the hierarchy.</td><td>See <a href="#pg_partitions">pg_partitions</a>.partitionlevel.</td></tr><tr><td>partitionrank</td><td>For range partitions, the rank of the partition compared to other partitions of the same level.</td><td>See <a href="#pg_partitions">pg_partitions</a>.partitionrank.</td></tr><tr><td>partitionposition</td><td>The rule order position of this subpartition.</td><td>See <a href="#pg_partitions">pg_partitions</a>.partitionposition.</td></tr><tr><td>partitionlistvalues</td><td>For list partitions, the list value(s) associated with this subpartition.</td><td>See <a href="#pg_partitions">pg_partitions</a>.partitionlistvalues.</td></tr><tr><td>partitionrangestart</td><td>For range partitions, the start value of this subpartition.</td><td>See <a href="#pg_partitions">pg_partitions</a>.partitionrangestart.</td></tr><tr><td>partitionstartinclusive</td><td>Whether or not the start value is included in this partition. <code>true</code> if the start value is included. <code>false</code> if it is excluded.</td><td>See <a href="#pg_partitions">pg_partitions</a>.partitionstartinclusive.</td></tr><tr><td>partitionrangeend</td><td>For range partitions, the end value of this subpartition.</td><td>See <a href="#pg_partitions">pg_partitions</a>.partitionrangend.</td></tr><tr><td>partitionendinclusive</td><td>Whether or not the end value is included in this partition. <code>true</code> if the end value is included. <code>false</code> if it is excluded.</td><td>See <a href="#pg_partitions">pg_partitions</a>.partitionendinclusive.</td></tr><tr><td>partitioneveryclause</td><td>The <code>EVERY</code> clause (interval) of this subpartition.</td><td>See <a href="#pg_partitions">pg_partitions</a>.partitioneveryclause.</td></tr><tr><td>partitionisdefault</td><td>Whether or not this is a default subpartition. <code>true</code> if this is the default, otherwise <code>false</code>.</td><td>See <a href="#pg_partitions">pg_partitions</a>.partitionisdefault.</td></tr><tr><td>partitionboundary</td><td>The entire partition specification for this subpartition.</td><td>See <a href="#pg_partitions">pg_partitions</a>.partitionboundary.</td></tr></tbody></table><h2 id="pg-partition-encoding" tabindex="-1"><a id="pg_partition_encoding"></a> pg_partition_encoding <a class="header-anchor" href="#pg-partition-encoding" aria-label="Permalink to &quot;&lt;a id=&quot;pg_partition_encoding&quot;&gt;&lt;/a&gt; pg_partition_encoding&quot;">​</a></h2><p>The WarehousePG 6 <code>pg_partition_encoding</code> table describes the available column compression options for a subpartition template. This information is stored in <a href="./../ref_guide/system_catalogs/gp_partition_template.html">gp_partition_template</a> in WarehousePG 7.</p><p>You must perform some text filtering to retrieve the per-column encoding information in WarehousePG 7 in the same format as that of <code>pg_partition_encoding</code>.</p><table tabindex="0"><thead><tr><th>Column Name</th><th>WarehousePG 6 Description</th><th>WarehousePG 7 Equivalent</th></tr></thead><tbody><tr><td>parencoid</td><td>The object identifier of the parent partition of this subpartition template.</td><td><code>gp_partition_template</code></td></tr><tr><td>parencattnum</td><td>The attribute number of the column for which the encoding option applies.</td><td><code>pg_get_expr(template, &lt;root_partition_oid&gt;)</code></td></tr><tr><td>parencattoptions</td><td>The storage option of this column.</td><td><code>pg_get_expr(template, &lt;root_partition_oid&gt;)</code></td></tr></tbody></table><h3 id="composing-a-similar-view-in-warehousepg-7-2" tabindex="-1"><a id="pgpartenc_compose"></a> Composing a Similar View in WarehousePG 7 <a class="header-anchor" href="#composing-a-similar-view-in-warehousepg-7-2" aria-label="Permalink to &quot;&lt;a id=&quot;pgpartenc_compose&quot;&gt;&lt;/a&gt; Composing a Similar View in WarehousePG 7&quot;">​</a></h3><p>You can retrieve a one-line definition of the template using <code>pg_get_expr()</code> as follows:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT level, pg_get_expr(template, relid) from gp_partition_template where relid::regclass::text = &#39;&lt;tablename&gt;&#39;;</span></span>
<span class="line"><span> level |                                                                                                          pg_get_expr</span></span>
<span class="line"><span>-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span></span>
<span class="line"><span>     1 | SUBPARTITION TEMPLATE(SUBPARTITION sp1 VALUES (1, 2, 3, 4, 5), COLUMN i ENCODING (compresstype=zlib), COLUMN j ENCODING (compresstype=rle_type), COLUMN k ENCODING (compresstype=zlib), COLUMN l ENCODING (compresstype=zlib))</span></span></code></pre></div><h2 id="pg-stat-partition-operations" tabindex="-1"><a id="pg_stat_partition_operations"></a> pg_stat_partition_operations <a class="header-anchor" href="#pg-stat-partition-operations" aria-label="Permalink to &quot;&lt;a id=&quot;pg_stat_partition_operations&quot;&gt;&lt;/a&gt; pg_stat_partition_operations&quot;">​</a></h2><p>The WarehousePG 6 <code>pg_stat_partition_operations</code> view displays details about the last operation performed on a partitioned table.</p><p>The view displays the same information as <code>pg_stat_operations</code>, but only for the partitioned table and its child partitions. You can retrieve similar information in WarehousePG 7 with a query such as:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT</span></span>
<span class="line"><span>    so.*,</span></span>
<span class="line"><span>    (SELECT level FROM pg_partition_tree(pg_partition_root(c.oid)) WHERE relid = c.oid) AS partitionlevel,</span></span>
<span class="line"><span>    pc.relname AS parentpartitiontablename,</span></span>
<span class="line"><span>    pc.relnamespace::regnamespace AS parentschemaname,</span></span>
<span class="line"><span>    pc.oid AS parent_relid</span></span>
<span class="line"><span>FROM</span></span>
<span class="line"><span>    pg_stat_operations so</span></span>
<span class="line"><span>LEFT JOIN</span></span>
<span class="line"><span>    pg_class c ON so.objid = c.oid</span></span>
<span class="line"><span>LEFT JOIN</span></span>
<span class="line"><span>    pg_namespace n ON n.oid = c.relnamespace</span></span>
<span class="line"><span>LEFT JOIN</span></span>
<span class="line"><span>    pg_inherits inh ON inh.inhrelid = c.oid</span></span>
<span class="line"><span>LEFT JOIN</span></span>
<span class="line"><span>    pg_partitioned_table pt ON inh.inhparent = pt.partrelid</span></span>
<span class="line"><span>LEFT JOIN</span></span>
<span class="line"><span>    pg_class pc ON pc.oid = pt.partrelid</span></span>
<span class="line"><span>WHERE</span></span>
<span class="line"><span>    c.relispartition = &#39;t&#39; OR c.oid IN (SELECT partrelid FROM pg_partitioned_table);</span></span></code></pre></div>`,71)]))}const u=a(s,[["render",p]]);export{g as __pageData,u as default};
