import{_ as a,c as t,o as n,ag as o}from"./chunks/framework.Ds6Eueu6.js";const m=JSON.parse('{"title":"Pseudo-Types","description":"","frontmatter":{},"headers":[],"relativePath":"docs/7x/ref_guide/datatype-pseudo.md","filePath":"docs/7x/ref_guide/datatype-pseudo.md"}'),s={name:"docs/7x/ref_guide/datatype-pseudo.md"};function r(i,e,p,l,c,d){return n(),t("div",null,e[0]||(e[0]=[o('<h1 id="pseudo-types" tabindex="-1">Pseudo-Types <a class="header-anchor" href="#pseudo-types" aria-label="Permalink to &quot;Pseudo-Types&quot;">​</a></h1><p>WarehousePG supports special-purpose data type entries that are collectively called <em>pseudo-types</em>. A pseudo-type cannot be used as a column data type, but it can be used to declare a function&#39;s argument or result type. Each of the available pseudo-types is useful in situations where a function&#39;s behavior does not correspond to simply taking or returning a value of a specific SQL data type.</p><p>Functions coded in procedural languages can use pseudo-types only as allowed by their implementation languages. The procedural languages all forbid use of a pseudo-type as an argument type, and allow only <em>void</em> and <em>record</em> as a result type.</p><p>A function with the pseudo-type <em>record</em> as a return data type returns an unspecified row type. The <em>record</em> represents an array of possibly-anonymous composite types. Since composite datums carry their own type identification, no extra knowledge is needed at the array level.</p><p>The pseudo-type <em>void</em> indicates that a function returns no value.</p><blockquote><p><strong>Note</strong> WarehousePG does not support triggers and the pseudo-type <em>trigger</em>.</p></blockquote><p>The types <em>anyelement</em>, <em>anyarray</em>, <em>anynonarray</em>, and <em>anyenum</em> are pseudo-types called polymorphic types. Some procedural languages also support polymorphic functions using the types <em>anyarray</em>, <em>anyelement</em>, <em>anyenum</em>, and <em>anynonarray</em>.</p><p>The pseudo-type <em>anytable</em> is a WarehousePG type that specifies a table expression—an expression that computes a table. WarehousePG allows this type only as an argument to a user-defined function. See <a href="#topic_ig2_1pc_qfb">Table Value Expressions</a> for more about the <em>anytable</em> pseudo-type.</p><p>For more information about pseudo-types, see the PostgreSQL documentation about <a href="https://www.postgresql.org/docs/12/datatype-pseudo.html" target="_blank" rel="noreferrer">Pseudo-Types</a>.</p><p><strong>Parent topic:</strong> <a href="./data_types.html">Data Types</a></p><h2 id="polymorphic-types" tabindex="-1"><a id="topic_dbn_bpc_qfb"></a>Polymorphic Types <a class="header-anchor" href="#polymorphic-types" aria-label="Permalink to &quot;&lt;a id=&quot;topic_dbn_bpc_qfb&quot;&gt;&lt;/a&gt;Polymorphic Types&quot;">​</a></h2><p>Four pseudo-types of special interest are <em>anyelement</em>, <em>anyarray</em>, <em>anynonarray</em>, and <em>anyenum</em>, which are collectively called <em>polymorphic</em> types. Any function declared using these types is said to be a polymorphic function. A polymorphic function can operate on many different data types, with the specific data types being determined by the data types actually passed to it at runtime.</p><p>Polymorphic arguments and results are tied to each other and are resolved to a specific data type when a query calling a polymorphic function is parsed. Each position (either argument or return value) declared as <em>anyelement</em> is allowed to have any specific actual data type, but in any given call they must all be the same actual type. Each position declared as <em>anyarray</em> can have any array data type, but similarly they must all be the same type. If there are positions declared <em>anyarray</em> and others declared <em>anyelement</em>, the actual array type in the <em>anyarray</em> positions must be an array whose elements are the same type appearing in the <em>anyelement</em> positions. <em>anynonarray</em> is treated exactly the same as <em>anyelement</em>, but adds the additional constraint that the actual type must not be an array type. <em>anyenum</em> is treated exactly the same as <em>anyelement</em>, but adds the additional constraint that the actual type must be an <code>enum</code> type.</p><p>When more than one argument position is declared with a polymorphic type, the net effect is that only certain combinations of actual argument types are allowed. For example, a function declared as <code>equal(*anyelement*, *anyelement*)</code> takes any two input values, so long as they are of the same data type.</p><p>When the return value of a function is declared as a polymorphic type, there must be at least one argument position that is also polymorphic, and the actual data type supplied as the argument determines the actual result type for that call. For example, if there were not already an array subscripting mechanism, one could define a function that implements subscripting as <code>subscript(*anyarray*, integer) returns *anyelement*</code>. This declaration constrains the actual first argument to be an array type, and allows the parser to infer the correct result type from the actual first argument&#39;s type. Another example is that a function declared as <code>myfunc(*anyarray*) returns *anyenum*</code> will only accept arrays of <code>enum</code> types.</p><p>Note that <em>anynonarray</em> and <em>anyenum</em> do not represent separate type variables; they are the same type as <em>anyelement</em>, just with an additional constraint. For example, declaring a function as <code>myfunc(*anyelement*, *anyenum*)</code> is equivalent to declaring it as <code>myfunc(*anyenum*, *anyenum*)</code>: both actual arguments must be the same <code>enum</code> type.</p><p>A variadic function (one taking a variable number of arguments) is polymorphic when its last parameter is declared as <code>VARIADIC *anyarray*</code>. For purposes of argument matching and determining the actual result type, such a function behaves the same as if you had declared the appropriate number of <em>anynonarray</em> parameters.</p><p>For more information about polymorphic types, see the PostgreSQL documentation about <a href="https://www.postgresql.org/docs/12/xfunc-c.html#AEN56822" target="_blank" rel="noreferrer">Polymorphic Arguments and Return Types</a>.</p><h2 id="table-value-expressions" tabindex="-1"><a id="topic_ig2_1pc_qfb"></a>Table Value Expressions <a class="header-anchor" href="#table-value-expressions" aria-label="Permalink to &quot;&lt;a id=&quot;topic_ig2_1pc_qfb&quot;&gt;&lt;/a&gt;Table Value Expressions&quot;">​</a></h2><p>The <em>anytable</em> pseudo-type declares a function argument that is a table value expression. The notation for a table value expression is a <code>SELECT</code> statement enclosed in a <code>TABLE()</code> function. You can specify a distribution policy for the table by adding <code>SCATTER RANDOMLY</code>, or a <code>SCATTER BY</code> clause with a column list to specify the distribution key.</p><p>The <code>SELECT</code> statement is run when the function is called and the result rows are distributed to segments so that each segment runs the function with a subset of the result table.</p><p>For example, this table expression selects three columns from a table named <code>customer</code> and sets the distribution key to the first column:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>TABLE(SELECT cust_key, name, address FROM customer SCATTER BY 1)</span></span></code></pre></div><p>The <code>SELECT</code> statement may include joins on multiple base tables, <code>WHERE</code> clauses, aggregates, and any other valid query syntax.</p><p>The <em>anytable</em> type is only permitted in functions implemented in the C or C++ languages. The body of the function can access the table using the WarehousePG Server Programming Interface (SPI) or the WarehousePG Partner Connector (GPPC) API.</p>',25)]))}const y=a(s,[["render",r]]);export{m as __pageData,y as default};
