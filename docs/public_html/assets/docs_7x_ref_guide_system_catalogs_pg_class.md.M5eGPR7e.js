import{_ as t,c as d,o,ag as a}from"./chunks/framework.Ds6Eueu6.js";const b=JSON.parse('{"title":"pg_class","description":"","frontmatter":{},"headers":[],"relativePath":"docs/7x/ref_guide/system_catalogs/pg_class.md","filePath":"docs/7x/ref_guide/system_catalogs/pg_class.md"}'),r={name:"docs/7x/ref_guide/system_catalogs/pg_class.md"};function i(s,e,c,n,l,h){return o(),d("div",null,e[0]||(e[0]=[a('<h1 id="pg-class" tabindex="-1">pg_class <a class="header-anchor" href="#pg-class" aria-label="Permalink to &quot;pg_class&quot;">â€‹</a></h1><p>The system catalog table <code>pg_class</code> catalogs tables and most everything else that has columns or is otherwise similar to a table. This includes indexes (see also <a href="./pg_index.html">pg_index</a>), sequences, views, materialized views, composite types, and TOAST tables. Below, when we mean all of these kinds of objects we speak of &quot;relations&quot;. Not all columns are meaningful for all relation types.</p><table tabindex="0"><thead><tr><th>column</th><th>type</th><th>references</th><th>description</th></tr></thead><tbody><tr><td><code>oid</code></td><td>oid</td><td></td><td>Row identifier</td></tr><tr><td><code>relname</code></td><td>name</td><td></td><td>Name of the table, index, view, etc.</td></tr><tr><td><code>relnamespace</code></td><td>oid</td><td><a href="./pg_namespace.html">pg_namespace</a>.oid</td><td>The object identifier of the namespace (schema) that contains this relation</td></tr><tr><td><code>reltype</code></td><td>oid</td><td><a href="./pg_type.html">pg_type</a>.oid</td><td>The object identifier of the data type that corresponds to this table&#39;s row type, if any (zero for indexes, which have no <code>pg_type</code> entry)</td></tr><tr><td><code>reloftype</code></td><td>oid</td><td><a href="./pg_type.html">pg_type</a>.oid</td><td>For typed tables, the object identifier of the underlying composite type, zero for all other relations</td></tr><tr><td><code>relowner</code></td><td>oid</td><td><a href="./pg_authid.html">pg_authid</a>.oid</td><td>Owner of the relation</td></tr><tr><td><code>relam</code></td><td>oid</td><td><a href="./pg_am.html">pg_am</a>.oid</td><td>If this is a table or an index, the access method used (heap, B-tree, hash, etc.)</td></tr><tr><td><code>relfilenode</code></td><td>oid</td><td></td><td>Name of the on-disk file of this relation; zero means this is a &quot;mapped&quot; relation whose disk file name is determined by low-level state</td></tr><tr><td><code>reltablespace</code></td><td>oid</td><td><a href="./pg_tablespace.html">pg_tablespace</a>.oid</td><td>The tablespace in which this relation is stored. If zero, the database&#39;s default tablespace is implied. (Not meaningful if the relation has no on-disk file.)</td></tr><tr><td><code>relpages</code></td><td>int4</td><td></td><td>Size of the on-disk representation of this table in pages (of size <code>BLCKSZ</code>). This is only an estimate used by the planner. It is updated by <code>VACUUM</code>, <code>ANALYZE</code>, and a few DDL commands such as <code>CREATE INDEX</code>.</td></tr><tr><td><code>reltuples</code></td><td>float4</td><td></td><td>Number of rows in the table. This is only an estimate used by the planner. It is updated by <code>VACUUM</code>, <code>ANALYZE</code>, and a few DDL commands such as <code>CREATE INDEX</code>.</td></tr><tr><td><code>relallvisible</code></td><td>int4</td><td></td><td>Number of pages that are marked all-visible in the table&#39;s visibility map. This is only an estimate used by the planner. It is updated by <code>VACUUM</code>, <code>ANALYZE</code>, and a few DDL commands such as <code>CREATE INDEX</code>.</td></tr><tr><td><code>reltoastrelid</code></td><td>oid</td><td>pg_class.oid</td><td>The object identifier of the TOAST table associated with this table, <code>0</code> if none. The TOAST table stores large attributes &quot;out of line&quot; in a secondary table.</td></tr><tr><td><code>relhasindex</code></td><td>boolean</td><td></td><td>True if this is a table and it has (or recently had) any indexes.</td></tr><tr><td><code>relisshared</code></td><td>boolean</td><td></td><td>True if this table is shared across all databases in the system. Only certain system catalog tables (such as <code>pg_database</code>) are shared.</td></tr><tr><td><code>relpersistence</code></td><td>char</td><td></td><td>The type of object persistence: <code>p</code> = heap or append-optimized permanent table, <code>u</code> = unlogged temporary table, <code>t</code> = temporary table.</td></tr><tr><td><code>relkind</code></td><td>char</td><td></td><td>The type of object<br><br><code>r</code> = heap or append-optimized ordinary table, <code>i</code> = index, <code>S</code> = sequence, <code>t</code> = TOAST table, <code>v</code> = view, <code>m</code> = materialized view, <code>c</code> = composite type, <code>f</code> = foreign table, <code>p</code> = partitioned table, <code>I</code> = partitioned index, <code>u</code> = uncatalogued temporary heap table, <code>o</code> = internal append-optimized segment files and EOFs, <code>b</code> = append-only block directory, <code>M</code> = append-only visibility map.</td></tr><tr><td><code>relnatts</code></td><td>int2</td><td></td><td>Number of user columns in the relation (system columns not counted). There must be this many corresponding entries in <code>pg_attribute</code>. See also <code>pg_attribute.attnum</code>.</td></tr><tr><td><code>relchecks</code></td><td>int2</td><td></td><td>Number of <code>CHECK</code> constraints on the table; see <a href="./pg_constraint.html">pg_constraint</a> catalog.</td></tr><tr><td><code>relhasrules</code></td><td>boolean</td><td></td><td>True if table has (or once had) rules; see <a href="./pg_rewrite.html">pg_rewrite</a> catalog.</td></tr><tr><td><code>relhastriggers</code></td><td>boolean</td><td></td><td>True if table has (or once had) triggers.</td></tr><tr><td><code>relhassubclass</code></td><td>boolean</td><td></td><td>True if table has (or once had) any inheritance children.</td></tr><tr><td><code>relrowsecurity</code></td><td>boolean</td><td></td><td>True if table has row level security enabled; see <code>pg_policy</code> catalog.</td></tr><tr><td><code>relforcerowsecurity</code></td><td>boolean</td><td></td><td>True if row level security (when enabled) will also apply to the table owner; see <code>pg_policy</code> catalog.</td></tr><tr><td><code>relispopulated</code></td><td>boolean</td><td></td><td>True if relation is populated (this is true for all relations other than some materialized views).</td></tr><tr><td><code>relreplident</code></td><td>char</td><td></td><td>Columns used to form &quot;replica identity&quot; for rows: <code>d</code> = default (primary key, if any), <code>n</code> = nothing, <code>f</code> = all columns, <code>i</code> = index with <code>indisreplident</code> set (same as nothing if the index used has been dropped).</td></tr><tr><td><code>relispartition</code></td><td>boolean</td><td></td><td>True if table or index is a partition.</td></tr><tr><td><code>relrewrite</code></td><td>oid</td><td><a href="./pg_class.html">pg_class</a>.oid</td><td>For new relations being written during a DDL operation that requires a table rewrite, this contains the object identifier of the original relation; otherwise 0. That state is only visible internally; this field should never contain anything other than 0 for a user-visible relation.</td></tr><tr><td><code>relfrozenxid</code></td><td>xid</td><td></td><td>All transaction IDs before this one have been replaced with a permanent (frozen) transaction ID in this table. This is used to track whether the table needs to be vacuumed in order to prevent transaction ID wraparound or to allow <code>pg_xact</code> to be shrunk.<br><br>The value is <code>0</code> (<code>InvalidTransactionId</code>) if the relation is not a table or if the table does not require vacuuming to prevent transaction ID wraparound. The table still might require vacuuming to reclaim disk space.</td></tr><tr><td><code>relminmxid</code></td><td>xid</td><td></td><td>All multixact IDs before this one have been replaced by a transaction ID in this table. This is used to track whether the table needs to be vacuumed in order to prevent multixact ID wraparound or to allow <code>pg_multixact</code> to be shrunk. Zero (<code>InvalidMultiXactId</code>) if the relation is not a table.</td></tr><tr><td><code>relacl</code></td><td>aclitem[]</td><td></td><td>Access privileges assigned by <code>GRANT</code> and <code>REVOKE</code>.</td></tr><tr><td><code>reloptions</code></td><td>text[]</td><td></td><td>Access-method-specific options, as &quot;keyword=value&quot; strings.</td></tr><tr><td><code>relpartbound</code></td><td>pg_node_tree</td><td></td><td>If table is a partition (see <code>relispartition</code>), internal representation of the partition bound.</td></tr></tbody></table><p>Several of the Boolean flags in <code>pg_class</code> are maintained lazily: they are guaranteed to be true if that&#39;s the correct state, but may not be reset to false immediately when the condition is no longer true. For example, <code>relhasindex</code> is set by <code>CREATE INDEX</code>, but it is never cleared by <code>DROP INDEX</code>. Instead, <code>VACUUM</code> clears <code>relhasindex</code> if it finds the table has no indexes. This arrangement avoids race conditions and improves concurrency.</p><p><strong>Parent topic:</strong> <a href="./../system_catalogs/catalog_ref-html.html">System Catalogs Definitions</a></p>',5)]))}const u=t(r,[["render",i]]);export{b as __pageData,u as default};
