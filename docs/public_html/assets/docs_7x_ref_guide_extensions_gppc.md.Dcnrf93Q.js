import{_ as t,c as a,o as n,ag as s}from"./chunks/framework.Ds6Eueu6.js";const h=JSON.parse('{"title":"WarehousePG Partner Connector API","description":"","frontmatter":{},"headers":[],"relativePath":"docs/7x/ref_guide/extensions/gppc.md","filePath":"docs/7x/ref_guide/extensions/gppc.md"}'),p={name:"docs/7x/ref_guide/extensions/gppc.md"};function i(o,e,l,c,r,d){return n(),a("div",null,e[0]||(e[0]=[s(`<h1 id="warehousepg-partner-connector-api" tabindex="-1">WarehousePG Partner Connector API <a class="header-anchor" href="#warehousepg-partner-connector-api" aria-label="Permalink to &quot;WarehousePG Partner Connector API&quot;">​</a></h1><p>With the WarehousePG Partner Connector API (GPPC API), you can write portable WarehousePG user-defined functions (UDFs) in the C and C++ programming languages. Functions that you develop with the GPPC API require no recompilation or modification to work with older or newer WarehousePG versions.</p><p>Functions that you write to the GPPC API can be invoked using SQL in WarehousePG. The API provides a set of functions and macros that you can use to issue SQL commands through the Server Programming Interface (SPI), manipulate simple and composite data type function arguments and return values, manage memory, and handle data.</p><p>You compile the C/C++ functions that you develop with the GPPC API into a shared library. The GPPC functions are available to WarehousePG users after the shared library is installed in the WarehousePG cluster and the GPPC functions are registered as SQL UDFs.</p><p>This topic contains the following information:</p><ul><li><a href="#topic_dev">Using the GPPC API</a><ul><li><a href="#topic_reqs">Requirements</a></li><li><a href="#topic_files">Header and Library Files</a></li><li><a href="#topic_data">Data Types</a></li><li><a href="#topic_argres">Function Declaration, Arguments, and Results</a></li><li><a href="#topic_mem">Memory Handling</a></li><li><a href="#topic_varlentext">Working With Variable-Length Text Types</a></li><li><a href="#topic_errrpt">Error Reporting and Logging</a></li><li><a href="#topic_spi">SPI Functions</a></li><li><a href="#topic_tuple">About Tuple Descriptors and Tuples</a></li><li><a href="#topic_srf">Set-Returning Functions</a></li><li><a href="#topic_tblfunc">Table Functions</a></li><li><a href="#topic_limits">Limitations</a></li><li><a href="#topic_samplecode">Sample Code</a></li></ul></li><li><a href="#topic_build">Building a GPPC Shared Library with PGXS</a></li><li><a href="#topic_reg">Registering a GPPC Function with WarehousePG</a></li><li><a href="#topic_deploy">Packaging and Deployment Considerations</a></li><li><a href="#topic_example_text">GPPC Text Function Example</a></li><li><a href="#topic_example_srf">GPPC Set-Returning Function Example</a></li></ul><h2 id="using-the-gppc-api" tabindex="-1"><a id="topic_dev"></a>Using the GPPC API <a class="header-anchor" href="#using-the-gppc-api" aria-label="Permalink to &quot;&lt;a id=&quot;topic_dev&quot;&gt;&lt;/a&gt;Using the GPPC API&quot;">​</a></h2><p>The GPPC API shares some concepts with C language functions as defined by PostgreSQL. Refer to <a href="https://www.postgresql.org/docs/12/xfunc-c.html" target="_blank" rel="noreferrer">C-Language Functions</a> in the PostgreSQL documentation for detailed information about developing C language functions.</p><p>The GPPC API is a wrapper that makes a C/C++ function SQL-invokable in WarehousePG. This wrapper shields GPPC functions that you write from WarehousePG library changes by normalizing table and data manipulation and SPI operations through functions and macros defined by the API.</p><p>The GPPC API includes functions and macros to:</p><ul><li>Operate on base and composite data types.</li><li>Process function arguments and return values.</li><li>Allocate and free memory.</li><li>Log and report errors to the client.</li><li>Issue SPI queries.</li><li>Return a table or set of rows.</li><li>Process tables as function input arguments.</li></ul><h3 id="requirements" tabindex="-1"><a id="topic_reqs"></a>Requirements <a class="header-anchor" href="#requirements" aria-label="Permalink to &quot;&lt;a id=&quot;topic_reqs&quot;&gt;&lt;/a&gt;Requirements&quot;">​</a></h3><p>When you develop with the GPPC API:</p><ul><li>You must develop your code on a system with the same hardware and software architecture as that of your WarehousePG hosts.</li><li>You must write the GPPC function(s) in the C or C++ programming languages.</li><li>The function code must use the GPPC API, data types, and macros.</li><li>The function code must <em>not</em> use the PostgreSQL C-Language Function API, header files, functions, or macros.</li><li>The function code must <em>not</em> <code>#include</code> the <code>postgres.h</code> header file or use <code>PG_MODULE_MAGIC</code>.</li><li>You must use only the GPPC-wrapped memory functions to allocate and free memory. See <a href="#topic_mem">Memory Handling</a>.</li><li>Symbol names in your object files must not conflict with each other nor with symbols defined in the WarehousePG server. You must rename your functions or variables if you get error messages to this effect.</li></ul><h3 id="header-and-library-files" tabindex="-1"><a id="topic_files"></a>Header and Library Files <a class="header-anchor" href="#header-and-library-files" aria-label="Permalink to &quot;&lt;a id=&quot;topic_files&quot;&gt;&lt;/a&gt;Header and Library Files&quot;">​</a></h3><p>The GPPC header files and libraries are installed in <code>$GPHOME</code>:</p><ul><li>$GPHOME/include/gppc.h - the main GPPC header file</li><li>$GPHOME/include/gppc_config.h - header file defining the GPPC version</li><li>$GPHOME/lib/libgppc.[a, so, so.1, so.1.2] - GPPC archive and shared libraries</li></ul><h3 id="data-types" tabindex="-1"><a id="topic_data"></a>Data Types <a class="header-anchor" href="#data-types" aria-label="Permalink to &quot;&lt;a id=&quot;topic_data&quot;&gt;&lt;/a&gt;Data Types&quot;">​</a></h3><p>The GPPC functions that you create will operate on data residing in WarehousePG. The GPPC API includes data type definitions for equivalent WarehousePG SQL data types. You must use these types in your GPPC functions.</p><p>The GPPC API defines a generic data type that you can use to represent any GPPC type. This data type is named <code>GppcDatum</code>, and is defined as follows:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>typedef int64_t GppcDatum;</span></span></code></pre></div><p>The following table identifies each GPPC data type and the SQL type to which it maps.</p><table tabindex="0"><thead><tr><th>SQL Type</th><th>GPPC Type</th><th>GPPC Oid for Type</th></tr></thead><tbody><tr><td>boolean</td><td>GppcBool</td><td>GppcOidBool</td></tr><tr><td>char (single byte)</td><td>GppcChar</td><td>GppcOidChar</td></tr><tr><td>int2/smallint</td><td>GppcInt2</td><td>GppcOidInt2</td></tr><tr><td>int4/integer</td><td>GppcInt4</td><td>GppcOidInt4</td></tr><tr><td>int8/bigint</td><td>GppcInt8</td><td>GppcOidInt8</td></tr><tr><td>float4/real</td><td>GppcFloat4</td><td>GppcOidFloat4</td></tr><tr><td>float8/double</td><td>GppcFloat8</td><td>GppcOidFloat8</td></tr><tr><td>text</td><td>*GppcText</td><td>GppcOidText</td></tr><tr><td>varchar</td><td>*GppcVarChar</td><td>GppcOidVarChar</td></tr><tr><td>char</td><td>*GppcBpChar</td><td>GppcOidBpChar</td></tr><tr><td>bytea</td><td>*GppcBytea</td><td>GppcOidBytea</td></tr><tr><td>numeric</td><td>*GppcNumeric</td><td>GppcOidNumeric</td></tr><tr><td>date</td><td>GppcDate</td><td>GppcOidDate</td></tr><tr><td>time</td><td>GppcTime</td><td>GppcOidTime</td></tr><tr><td>timetz</td><td>*GppcTimeTz</td><td>GppcOidTimeTz</td></tr><tr><td>timestamp</td><td>GppcTimestamp</td><td>GppcOidTimestamp</td></tr><tr><td>timestamptz</td><td>GppcTimestampTz</td><td>GppcOidTimestampTz</td></tr><tr><td>anytable</td><td>GppcAnyTable</td><td>GppcOidAnyTable</td></tr><tr><td>oid</td><td>GppcOid</td><td></td></tr></tbody></table><p>The GPPC API treats text, numeric, and timestamp data types specially, providing functions to operate on these types.</p><p>Example GPPC base data type declarations:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>GppcText       message;</span></span>
<span class="line"><span>GppcInt4       arg1;</span></span>
<span class="line"><span>GppcNumeric    total_sales;</span></span></code></pre></div><p>The GPPC API defines functions to convert between the generic <code>GppcDatum</code> type and the GPPC specific types. For example, to convert from an integer to a datum:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>GppcInt4 num = 13;</span></span>
<span class="line"><span>GppcDatum num_dat = GppcInt4GetDatum(num);</span></span></code></pre></div><h4 id="composite-types" tabindex="-1"><a id="topic_composite"></a>Composite Types <a class="header-anchor" href="#composite-types" aria-label="Permalink to &quot;&lt;a id=&quot;topic_composite&quot;&gt;&lt;/a&gt;Composite Types&quot;">​</a></h4><p>A composite data type represents the structure of a row or record, and is comprised of a list of field names and their data types. This structure information is typically referred to as a tuple descriptor. An instance of a composite type is typically referred to as a tuple or row. A tuple does not have a fixed layout and can contain null fields.</p><p>The GPPC API provides an interface that you can use to define the structure of, to access, and to set tuples. You will use this interface when your GPPC function takes a table as an input argument or returns table or set of record types. Using tuples in table and set returning functions is covered later in this topic.</p><h3 id="function-declaration-arguments-and-results" tabindex="-1"><a id="topic_argres"></a>Function Declaration, Arguments, and Results <a class="header-anchor" href="#function-declaration-arguments-and-results" aria-label="Permalink to &quot;&lt;a id=&quot;topic_argres&quot;&gt;&lt;/a&gt;Function Declaration, Arguments, and Results&quot;">​</a></h3><p>The GPPC API relies on macros to declare functions and to simplify the passing of function arguments and results. These macros include:</p><table tabindex="0"><thead><tr><th>Task</th><th>Macro Signature</th><th>Description</th></tr></thead><tbody><tr><td>Make a function SQL-invokable</td><td><code>GPPC_FUNCTION_INFO(function\\_name)</code></td><td>Glue to make function <code>function\\_name</code> SQL-invokable.</td></tr><tr><td>Declare a function</td><td><code>GppcDatum function\\_name(GPPC_FUNCTION_ARGS)</code></td><td>Declare a GPPC function named <code>function\\_name</code>; every function must have this same signature.</td></tr><tr><td>Return the number of arguments</td><td><code>GPPC_NARGS()</code></td><td>Return the number of arguments passed to the function.</td></tr><tr><td>Fetch an argument</td><td><code>GPPC_GETARG_&lt;ARGTYPE&gt;(arg\\_num)</code></td><td>Fetch the value of argument number arg_num (starts at 0), where <code>&lt;ARGTYPE&gt;</code> identifies the data type of the argument. For example, <code>GPPC_GETARG_FLOAT8(0)</code>.</td></tr><tr><td>Fetch and make a copy of a text-type argument</td><td><code>GPPC_GETARG_&lt;ARGTYPE&gt;_COPY(arg\\_num)</code></td><td>Fetch and make a copy of the value of argument number arg_num (starts at 0). <code>&lt;ARGTYPE&gt;</code> identifies the text type (text, varchar, bpchar, bytea). For example, <code>GPPC_GETARG_BYTEA_COPY(1)</code>.</td></tr><tr><td>Determine if an argument is NULL</td><td><code>GPPC_ARGISNULL(arg\\_num)</code></td><td>Return whether or not argument number <code>arg\\_num</code> is NULL.</td></tr><tr><td>Return a result</td><td><code>GPPC_RETURN_&lt;ARGTYPE&gt;(return\\_val)</code></td><td>Return the value <code>return\\_val</code>, where <code>&lt;ARGTYPE&gt;</code> identifies the data type of the return value. For example, <code>GPPC_RETURN_INT4(131)</code>.</td></tr></tbody></table><p>When you define and implement your GPPC function, you must declare it with the GPPC API using the two declarations identified above. For example, to declare a GPPC function named <code>add_int4s()</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>GPPC_FUNCTION_INFO(add_int4s);</span></span>
<span class="line"><span>GppcDatum add_int4s(GPPC_FUNCTION_ARGS);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>GppcDatum</span></span>
<span class="line"><span>add_int4s(GPPC_FUNCTION_ARGS)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  // code here</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>If the <code>add_int4s()</code> function takes two input arguments of type <code>int4</code>, you use the <code>GPPC_GETARG_INT4(arg\\_num)</code> macro to access the argument values. The argument index starts at 0. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>GppcInt4  first_int = GPPC_GETARG_INT4(0);</span></span>
<span class="line"><span>GppcInt4  second_int = GPPC_GETARG_INT4(1);</span></span></code></pre></div><p>If <code>add_int4s()</code> returns the sum of the two input arguments, you use the <code>GPPC_RETURN_INT8(return\\_val)</code> macro to return this sum. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>GppcInt8  sum = first_int + second_int;</span></span>
<span class="line"><span>GPPC_RETURN_INT8(sum);</span></span></code></pre></div><p>The complete GPPC function:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>GPPC_FUNCTION_INFO(add_int4s);</span></span>
<span class="line"><span>GppcDatum add_int4s(GPPC_FUNCTION_ARGS);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>GppcDatum</span></span>
<span class="line"><span>add_int4s(GPPC_FUNCTION_ARGS)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  // get input arguments</span></span>
<span class="line"><span>  GppcInt4    first_int = GPPC_GETARG_INT4(0);</span></span>
<span class="line"><span>  GppcInt4    second_int = GPPC_GETARG_INT4(1);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // add the arguments</span></span>
<span class="line"><span>  GppcInt8    sum = first_int + second_int;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // return the sum</span></span>
<span class="line"><span>  GPPC_RETURN_INT8(sum);</span></span>
<span class="line"><span>}</span></span></code></pre></div><h3 id="memory-handling" tabindex="-1"><a id="topic_mem"></a>Memory Handling <a class="header-anchor" href="#memory-handling" aria-label="Permalink to &quot;&lt;a id=&quot;topic_mem&quot;&gt;&lt;/a&gt;Memory Handling&quot;">​</a></h3><p>The GPPC API provides functions that you use to allocate and free memory, including text memory. You must use these functions for all memory operations.</p><table tabindex="0"><thead><tr><th>Function Name</th><th>Description</th></tr></thead><tbody><tr><td>void *GppcAlloc( size_t num )</td><td>Allocate num bytes of uninitialized memory.</td></tr><tr><td>void *GppcAlloc0( size_t num )</td><td>Allocate num bytes of 0-initialized memory.</td></tr><tr><td>void *GppcRealloc( void *ptr, size_t num )</td><td>Resize pre-allocated memory.</td></tr><tr><td>void GppcFree( void *ptr )</td><td>Free allocated memory.</td></tr></tbody></table><p>After you allocate memory, you can use system functions such as <code>memcpy()</code> to set the data.</p><p>The following example allocates an array of <code>GppcDatum</code>s and sets the array to datum versions of the function input arguments:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>GppcDatum  *values;</span></span>
<span class="line"><span>int attnum = GPPC_NARGS();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// allocate memory for attnum values</span></span>
<span class="line"><span>values = GppcAlloc( sizeof(GppcDatum) * attnum );</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// set the values</span></span>
<span class="line"><span>for( int i=0; i&lt;attnum; i++ ) {</span></span>
<span class="line"><span>    GppcDatum d = GPPC_GETARG_DATUM(i);</span></span>
<span class="line"><span>    values[i] = d;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>When you allocate memory for a GPPC function, you allocate it in the current context. The GPPC API includes functions to return, create, switch, and reset memory contexts.</p><table tabindex="0"><thead><tr><th>Function Name</th><th>Description</th></tr></thead><tbody><tr><td>GppcMemoryContext GppcGetCurrentMemoryContext(void)</td><td>Return the current memory context.</td></tr><tr><td>GppcMemoryContext GppcMemoryContextCreate(GppcMemoryContext parent)</td><td>Create a new memory context under parent.</td></tr><tr><td>GppcMemoryContext GppcMemoryContextSwitchTo(GppcMemoryContext context)</td><td>Switch to the memory context context.</td></tr><tr><td>void GppcMemoryContextReset(GppcMemoryContext context)</td><td>Reset (free) the memory in memory context context.</td></tr></tbody></table><p>WarehousePG typically calls a SQL-invoked function in a per-tuple context that it creates and deletes every time the server backend processes a table row. Do not assume that memory allocated in the current memory context is available across multiple function calls.</p><h3 id="working-with-variable-length-text-types" tabindex="-1"><a id="topic_varlentext"></a>Working With Variable-Length Text Types <a class="header-anchor" href="#working-with-variable-length-text-types" aria-label="Permalink to &quot;&lt;a id=&quot;topic_varlentext&quot;&gt;&lt;/a&gt;Working With Variable-Length Text Types&quot;">​</a></h3><p>The GPPC API supports the variable length text, varchar, blank padded, and byte array types. You must use the GPPC API-provided functions when you operate on these data types. Variable text manipulation functions provided in the GPPC API include those to allocate memory for, determine string length of, get string pointers for, and access these types:</p><table tabindex="0"><thead><tr><th>Function Name</th><th>Description</th></tr></thead><tbody><tr><td>GppcText GppcAllocText( size_t len )<br><br>GppcVarChar GppcAllocVarChar( size_t len )<br><br>GppcBpChar GppcAllocBpChar( size_t len )<br><br><br><br>GppcBytea GppcAllocBytea( size_t len )</td><td>Allocate len bytes of memory for the varying length type.</td></tr><tr><td>size_t GppcGetTextLength( GppcText s )<br><br>size_t GppcGetVarCharLength( GppcVarChar s )<br><br>size_t GppcGetBpCharLength( GppcBpChar s )<br><br>size_t GppcGetByteaLength( GppcBytea b )</td><td>Return the number of bytes in the memory chunk.</td></tr><tr><td>char *GppcGetTextPointer( GppcText s )<br><br>char *GppcGetVarCharPointer( GppcVarChar s )<br><br>char *GppcGetBpCharPointer( GppcBpChar s )<br><br>char *GppcGetByteaPointer( GppcBytea b )</td><td>Return a string pointer to the head of the memory chunk. The string is not null-terminated.</td></tr><tr><td>char *GppcTextGetCString( GppcText s )<br><br>char *GppcVarCharGetCString( GppcVarChar s )<br><br>char *GppcBpCharGetCString( GppcBpChar s )</td><td>Return a string pointer to the head of the memory chunk. The string is null-terminated.</td></tr><tr><td>GppcText *GppcCStringGetText( const char *s )<br><br>GppcVarChar *GppcCStringGetVarChar( const char *s )<br><br>GppcBpChar *GppcCStringGetBpChar( const char *s )</td><td>Build a varying-length type from a character string.</td></tr></tbody></table><p>Memory returned by the <code>GppcGet&lt;VLEN_ARGTYPE&gt;Pointer()</code> functions may point to actual database content. Do not modify the memory content. The GPPC API provides functions to allocate memory for these types should you require it. After you allocate memory, you can use system functions such as <code>memcpy()</code> to set the data.</p><p>The following example manipulates text input arguments and allocates and sets result memory for a text string concatenation operation:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>GppcText first_textstr = GPPC_GETARG_TEXT(0);</span></span>
<span class="line"><span>GppcText second_textstr = GPPC_GETARG_TEXT(1);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// determine the size of the concatenated string and allocate</span></span>
<span class="line"><span>// text memory of this size</span></span>
<span class="line"><span>size_t arg0_len = GppcGetTextLength(first_textstr);</span></span>
<span class="line"><span>size_t arg1_len = GppcGetTextLength(second_textstr);</span></span>
<span class="line"><span>GppcText retstring = GppcAllocText(arg0_len + arg1_len);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// construct the concatenated return string; copying each string</span></span>
<span class="line"><span>// individually</span></span>
<span class="line"><span>memcpy(GppcGetTextPointer(retstring), GppcGetTextPointer(first_textstr), arg0_len);</span></span>
<span class="line"><span>memcpy(GppcGetTextPointer(retstring) + arg0_len, GppcGetTextPointer(second_textstr), arg1_len);</span></span></code></pre></div><h3 id="error-reporting-and-logging" tabindex="-1"><a id="topic_errrpt"></a>Error Reporting and Logging <a class="header-anchor" href="#error-reporting-and-logging" aria-label="Permalink to &quot;&lt;a id=&quot;topic_errrpt&quot;&gt;&lt;/a&gt;Error Reporting and Logging&quot;">​</a></h3><p>The GPPC API provides error reporting and logging functions. The API defines reporting levels equivalent to those in WarehousePG:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>typedef enum GppcReportLevel</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>        GPPC_DEBUG1                             = 10,</span></span>
<span class="line"><span>        GPPC_DEBUG2                             = 11,</span></span>
<span class="line"><span>        GPPC_DEBUG3                             = 12,</span></span>
<span class="line"><span>        GPPC_DEBUG4                             = 13,</span></span>
<span class="line"><span>        GPPC_DEBUG                              = 14,</span></span>
<span class="line"><span>        GPPC_LOG                                = 15,</span></span>
<span class="line"><span>        GPPC_INFO                               = 17,</span></span>
<span class="line"><span>        GPPC_NOTICE                             = 18,</span></span>
<span class="line"><span>        GPPC_WARNING                    	= 19,</span></span>
<span class="line"><span>        GPPC_ERROR                              = 20,</span></span>
<span class="line"><span>} GppcReportLevel;</span></span></code></pre></div><p>(The WarehousePG <a href="./../config_params/guc-list.html"><code>client_min_messages</code></a> server configuration parameter governs the current client logging level. The <a href="./../config_params/guc-list.html"><code>log_min_messages</code></a> configuration parameter governs the current log-to-logfile level.)</p><p>A GPPC report includes the report level, a report message, and an optional report callback function.</p><p>Reporting and handling functions provide by the GPPC API include:</p><table tabindex="0"><thead><tr><th>Function Name</th><th>Description</th></tr></thead><tbody><tr><td>GppcReport()</td><td>Format and print/log a string of the specified report level.</td></tr><tr><td>GppcInstallReportCallback()</td><td>Register/install a report callback function.</td></tr><tr><td>GppcUninstallReportCallback()</td><td>Uninstall a report callback function.</td></tr><tr><td>GppcGetReportLevel()</td><td>Retrieve the level from an error report.</td></tr><tr><td>GppcGetReportMessage()</td><td>Retrieve the message from an error report.</td></tr><tr><td>GppcCheckForInterrupts()</td><td>Error out if an interrupt is pending.</td></tr></tbody></table><p>The <code>GppcReport()</code> function signature is:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>void GppcReport(GppcReportLevel elevel, const char *fmt, ...);</span></span></code></pre></div><p><code>GppcReport()</code> takes a format string input argument similar to <code>printf()</code>. The following example generates an error level report message that formats a GPPC text argument:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>GppcText  uname = GPPC_GETARG_TEXT(1);</span></span>
<span class="line"><span>GppcReport(GPPC_ERROR, &quot;Unknown user name: %s&quot;, GppcTextGetCString(uname));</span></span></code></pre></div><p>Refer to the <a href="https://github.com/greenplum-db/gpdb/tree/main/src/interfaces/gppc/test" target="_blank" rel="noreferrer">GPPC example code</a> for example report callback handlers.</p><h3 id="spi-functions" tabindex="-1"><a id="topic_spi"></a>SPI Functions <a class="header-anchor" href="#spi-functions" aria-label="Permalink to &quot;&lt;a id=&quot;topic_spi&quot;&gt;&lt;/a&gt;SPI Functions&quot;">​</a></h3><p>The WarehousePG Server Programming Interface (SPI) provides writers of C/C++ functions the ability to run SQL commands within a GPPC function. For additional information on SPI functions, refer to <a href="https://www.postgresql.org/docs/12/spi.html" target="_blank" rel="noreferrer">Server Programming Interface</a> in the PostgreSQL documentation.</p><p>The GPPC API exposes a subset of PostgreSQL SPI functions. This subset enables you to issue SPI queries and retrieve SPI result values in your GPPC function. The GPPC SPI wrapper functions are:</p><table tabindex="0"><thead><tr><th>SPI Function Name</th><th>GPPC Function Name</th><th>Description</th></tr></thead><tbody><tr><td>SPI_connect()</td><td>GppcSPIConnect()</td><td>Connect to the WarehousePG server programming interface.</td></tr><tr><td>SPI_finish()</td><td>GppcSPIFinish()</td><td>Disconnect from the WarehousePG server programming interface.</td></tr><tr><td>SPI_exec()</td><td>GppcSPIExec()</td><td>Run a SQL statement, returning the number of rows.</td></tr><tr><td>SPI_getvalue()</td><td>GppcSPIGetValue()</td><td>Retrieve the value of a specific attribute by number from a SQL result as a character string.</td></tr><tr><td>GppcSPIGetDatum()</td><td>Retrieve the value of a specific attribute by number from a SQL result as a <code>GppcDatum</code>.</td><td></td></tr><tr><td>GppcSPIGetValueByName()</td><td>Retrieve the value of a specific attribute by name from a SQL result as a character string.</td><td></td></tr><tr><td>GppcSPIGetDatumByName()</td><td>Retrieve the value of a specific attribute by name from a SQL result as a <code>GppcDatum</code>.</td><td></td></tr></tbody></table><p>When you create a GPPC function that accesses the server programming interface, your function should comply with the following flow:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>GppcSPIConnect();</span></span>
<span class="line"><span>GppcSPIExec(...)</span></span>
<span class="line"><span>// process the results - GppcSPIGetValue(...), GppcSPIGetDatum(...)</span></span>
<span class="line"><span>GppcSPIFinish()</span></span></code></pre></div><p>You use <code>GppcSPIExec()</code> to run SQL statements in your GPPC function. When you call this function, you also identify the maximum number of rows to return. The function signature of <code>GppcSPIExec()</code> is:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>GppcSPIResult GppcSPIExec(const char *sql_statement, long rcount);</span></span></code></pre></div><p><code>GppcSPIExec()</code> returns a <code>GppcSPIResult</code> structure. This structure represents SPI result data. It includes a pointer to the data, information about the number of rows processed, a counter, and a result code. The GPPC API defines this structure as follows:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>typedef struct GppcSPIResultData</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    struct GppcSPITupleTableData   *tuptable;</span></span>
<span class="line"><span>    uint32_t                       processed;</span></span>
<span class="line"><span>    uint32_t                       current;</span></span>
<span class="line"><span>    int                            rescode;</span></span>
<span class="line"><span>} GppcSPIResultData;</span></span>
<span class="line"><span>typedef GppcSPIResultData *GppcSPIResult;</span></span></code></pre></div><p>You can set and use the <code>current</code> field in the <code>GppcSPIResult</code> structure to examine each row of the <code>tuptable</code> result data.</p><p>The following code excerpt uses the GPPC API to connect to SPI, run a simple query, loop through query results, and finish processing:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>GppcSPIResult   result;</span></span>
<span class="line"><span>char            *attname = &quot;id&quot;;</span></span>
<span class="line"><span>char            *query = &quot;SELECT i, &#39;foo&#39; || i AS val FROM generate_series(1, 10)i ORDER BY 1&quot;;</span></span>
<span class="line"><span>bool            isnull = true;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// connect to SPI</span></span>
<span class="line"><span>if( GppcSPIConnect() &lt; 0 ) {</span></span>
<span class="line"><span>    GppcReport(GPPC_ERROR, &quot;cannot connect to SPI&quot;);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// execute the query, returning all rows</span></span>
<span class="line"><span>result = GppcSPIExec(query, 0);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// process result</span></span>
<span class="line"><span>while( result-&gt;current &lt; result-&gt;processed ) {</span></span>
<span class="line"><span>    // get the value of attname column as a datum, making a copy</span></span>
<span class="line"><span>    datum = GppcSPIGetDatumByName(result, attname, &amp;isnull, true);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // do something with value</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // move on to next row</span></span>
<span class="line"><span>    result-&gt;current++;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// complete processing</span></span>
<span class="line"><span>GppcSPIFinish();</span></span></code></pre></div><h3 id="about-tuple-descriptors-and-tuples" tabindex="-1"><a id="topic_tuple"></a>About Tuple Descriptors and Tuples <a class="header-anchor" href="#about-tuple-descriptors-and-tuples" aria-label="Permalink to &quot;&lt;a id=&quot;topic_tuple&quot;&gt;&lt;/a&gt;About Tuple Descriptors and Tuples&quot;">​</a></h3><p>A table or a set of records contains one or more tuples (rows). The structure of each attribute of a tuple is defined by a tuple descriptor. A tuple descriptor defines the following for each attribute in the tuple:</p><ul><li>attribute name</li><li>object identifier of the attribute data type</li><li>byte length of the attribute data type</li><li>object identifier of the attribute modifer</li></ul><p>The GPPC API defines an abstract type, <code>GppcTupleDesc</code>, to represent a tuple/row descriptor. The API also provides functions that you can use to create, access, and set tuple descriptors:</p><table tabindex="0"><thead><tr><th>Function Name</th><th>Description</th></tr></thead><tbody><tr><td>GppcCreateTemplateTupleDesc()</td><td>Create an empty tuple descriptor with a specified number of attributes.</td></tr><tr><td>GppcTupleDescInitEntry()</td><td>Add an attribute to the tuple descriptor at a specified position.</td></tr><tr><td>GppcTupleDescNattrs()</td><td>Fetch the number of attributes in the tuple descriptor.</td></tr><tr><td>GppcTupleDescAttrName()</td><td>Fetch the name of the attribute in a specific position (starts at 0) in the tuple descriptor.</td></tr><tr><td>GppcTupleDescAttrType()</td><td>Fetch the type object identifier of the attribute in a specific position (starts at 0) in the tuple descriptor.</td></tr><tr><td>GppcTupleDescAttrLen()</td><td>Fetch the type length of an attribute in a specific position (starts at 0) in the tuple descriptor.</td></tr><tr><td>GppcTupleDescAttrTypmod()</td><td>Fetch the type modifier object identifier of an attribute in a specific position (starts at 0) in the tuple descriptor.</td></tr></tbody></table><p>To construct a tuple descriptor, you first create a template, and then fill in the descriptor fields for each attribute. The signatures for these functions are:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>GppcTupleDesc GppcCreateTemplateTupleDesc(int natts);</span></span>
<span class="line"><span>void GppcTupleDescInitEntry(GppcTupleDesc desc, uint16_t attno,</span></span>
<span class="line"><span>                            const char *attname, GppcOid typid, int32_t typmod);</span></span></code></pre></div><p>In some cases, you may want to initialize a tuple descriptor entry from an attribute definition in an existing tuple. The following functions fetch the number of attributes in a tuple descriptor, as well as the definition of a specific attribute (by number) in the descriptor:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int GppcTupleDescNattrs(GppcTupleDesc tupdesc);</span></span>
<span class="line"><span>const char *GppcTupleDescAttrName(GppcTupleDesc tupdesc, int16_t attno);</span></span>
<span class="line"><span>GppcOid GppcTupleDescAttrType(GppcTupleDesc tupdesc, int16_t attno);</span></span>
<span class="line"><span>int16_t GppcTupleDescAttrLen(GppcTupleDesc tupdesc, int16_t attno);</span></span>
<span class="line"><span>int32_t GppcTupleDescAttrTypmod(GppcTupleDesc tupdesc, int16_t attno);</span></span></code></pre></div><p>The following example initializes a two attribute tuple descriptor. The first attribute is initialized with the definition of an attribute from a different descriptor, and the second attribute is initialized to a boolean type attribute:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>GppcTupleDesc       tdesc;</span></span>
<span class="line"><span>GppcTupleDesc       indesc = some_input_descriptor;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// initialize the tuple descriptor with 2 attributes</span></span>
<span class="line"><span>tdesc = GppcCreateTemplateTupleDesc(2);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// use third attribute from the input descriptor</span></span>
<span class="line"><span>GppcTupleDescInitEntry(tdesc, 1, </span></span>
<span class="line"><span>	       GppcTupleDescAttrName(indesc, 2),</span></span>
<span class="line"><span>	       GppcTupleDescAttrType(indesc, 2),</span></span>
<span class="line"><span>	       GppcTupleDescAttrTypmod(indesc, 2));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// create the boolean attribute</span></span>
<span class="line"><span>GppcTupleDescInitEntry(tdesc, 2, &quot;is_active&quot;, GppcOidBool, 0);</span></span></code></pre></div><p>The GPPC API defines an abstract type, <code>GppcHeapTuple</code>, to represent a tuple/record/row. A tuple is defined by its tuple descriptor, the value for each tuple attribute, and an indicator of whether or not each value is NULL.</p><p>The GPPC API provides functions that you can use to set and access a tuple and its attributes:</p><table tabindex="0"><thead><tr><th>Function Name</th><th>Description</th></tr></thead><tbody><tr><td>GppcHeapFormTuple()</td><td>Form a tuple from an array of <code>GppcDatum</code>s.</td></tr><tr><td>GppcBuildHeapTupleDatum()</td><td>Form a <code>GppcDatum</code> tuple from an array of <code>GppcDatum</code>s.</td></tr><tr><td>GppcGetAttributeByName()</td><td>Fetch an attribute from the tuple by name.</td></tr><tr><td>GppcGetAttributeByNum()</td><td>Fetch an attribute from the tuple by number (starts at 1).</td></tr></tbody></table><p>The signatures for the tuple-building GPPC functions are:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>GppcHeapTuple GppcHeapFormTuple(GppcTupleDesc tupdesc, GppcDatum *values, bool *nulls);</span></span>
<span class="line"><span>GppcDatum    GppcBuildHeapTupleDatum(GppcTupleDesc tupdesc, GppcDatum *values, bool *nulls);</span></span></code></pre></div><p>The following code excerpt constructs a <code>GppcDatum</code> tuple from the tuple descriptor in the above code example, and from integer and boolean input arguments to a function:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>GppcDatum intarg = GPPC_GETARG_INT4(0);</span></span>
<span class="line"><span>GppcDatum boolarg = GPPC_GETARG_BOOL(1);</span></span>
<span class="line"><span>GppcDatum result, values[2];</span></span>
<span class="line"><span>bool nulls[2] = { false, false };</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// construct the values array</span></span>
<span class="line"><span>values[0] = intarg;</span></span>
<span class="line"><span>values[1] = boolarg;</span></span>
<span class="line"><span>result = GppcBuildHeapTupleDatum( tdesc, values, nulls );</span></span></code></pre></div><h3 id="set-returning-functions" tabindex="-1"><a id="topic_srf"></a>Set-Returning Functions <a class="header-anchor" href="#set-returning-functions" aria-label="Permalink to &quot;&lt;a id=&quot;topic_srf&quot;&gt;&lt;/a&gt;Set-Returning Functions&quot;">​</a></h3><p>WarehousePG UDFs whose signatures include <code>RETURNS SETOF RECORD</code> or <code>RETURNS TABLE( ... )</code> are set-returning functions.</p><p>The GPPC API provides support for returning sets (for example, multiple rows/tuples) from a GPPC function. WarehousePG calls a set-returning function (SRF) once for each row or item. The function must save enough state to remember what it was doing and to return the next row on each call. Memory that you allocate in the SRF context must survive across multiple function calls.</p><p>The GPPC API provides macros and functions to help keep track of and set this context, and to allocate SRF memory. They include:</p><table tabindex="0"><thead><tr><th>Function/Macro Name</th><th>Description</th></tr></thead><tbody><tr><td>GPPC_SRF_RESULT_DESC()</td><td>Get the output row tuple descriptor for this SRF. The result tuple descriptor is determined by an output table definition or a <code>DESCRIBE</code> function.</td></tr><tr><td>GPPC_SRF_IS_FIRSTCALL()</td><td>Determine if this is the first call to the SRF.</td></tr><tr><td>GPPC_SRF_FIRSTCALL_INIT()</td><td>Initialize the SRF context.</td></tr><tr><td>GPPC_SRF_PERCALL_SETUP()</td><td>Restore the context on each call to the SRF.</td></tr><tr><td>GPPC_SRF_RETURN_NEXT()</td><td>Return a value from the SRF and continue processing.</td></tr><tr><td>GPPC_SRF_RETURN_DONE()</td><td>Signal that SRF processing is complete.</td></tr><tr><td>GppSRFAlloc()</td><td>Allocate memory in this SRF context.</td></tr><tr><td>GppSRFAlloc0()</td><td>Allocate memory in this SRF context and initialize it to zero.</td></tr><tr><td>GppSRFSave()</td><td>Save user state in this SRF context.</td></tr><tr><td>GppSRFRestore()</td><td>Restore user state in this SRF context.</td></tr></tbody></table><p>The <code>GppcFuncCallContext</code> structure provides the context for an SRF. You create this context on the first call to your SRF. Your set-returning GPPC function must retrieve the function context on each invocation. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// set function context</span></span>
<span class="line"><span>GppcFuncCallContext fctx;</span></span>
<span class="line"><span>if (GPPC_SRF_IS_FIRSTCALL()) {</span></span>
<span class="line"><span>    fctx = GPPC_SRF_FIRSTCALL_INIT();</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>fctx = GPPC_SRF_PERCALL_SETUP();</span></span>
<span class="line"><span>// process the tuple</span></span></code></pre></div><p>The GPPC function must provide the context when it returns a tuple result or to indicate that processing is complete. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>GPPC_SRF_RETURN_NEXT(fctx, result_tuple);</span></span>
<span class="line"><span>// or</span></span>
<span class="line"><span>GPPC_SRF_RETURN_DONE(fctx);</span></span></code></pre></div><p>Use a <code>DESCRIBE</code> function to define the output tuple descriptor of a function that uses the <code>RETURNS SETOF RECORD</code> clause. Use the <code>GPPC_SRF_RESULT_DESC()</code> macro to get the output tuple descriptor of a function that uses the <code>RETURNS TABLE( ... )</code> clause.</p><p>Refer to the <a href="#topic_example_srf">GPPC Set-Returning Function Example</a> for a set-returning function code and deployment example.</p><h3 id="table-functions" tabindex="-1"><a id="topic_tblfunc"></a>Table Functions <a class="header-anchor" href="#table-functions" aria-label="Permalink to &quot;&lt;a id=&quot;topic_tblfunc&quot;&gt;&lt;/a&gt;Table Functions&quot;">​</a></h3><p>The GPPC API provides the <code>GppcAnyTable</code> type to pass a table to a function as an input argument, or to return a table as a function result.</p><p>Table-related functions and macros provided in the GPPC API include:</p><table tabindex="0"><thead><tr><th>Function/Macro Name</th><th>Description</th></tr></thead><tbody><tr><td>GPPC_GETARG_ANYTABLE()</td><td>Fetch an anytable function argument.</td></tr><tr><td>GPPC_RETURN_ANYTABLE()</td><td>Return the table.</td></tr><tr><td>GppcAnyTableGetTupleDesc()</td><td>Fetch the tuple descriptor for the table.</td></tr><tr><td>GppcAnyTableGetNextTuple()</td><td>Fetch the next row in the table.</td></tr></tbody></table><p>You can use the <code>GPPC_GETARG_ANYTABLE()</code> macro to retrieve a table input argument. When you have access to the table, you can examine the tuple descriptor for the table using the <code>GppcAnyTableGetTupleDesc()</code> function. The signature of this function is:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>GppcTupleDesc GppcAnyTableGetTupleDesc(GppcAnyTable t);</span></span></code></pre></div><p>For example, to retrieve the tuple descriptor of a table that is the first input argument to a function:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>GppcAnyTable     intbl;</span></span>
<span class="line"><span>GppcTupleDesc    in_desc;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>intbl = GPPC_GETARG_ANYTABLE(0);</span></span>
<span class="line"><span>in_desc = GppcAnyTableGetTupleDesc(intbl);</span></span></code></pre></div><p>The <code>GppcAnyTableGetNextTuple()</code> function fetches the next row from the table. Similarly, to retrieve the next tuple from the table above:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>GppcHeapTuple    ntuple;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>ntuple = GppcAnyTableGetNextTuple(intbl);</span></span></code></pre></div><h3 id="limitations" tabindex="-1"><a id="topic_limits"></a>Limitations <a class="header-anchor" href="#limitations" aria-label="Permalink to &quot;&lt;a id=&quot;topic_limits&quot;&gt;&lt;/a&gt;Limitations&quot;">​</a></h3><p>The GPPC API does not support the following operators with WarehousePG version 5.0.x:</p><ul><li>integer || integer</li><li>integer = text</li><li>text &lt; integer</li></ul><h3 id="sample-code" tabindex="-1"><a id="topic_samplecode"></a>Sample Code <a class="header-anchor" href="#sample-code" aria-label="Permalink to &quot;&lt;a id=&quot;topic_samplecode&quot;&gt;&lt;/a&gt;Sample Code&quot;">​</a></h3><p>The <a href="https://github.com/greenplum-db/gpdb/tree/main/src/interfaces/gppc/test" target="_blank" rel="noreferrer">gppc test</a> directory in the WarehousePG github repository includes sample GPPC code:</p><ul><li><code>gppc_demo/</code> - sample code exercising GPPC SPI functions, error reporting, data type argument and return macros, set-returning functions, and encoding functions</li><li><code>tabfunc_gppc_demo/</code> - sample code exercising GPPC table and set-returning functions</li></ul><h2 id="building-a-gppc-shared-library-with-pgxs" tabindex="-1"><a id="topic_build"></a>Building a GPPC Shared Library with PGXS <a class="header-anchor" href="#building-a-gppc-shared-library-with-pgxs" aria-label="Permalink to &quot;&lt;a id=&quot;topic_build&quot;&gt;&lt;/a&gt;Building a GPPC Shared Library with PGXS&quot;">​</a></h2><p>You compile functions that you write with the GPPC API into one or more shared libraries that the WarehousePG server loads on demand.</p><p>You can use the PostgreSQL build extension infrastructure (PGXS) to build the source code for your GPPC functions against a WarehousePG installation. This framework automates common build rules for simple modules. If you have a more complicated use case, you will need to write your own build system.</p><p>To use the PGXS infrastructure to generate a shared library for functions that you create with the GPPC API, create a simple <code>Makefile</code> that sets PGXS-specific variables.</p><blockquote><p><strong>Note</strong> Refer to <a href="https://www.postgresql.org/docs/12/extend-pgxs.html" target="_blank" rel="noreferrer">Extension Building Infrastructure</a> in the PostgreSQL documentation for information about the <code>Makefile</code> variables supported by PGXS.</p></blockquote><p>For example, the following <code>Makefile</code> generates a shared library named <code>sharedlib_name.so</code> from two C source files named <code>src1.c</code> and <code>src2.c</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MODULE_big = sharedlib_name</span></span>
<span class="line"><span>OBJS = src1.o src2.o</span></span>
<span class="line"><span>PG_CPPFLAGS = -I$(shell $(PG_CONFIG) --includedir)</span></span>
<span class="line"><span>SHLIB_LINK = -L$(shell $(PG_CONFIG) --libdir) -lgppc</span></span>
<span class="line"><span></span></span>
<span class="line"><span>PG_CONFIG = pg_config</span></span>
<span class="line"><span>PGXS := $(shell $(PG_CONFIG) --pgxs)</span></span>
<span class="line"><span>include $(PGXS)</span></span></code></pre></div><p><code>MODULE_big</code> identifes the base name of the shared library generated by the <code>Makefile</code>.</p><p><code>PG_CPPFLAGS</code> adds the WarehousePG installation include directory to the compiler header file search path.</p><p><code>SHLIB_LINK</code> adds the WarehousePG installation library directory to the linker search path. This variable also adds the GPPC library (<code>-lgppc</code>) to the link command.</p><p>The <code>PG_CONFIG</code> and <code>PGXS</code> variable settings and the <code>include</code> statement are required and typically reside in the last three lines of the <code>Makefile</code>.</p><h2 id="registering-a-gppc-function-with-warehousepg" tabindex="-1"><a id="topic_reg"></a>Registering a GPPC Function with WarehousePG <a class="header-anchor" href="#registering-a-gppc-function-with-warehousepg" aria-label="Permalink to &quot;&lt;a id=&quot;topic_reg&quot;&gt;&lt;/a&gt;Registering a GPPC Function with WarehousePG&quot;">​</a></h2><p>Before users can invoke a GPPC function from SQL, you must register the function with WarehousePG.</p><p>Registering a GPPC function involves mapping the GPPC function signature to a SQL user-defined function. You define this mapping with the <code>CREATE FUNCTION .. AS</code> command specifying the GPPC shared library name. You may choose to use the same name or differing names for the GPPC and SQL functions.</p><p>Sample <code>CREATE FUNCTION ... AS</code> syntax follows:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE FUNCTION &lt;sql_function_name&gt;(&lt;arg&gt;[, ...]) RETURNS &lt;return_type&gt;</span></span>
<span class="line"><span>  AS &#39;&lt;shared_library_path&gt;&#39;[, &#39;&lt;gppc_function_name&gt;&#39;]</span></span>
<span class="line"><span>LANGUAGE C STRICT [WITH (DESCRIBE=&lt;describe_function&gt;)];</span></span></code></pre></div><p>You may omit the shared library <code>.so</code> extension when you specify <code>shared\\_library\\_path</code>.</p><p>The following command registers the example <code>add_int4s()</code> function referenced earlier in this topic to a SQL UDF named <code>add_two_int4s_gppc()</code> if the GPPC function was compiled and linked in a shared library named <code>gppc_try.so</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE FUNCTION add_two_int4s_gppc(int4, int4) RETURNS int8</span></span>
<span class="line"><span>  AS &#39;gppc_try.so&#39;, &#39;add_int4s&#39;</span></span>
<span class="line"><span>LANGUAGE C STRICT;</span></span></code></pre></div><h3 id="about-dynamic-loading" tabindex="-1"><a id="topic_dynload"></a>About Dynamic Loading <a class="header-anchor" href="#about-dynamic-loading" aria-label="Permalink to &quot;&lt;a id=&quot;topic_dynload&quot;&gt;&lt;/a&gt;About Dynamic Loading&quot;">​</a></h3><p>You specify the name of the GPPC shared library in the SQL <code>CREATE FUNCTION ... AS</code> command to register a GPPC function in the shared library with WarehousePG. The WarehousePG dynamic loader loads a GPPC shared library file into memory the first time that a user invokes a user-defined function linked in that shared library. If you do not provide an absolute path to the shared library in the <code>CREATE FUNCTION ... AS</code> command, WarehousePG attempts to locate the library using these ordered steps:</p><ol><li>If the shared library file path begins with the string <code>$libdir</code>, WarehousePG looks for the file in the PostgreSQL package library directory. Run the <code>pg_config --pkglibdir</code> command to determine the location of this directory.</li><li>If the shared library file name is specified without a directory prefix, WarehousePG searches for the file in the directory identified by the <code>dynamic_library_path</code> server configuration parameter value.</li><li>The current working directory.</li></ol><h2 id="packaging-and-deployment-considerations" tabindex="-1"><a id="topic_deploy"></a>Packaging and Deployment Considerations <a class="header-anchor" href="#packaging-and-deployment-considerations" aria-label="Permalink to &quot;&lt;a id=&quot;topic_deploy&quot;&gt;&lt;/a&gt;Packaging and Deployment Considerations&quot;">​</a></h2><p>You must package the GPPC shared library and SQL function registration script in a form suitable for deployment by the WarehousePG administrator in the WarehousePG cluster. Provide specific deployment instructions for your GPPC package.</p><p>When you construct the package and deployment instructions, take into account the following:</p><ul><li>Consider providing a shell script or program that the WarehousePG administrator runs to both install the shared library to the desired file system location and register the GPPC functions.</li><li>The GPPC shared library must be installed to the same file system location on the coordinator host and on every segment host in the WarehousePG cluster.</li><li>The <code>gpadmin</code> user must have permission to traverse the complete file system path to the GPPC shared library file.</li><li>The file system location of your GPPC shared library after it is installed in the WarehousePG deployment determines how you reference the shared library when you register a function in the library with the <code>CREATE FUNCTION ... AS</code> command.</li><li>Create a <code>.sql</code> script file that registers a SQL UDF for each GPPC function in your GPPC shared library. The functions that you create in the <code>.sql</code> registration script must reference the deployment location of the GPPC shared library. Include this script in your GPPC deployment package.</li><li>Document the instructions for running your GPPC package deployment script, if you provide one.</li><li>Document the instructions for installing the GPPC shared library if you do not include this task in a package deployment script.</li><li>Document the instructions for installing and running the function registration script if you do not include this task in a package deployment script.</li></ul><h2 id="gppc-text-function-example" tabindex="-1"><a id="topic_example_text"></a>GPPC Text Function Example <a class="header-anchor" href="#gppc-text-function-example" aria-label="Permalink to &quot;&lt;a id=&quot;topic_example_text&quot;&gt;&lt;/a&gt;GPPC Text Function Example&quot;">​</a></h2><p>In this example, you develop, build, and deploy a GPPC shared library and register and run a GPPC function named <code>concat_two_strings</code>. This function uses the GPPC API to concatenate two string arguments and return the result.</p><p>You will develop the GPPC function on your WarehousePG coordinator host. Deploying the GPPC shared library that you create in this example requires administrative access to your WarehousePG cluster.</p><p>Perform the following procedure to run the example:</p><ol><li><p>Log in to the WarehousePG coordinator host and set up your environment. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$ ssh gpadmin@&lt;gpcoordinator&gt;</span></span>
<span class="line"><span>gpadmin@gpcoordinator$ . /usr/local/greenplum-db/greenplum_path.sh</span></span></code></pre></div></li><li><p>Create a work directory and navigate to the new directory. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>gpadmin@gpcoordinator$ mkdir gppc_work</span></span>
<span class="line"><span>gpadmin@gpcoordinator$ cd gppc_work</span></span></code></pre></div></li><li><p>Prepare a file for GPPC source code by opening the file in the editor of your choice. For example, to open a file named <code>gppc_concat.c</code> using <code>vi</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>gpadmin@gpcoordinator$ vi gppc_concat.c</span></span></code></pre></div></li><li><p>Copy/paste the following code into the file:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#include &lt;stdio.h&gt;</span></span>
<span class="line"><span>#include &lt;string.h&gt;</span></span>
<span class="line"><span>#include &quot;gppc.h&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// make the function SQL-invokable</span></span>
<span class="line"><span>GPPC_FUNCTION_INFO(concat_two_strings);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// declare the function</span></span>
<span class="line"><span>GppcDatum concat_two_strings(GPPC_FUNCTION_ARGS);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>GppcDatum</span></span>
<span class="line"><span>concat_two_strings(GPPC_FUNCTION_ARGS)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    // retrieve the text input arguments</span></span>
<span class="line"><span>    GppcText arg0 = GPPC_GETARG_TEXT(0);</span></span>
<span class="line"><span>    GppcText arg1 = GPPC_GETARG_TEXT(1);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // determine the size of the concatenated string and allocate</span></span>
<span class="line"><span>    // text memory of this size</span></span>
<span class="line"><span>    size_t arg0_len = GppcGetTextLength(arg0);</span></span>
<span class="line"><span>    size_t arg1_len = GppcGetTextLength(arg1);</span></span>
<span class="line"><span>    GppcText retstring = GppcAllocText(arg0_len + arg1_len);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // construct the concatenated return string</span></span>
<span class="line"><span>    memcpy(GppcGetTextPointer(retstring), GppcGetTextPointer(arg0), arg0_len);</span></span>
<span class="line"><span>    memcpy(GppcGetTextPointer(retstring) + arg0_len, GppcGetTextPointer(arg1), arg1_len);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    GPPC_RETURN_TEXT( retstring );</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>The code declares and implements the <code>concat_two_strings()</code> function. It uses GPPC data types, macros, and functions to get the function arguments, allocate memory for the concatenated string, copy the arguments into the new string, and return the result.</p></li><li><p>Save the file and exit the editor.</p></li><li><p>Open a file named <code>Makefile</code> in the editor of your choice. Copy/paste the following text into the file:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MODULE_big = gppc_concat</span></span>
<span class="line"><span>OBJS = gppc_concat.o</span></span>
<span class="line"><span></span></span>
<span class="line"><span>PG_CONFIG = pg_config</span></span>
<span class="line"><span>PGXS := $(shell $(PG_CONFIG) --pgxs)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>PG_CPPFLAGS = -I$(shell $(PG_CONFIG) --includedir)</span></span>
<span class="line"><span>SHLIB_LINK = -L$(shell $(PG_CONFIG) --libdir) -lgppc</span></span>
<span class="line"><span>include $(PGXS)</span></span></code></pre></div></li><li><p>Save the file and exit the editor.</p></li><li><p>Build a GPPC shared library for the <code>concat_two_strings()</code> function. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>gpadmin@gpcoordinator$ make all</span></span></code></pre></div><p>The <code>make</code> command generates a shared library file named <code>gppc_concat.so</code> in the current working directory.</p></li><li><p>Copy the shared library to your WarehousePG installation. You must have WarehousePG administrative privileges to copy the file. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>gpadmin@gpcoordinator$ cp gppc_concat.so /usr/local/greenplum-db/lib/postgresql/</span></span></code></pre></div></li><li><p>Copy the shared library to every host in your WarehousePG installation. For example, if <code>seghostfile</code> contains a list, one-host-per-line, of the segment hosts in your WarehousePG cluster:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>gpadmin@gpcoordinator$ gpsync -v -f seghostfile /usr/local/greenplum-db/lib/postgresql/gppc_concat.so =:/usr/local/greenplum-db/lib/postgresql/gppc_concat.so</span></span></code></pre></div></li><li><p>Open a <code>psql</code> session. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>gpadmin@gpcoordinator$ psql -d testdb</span></span></code></pre></div></li><li><p>Register the GPPC function named <code>concat_two_strings()</code> with WarehousePG, For example, to map the WarehousePG function <code>concat_with_gppc()</code> to the GPPC <code>concat_two_strings()</code> function:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>testdb=# CREATE FUNCTION concat_with_gppc(text, text) RETURNS text</span></span>
<span class="line"><span>  AS &#39;gppc_concat&#39;, &#39;concat_two_strings&#39;</span></span>
<span class="line"><span>LANGUAGE C STRICT;</span></span></code></pre></div></li><li><p>Run the <code>concat_with_gppc()</code> function. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>testdb=# SELECT concat_with_gppc( &#39;happy&#39;, &#39;monday&#39; );</span></span>
<span class="line"><span> concat_with_gppc</span></span>
<span class="line"><span>------------------</span></span>
<span class="line"><span> happymonday</span></span>
<span class="line"><span>(1 row)</span></span></code></pre></div></li></ol><h2 id="gppc-set-returning-function-example" tabindex="-1"><a id="topic_example_srf"></a>GPPC Set-Returning Function Example <a class="header-anchor" href="#gppc-set-returning-function-example" aria-label="Permalink to &quot;&lt;a id=&quot;topic_example_srf&quot;&gt;&lt;/a&gt;GPPC Set-Returning Function Example&quot;">​</a></h2><p>In this example, you develop, build, and deploy a GPPC shared library. You also create and run a <code>.sql</code> registration script for a GPPC function named <code>return_tbl()</code>. This function uses the GPPC API to take an input table with an integer and a text column, determine if the integer column is greater than 13, and returns a result table with the input integer column and a boolean column identifying whether or not the integer is greater than 13. <code>return_tbl()</code> utilizes GPPC API reporting and SRF functions and macros.</p><p>You will develop the GPPC function on your WarehousePG coordinator host. Deploying the GPPC shared library that you create in this example requires administrative access to your WarehousePG cluster.</p><p>Perform the following procedure to run the example:</p><ol><li><p>Log in to the WarehousePG coordinator host and set up your environment. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$ ssh gpadmin@&lt;gpcoordinator&gt;</span></span>
<span class="line"><span>gpadmin@gpcoordinator$ . /usr/local/greenplum-db/greenplum_path.sh</span></span></code></pre></div></li><li><p>Create a work directory and navigate to the new directory. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>gpadmin@gpcoordinator$ mkdir gppc_work</span></span>
<span class="line"><span>gpadmin@gpcoordinator$ cd gppc_work</span></span></code></pre></div></li><li><p>Prepare a source file for GPPC code by opening the file in the editor of your choice. For example, to open a file named <code>gppc_concat.c</code> using <code>vi</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>gpadmin@gpcoordinator$ vi gppc_rettbl.c</span></span></code></pre></div></li><li><p>Copy/paste the following code into the file:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#include &lt;stdio.h&gt;</span></span>
<span class="line"><span>#include &lt;string.h&gt;</span></span>
<span class="line"><span>#include &quot;gppc.h&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// initialize the logging level</span></span>
<span class="line"><span>GppcReportLevel level = GPPC_INFO;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// make the function SQL-invokable and declare the function</span></span>
<span class="line"><span>GPPC_FUNCTION_INFO(return_tbl);</span></span>
<span class="line"><span>GppcDatum return_tbl(GPPC_FUNCTION_ARGS);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>GppcDatum</span></span>
<span class="line"><span>return_tbl(GPPC_FUNCTION_ARGS)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    GppcFuncCallContext	fctx;</span></span>
<span class="line"><span>    GppcAnyTable	intbl;</span></span>
<span class="line"><span>    GppcHeapTuple	intuple;</span></span>
<span class="line"><span>    GppcTupleDesc	in_tupdesc, out_tupdesc;</span></span>
<span class="line"><span>    GppcBool  		resbool = false;</span></span>
<span class="line"><span>    GppcDatum  		result, boolres, values[2];</span></span>
<span class="line"><span>    bool		nulls[2] = {false, false};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // single input argument - the table</span></span>
<span class="line"><span>    intbl = GPPC_GETARG_ANYTABLE(0);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // set the function context</span></span>
<span class="line"><span>    if (GPPC_SRF_IS_FIRSTCALL()) {</span></span>
<span class="line"><span>        fctx = GPPC_SRF_FIRSTCALL_INIT();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    fctx = GPPC_SRF_PERCALL_SETUP();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // get the tuple descriptor for the input table</span></span>
<span class="line"><span>    in_tupdesc  = GppcAnyTableGetTupleDesc(intbl);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // retrieve the next tuple</span></span>
<span class="line"><span>    intuple = GppcAnyTableGetNextTuple(intbl);</span></span>
<span class="line"><span>    if( intuple == NULL ) {</span></span>
<span class="line"><span>      // no more tuples, conclude</span></span>
<span class="line"><span>      GPPC_SRF_RETURN_DONE(fctx);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // get the output tuple descriptor and verify that it is</span></span>
<span class="line"><span>    // defined as we expect</span></span>
<span class="line"><span>    out_tupdesc = GPPC_SRF_RESULT_DESC();</span></span>
<span class="line"><span>    if (GppcTupleDescNattrs(out_tupdesc) != 2                ||</span></span>
<span class="line"><span>        GppcTupleDescAttrType(out_tupdesc, 0) != GppcOidInt4 ||</span></span>
<span class="line"><span>        GppcTupleDescAttrType(out_tupdesc, 1) != GppcOidBool) {</span></span>
<span class="line"><span>        GppcReport(GPPC_ERROR, &quot;INVALID out_tupdesc tuple&quot;);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // log the attribute names of the output tuple descriptor</span></span>
<span class="line"><span>    GppcReport(level, &quot;output tuple descriptor attr0 name: %s&quot;, GppcTupleDescAttrName(out_tupdesc, 0));</span></span>
<span class="line"><span>    GppcReport(level, &quot;output tuple descriptor attr1 name: %s&quot;, GppcTupleDescAttrName(out_tupdesc, 1));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // retrieve the attribute values by name from the tuple</span></span>
<span class="line"><span>    bool text_isnull, int_isnull;</span></span>
<span class="line"><span>    GppcDatum intdat = GppcGetAttributeByName(intuple, &quot;id&quot;, &amp;int_isnull);</span></span>
<span class="line"><span>    GppcDatum textdat = GppcGetAttributeByName(intuple, &quot;msg&quot;, &amp;text_isnull);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // convert datum to specific type</span></span>
<span class="line"><span>    GppcInt4 intarg = GppcDatumGetInt4(intdat);</span></span>
<span class="line"><span>    GppcReport(level, &quot;id: %d&quot;, intarg);</span></span>
<span class="line"><span>    GppcReport(level, &quot;msg: %s&quot;, GppcTextGetCString(GppcDatumGetText(textdat)));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // perform the &gt;13 check on the integer</span></span>
<span class="line"><span>    if( !int_isnull &amp;&amp; (intarg &gt; 13) ) {</span></span>
<span class="line"><span>        // greater than 13?</span></span>
<span class="line"><span>        resbool = true;</span></span>
<span class="line"><span>        GppcReport(level, &quot;id is greater than 13!&quot;);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // values are datums; use integer from the tuple and</span></span>
<span class="line"><span>    // construct the datum for the boolean return</span></span>
<span class="line"><span>    values[0] = intdat;</span></span>
<span class="line"><span>    boolres = GppcBoolGetDatum(resbool);</span></span>
<span class="line"><span>    values[1] = boolres;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // build a datum tuple and return</span></span>
<span class="line"><span>    result = GppcBuildHeapTupleDatum(out_tupdesc, values, nulls);</span></span>
<span class="line"><span>    GPPC_SRF_RETURN_NEXT(fctx, result);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre></div><p>The code declares and implements the <code>return_tbl()</code> function. It uses GPPC data types, macros, and functions to fetch the function arguments, examine tuple descriptors, build the return tuple, and return the result. The function also uses the SRF macros to keep track of the tuple context across function calls.</p></li><li><p>Save the file and exit the editor.</p></li><li><p>Open a file named <code>Makefile</code> in the editor of your choice. Copy/paste the following text into the file:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MODULE_big = gppc_rettbl</span></span>
<span class="line"><span>OBJS = gppc_rettbl.o</span></span>
<span class="line"><span></span></span>
<span class="line"><span>PG_CONFIG = pg_config</span></span>
<span class="line"><span>PGXS := $(shell $(PG_CONFIG) --pgxs)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>PG_CPPFLAGS = -I$(shell $(PG_CONFIG) --includedir)</span></span>
<span class="line"><span>SHLIB_LINK = -L$(shell $(PG_CONFIG) --libdir) -lgppc</span></span>
<span class="line"><span>include $(PGXS)</span></span></code></pre></div></li><li><p>Save the file and exit the editor.</p></li><li><p>Build a GPPC shared library for the <code>return_tbl()</code> function. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>gpadmin@gpcoordinator$ make all</span></span></code></pre></div><p>The <code>make</code> command generates a shared library file named <code>gppc_rettbl.so</code> in the current working directory.</p></li><li><p>Copy the shared library to your WarehousePG installation. You must have WarehousePG administrative privileges to copy the file. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>gpadmin@gpcoordinator$ cp gppc_rettbl.so /usr/local/greenplum-db/lib/postgresql/</span></span></code></pre></div><p>This command copies the shared library to <code>$libdir</code></p></li><li><p>Copy the shared library to every host in your WarehousePG installation. For example, if <code>seghostfile</code> contains a list, one-host-per-line, of the segment hosts in your WarehousePG cluster:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>gpadmin@gpcoordinator$ gpsync -v -f seghostfile /usr/local/greenplum-db/lib/postgresql/gppc_rettbl.so =:/usr/local/greenplum-db/lib/postgresql/gppc_rettbl.so</span></span></code></pre></div></li><li><p>Create a <code>.sql</code> file to register the GPPC <code>return_tbl()</code> function. Open a file named <code>gppc_rettbl_reg.sql</code> in the editor of your choice.</p></li><li><p>Copy/paste the following text into the file:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE FUNCTION rettbl_gppc(anytable) RETURNS TABLE(id int4, thirteen bool)</span></span>
<span class="line"><span>  AS &#39;gppc_rettbl&#39;, &#39;return_tbl&#39;</span></span>
<span class="line"><span>LANGUAGE C STRICT;</span></span></code></pre></div></li><li><p>Register the GPPC function by running the script you just created. For example, to register the function in a database named <code>testdb</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>gpadmin@gpcoordinator$ psql -d testdb -f gppc_rettbl_reg.sql</span></span></code></pre></div></li><li><p>Open a <code>psql</code> session. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>gpadmin@gpcoordinator$ psql -d testdb</span></span></code></pre></div></li><li><p>Create a table with some test data. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE TABLE gppc_testtbl( id int, msg text );</span></span>
<span class="line"><span>INSERT INTO gppc_testtbl VALUES (1, &#39;f1&#39;);</span></span>
<span class="line"><span>INSERT INTO gppc_testtbl VALUES (7, &#39;f7&#39;);</span></span>
<span class="line"><span>INSERT INTO gppc_testtbl VALUES (10, &#39;f10&#39;);</span></span>
<span class="line"><span>INSERT INTO gppc_testtbl VALUES (13, &#39;f13&#39;);</span></span>
<span class="line"><span>INSERT INTO gppc_testtbl VALUES (15, &#39;f15&#39;);</span></span>
<span class="line"><span>INSERT INTO gppc_testtbl VALUES (17, &#39;f17&#39;);</span></span></code></pre></div></li><li><p>Run the <code>rettbl_gppc()</code> function. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>testdb=# SELECT * FROM rettbl_gppc(TABLE(SELECT * FROM gppc_testtbl));</span></span>
<span class="line"><span> id | thirteen </span></span>
<span class="line"><span>----+----------</span></span>
<span class="line"><span>  1 | f</span></span>
<span class="line"><span>  7 | f</span></span>
<span class="line"><span> 13 | f</span></span>
<span class="line"><span> 15 | t</span></span>
<span class="line"><span> 17 | t</span></span>
<span class="line"><span> 10 | f</span></span>
<span class="line"><span>(6 rows)</span></span></code></pre></div></li></ol>`,163)]))}const g=t(p,[["render",i]]);export{h as __pageData,g as default};
