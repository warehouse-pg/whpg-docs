import{_ as t,c as a,o,ag as i}from"./chunks/framework.Ds6Eueu6.js";const h=JSON.parse('{"title":"Schema Design","description":"","frontmatter":{},"headers":[],"relativePath":"docs/7x/best_practices/schema.md","filePath":"docs/7x/best_practices/schema.md"}'),n={name:"docs/7x/best_practices/schema.md"};function s(r,e,d,l,c,p){return o(),a("div",null,e[0]||(e[0]=[i(`<h1 id="schema-design" tabindex="-1">Schema Design <a class="header-anchor" href="#schema-design" aria-label="Permalink to &quot;Schema Design&quot;">​</a></h1><hr><p>Best practices for designing WarehousePG schemas.</p><p>WarehousePG is an analytical, shared-nothing database, which is much different than a highly normalized, transactional SMP database. WarehousePG performs best with a denormalized schema design suited for MPP analytical processing, a star or snowflake schema, with large centralized fact tables connected to multiple smaller dimension tables.</p><p><strong>Parent topic:</strong> <a href="./intro.html">WarehousePG Best Practices</a></p><h2 id="data-types" tabindex="-1"><a id="data_types"></a>Data Types <a class="header-anchor" href="#data-types" aria-label="Permalink to &quot;&lt;a id=&quot;data_types&quot;&gt;&lt;/a&gt;Data Types&quot;">​</a></h2><h3 id="use-types-consistently" tabindex="-1"><a id="use_types"></a>Use Types Consistently <a class="header-anchor" href="#use-types-consistently" aria-label="Permalink to &quot;&lt;a id=&quot;use_types&quot;&gt;&lt;/a&gt;Use Types Consistently&quot;">​</a></h3><p>Use the same data types for columns used in joins between tables. If the data types differ, WarehousePG must dynamically convert the data type of one of the columns so the data values can be compared correctly. With this in mind, you may need to increase the data type size to facilitate joins to other common objects.</p><h3 id="choose-data-types-that-use-the-least-space" tabindex="-1"><a id="choose_data"></a>Choose Data Types that Use the Least Space <a class="header-anchor" href="#choose-data-types-that-use-the-least-space" aria-label="Permalink to &quot;&lt;a id=&quot;choose_data&quot;&gt;&lt;/a&gt;Choose Data Types that Use the Least Space&quot;">​</a></h3><p>You can increase database capacity and improve query execution by choosing the most efficient data types to store your data.</p><p>Use <code>TEXT</code> or <code>VARCHAR</code> rather than <code>CHAR</code>. There are no performance differences among the character data types, but using <code>TEXT</code> or <code>VARCHAR</code> can decrease the storage space used.</p><p>Use the smallest numeric data type that will accommodate your data. Using <code>BIGINT</code> for data that fits in <code>INT</code> or <code>SMALLINT</code> wastes storage space.</p><h2 id="storage-model" tabindex="-1"><a id="storage_model"></a>Storage Model <a class="header-anchor" href="#storage-model" aria-label="Permalink to &quot;&lt;a id=&quot;storage_model&quot;&gt;&lt;/a&gt;Storage Model&quot;">​</a></h2><p>WarehousePG provides an array of storage options when creating tables. It is very important to know when to use heap storage versus append-optimized (AO) storage, and when to use row-oriented storage versus column-oriented storage. The correct selection of heap versus AO and row versus column is extremely important for large fact tables, but less important for small dimension tables.</p><p>The best practices for determining the storage model are:</p><ol><li>Design and build an insert-only model, truncating a daily partition before load.</li><li>For large partitioned fact tables, evaluate and use optimal storage options for different partitions. One storage option is not always right for the entire partitioned table. For example, some partitions can be row-oriented while others are column-oriented.</li><li>When using column-oriented storage, every column is a separate file on <em>every</em> WarehousePG segment. For tables with a large number of columns consider columnar storage for data often accessed (hot) and row-oriented storage for data not often accessed (cold).</li><li>Storage options should be set at the partition level.</li><li>Compress large tables to improve I/O performance and to make space in the cluster.</li></ol><h3 id="heap-storage-or-append-optimized-storage" tabindex="-1"><a id="heap_vs_ao"></a>Heap Storage or Append-Optimized Storage <a class="header-anchor" href="#heap-storage-or-append-optimized-storage" aria-label="Permalink to &quot;&lt;a id=&quot;heap_vs_ao&quot;&gt;&lt;/a&gt;Heap Storage or Append-Optimized Storage&quot;">​</a></h3><p>Heap storage is the default model, and is the model PostgreSQL uses for all database tables. Use heap storage for tables and partitions that will receive iterative <code>UPDATE</code>, <code>DELETE</code>, and singleton <code>INSERT</code> operations. Use heap storage for tables and partitions that will receive concurrent <code>UPDATE</code>, <code>DELETE</code>, and <code>INSERT</code> operations.</p><p>Use append-optimized storage for tables and partitions that are updated infrequently after the initial load and have subsequent inserts performed only in batch operations. Avoid performing singleton <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code> operations on append-optimized tables. Concurrent batch <code>INSERT</code> operations are acceptable, but <em>never</em> perform concurrent batch <code>UPDATE</code> or <code>DELETE</code> operations.</p><p>The append-optimized storage model is inappropriate for frequently updated tables, because space occupied by rows that are updated and deleted in append-optimized tables is not recovered and reused as efficiently as with heap tables. Append-optimized storage is intended for large tables that are loaded once, updated infrequently, and queried frequently for analytical query processing.</p><h3 id="row-or-column-orientation" tabindex="-1"><a id="row_vs_column"></a>Row or Column Orientation <a class="header-anchor" href="#row-or-column-orientation" aria-label="Permalink to &quot;&lt;a id=&quot;row_vs_column&quot;&gt;&lt;/a&gt;Row or Column Orientation&quot;">​</a></h3><p>Row orientation is the traditional way to store database tuples. The columns that comprise a row are stored on disk contiguously, so that an entire row can be read from disk in a single I/O.</p><p>Column orientation stores column values together on disk. A separate file is created for each column. If the table is partitioned, a separate file is created for each column and partition. When a query accesses only a small number of columns in a column-oriented table with many columns, the cost of I/O is substantially reduced compared to a row-oriented table; any columns not referenced do not have to be retrieved from disk.</p><p>Row-oriented storage is recommended for transactional type workloads with iterative transactions where updates are required and frequent inserts are performed. Use row-oriented storage when selects against the table are wide, where many columns of a single row are needed in a query. If the majority of columns in the <code>SELECT</code> list or <code>WHERE</code> clause is selected in queries, use row-oriented storage. Use row-oriented storage for general purpose or mixed workloads, as it offers the best combination of flexibility and performance.</p><p>Column-oriented storage is optimized for read operations but it is not optimized for write operations; column values for a row must be written to different places on disk. Column-oriented tables can offer optimal query performance on large tables with many columns where only a small subset of columns are accessed by the queries.</p><p>Another benefit of column orientation is that a collection of values of the same data type can be stored together in less space than a collection of mixed type values, so column-oriented tables use less disk space (and consequently less disk I/O) than row-oriented tables. Column-oriented tables also compress better than row-oriented tables.</p><p>Use column-oriented storage for data warehouse analytic workloads where selects are narrow or aggregations of data are computed over a small number of columns. Use column-oriented storage for tables that have single columns that are regularly updated without modifying other columns in the row. Reading a complete row in a wide columnar table requires more time than reading the same row from a row-oriented table. It is important to understand that each column is a separate physical file on <em>every</em> segment in WarehousePG.</p><h2 id="compression" tabindex="-1"><a id="topic_ebd_khx_z4"></a>Compression <a class="header-anchor" href="#compression" aria-label="Permalink to &quot;&lt;a id=&quot;topic_ebd_khx_z4&quot;&gt;&lt;/a&gt;Compression&quot;">​</a></h2><p>WarehousePG offers a variety of options to compress append-optimized tables and partitions. Use compression to improve I/O across the system by allowing more data to be read with each disk read operation. The best practice is to set the column compression settings at the partition level.</p><p>Note that new partitions added to a partitioned table do not automatically inherit compression defined at the table level; you must <em>specifically</em> define compression when you add new partitions.</p><p>Run-length encoding (RLE) compression provides the best levels of compression. Higher levels of compression usually result in more compact storage on disk, but require additional time and CPU cycles when compressing data on writes and uncompressing on reads. Sorting data, in combination with the various compression options, can achieve the highest level of compression.</p><p>Data compression should never be used for data that is stored on a compressed file system.</p><p>Test different compression types and ordering methods to determine the best compression for your specific data. For example, you might start zstd compression at level 8 or 9 and adjust for best results. RLE compression works best with files that contain repetitive data.</p><h2 id="distributions" tabindex="-1"><a id="distribution"></a>Distributions <a class="header-anchor" href="#distributions" aria-label="Permalink to &quot;&lt;a id=&quot;distribution&quot;&gt;&lt;/a&gt;Distributions&quot;">​</a></h2><p>An optimal distribution that results in evenly distributed data is the most important factor in WarehousePG. In an MPP shared nothing environment overall response time for a query is measured by the completion time for all segments. The system is only as fast as the slowest segment. If the data is skewed, segments with more data will take more time to complete, so every segment must have an approximately equal number of rows and perform approximately the same amount of processing. Poor performance and out of memory conditions may result if one segment has significantly more data to process than other segments.</p><p>Consider the following best practices when deciding on a distribution strategy:</p><ul><li>Explicitly define a column or random distribution for all tables. Do not use the default.</li><li>Ideally, use a single column that will distribute data across all segments evenly.</li><li>Do not distribute on columns that will be used in the <code>WHERE</code> clause of a query.</li><li>Do not distribute on dates or timestamps.</li><li>The distribution key column data should contain unique values or very high cardinality.</li><li>If a single column cannot achieve an even distribution, use a multi-column distribution key with a maximum of two columns. Additional column values do not typically yield a more even distribution and they require additional time in the hashing process.</li><li>If a two-column distribution key cannot achieve an even distribution of data, use a random distribution. Multi-column distribution keys in most cases require motion operations to join tables, so they offer no advantages over a random distribution.</li></ul><p>WarehousePG random distribution is not round-robin, so there is no guarantee of an equal number of records on each segment. Random distributions typically fall within a target range of less than ten percent variation.</p><p>Optimal distributions are critical when joining large tables together. To perform a join, matching rows must be located together on the same segment. If data is not distributed on the same join column, the rows needed from one of the tables are dynamically redistributed to the other segments. In some cases a broadcast motion, in which each segment sends its individual rows to all other segments, is performed rather than a redistribution motion, where each segment rehashes the data and sends the rows to the appropriate segments according to the hash key.</p><h3 id="local-co-located-joins" tabindex="-1"><a id="local"></a>Local (Co-located) Joins <a class="header-anchor" href="#local-co-located-joins" aria-label="Permalink to &quot;&lt;a id=&quot;local&quot;&gt;&lt;/a&gt;Local \\(Co-located\\) Joins&quot;">​</a></h3><p>Using a hash distribution that evenly distributes table rows across all segments and results in local joins can provide substantial performance gains. When joined rows are on the same segment, much of the processing can be accomplished within the segment instance. These are called <em>local</em> or <em>co-located</em> joins. Local joins minimize data movement; each segment operates independently of the other segments, without network traffic or communications between segments.</p><p>To achieve local joins for large tables commonly joined together, distribute the tables on the same column. Local joins require that both sides of a join be distributed on the same columns (and in the same order) <em>and</em> that all columns in the distribution clause are used when joining tables. The distribution columns must also be the same data type—although some values with different data types may appear to have the same representation, they are stored differently and hash to different values, so they are stored on different segments.</p><h3 id="data-skew" tabindex="-1"><a id="skew"></a>Data Skew <a class="header-anchor" href="#data-skew" aria-label="Permalink to &quot;&lt;a id=&quot;skew&quot;&gt;&lt;/a&gt;Data Skew&quot;">​</a></h3><p>Data skew is often the root cause of poor query performance and out of memory conditions. Skewed data affects scan (read) performance, but it also affects all other query execution operations, for instance, joins and group by operations.</p><p>It is very important to <em>validate</em> distributions to <em>ensure</em> that data is evenly distributed after the initial load. It is equally important to <em>continue</em> to validate distributions after incremental loads.</p><p>The following query shows the number of rows per segment as well as the variance from the minimum and maximum numbers of rows:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT &#39;Example Table&#39; AS &quot;Table Name&quot;, </span></span>
<span class="line"><span>    max(c) AS &quot;Max Seg Rows&quot;, min(c) AS &quot;Min Seg Rows&quot;, </span></span>
<span class="line"><span>    (max(c)-min(c))*100.0/max(c) AS &quot;Percentage Difference Between Max &amp; Min&quot; </span></span>
<span class="line"><span>FROM (SELECT count(*) c, gp_segment_id FROM facts GROUP BY 2) AS a;</span></span></code></pre></div><p>The <code>gp_toolkit</code> schema has two views that you can use to check for skew.</p><ul><li>The <code>gp_toolkit.gp_skew_coefficients</code> view shows data distribution skew by calculating the coefficient of variation (CV) for the data stored on each segment. The <code>skccoeff</code> column shows the coefficient of variation (CV), which is calculated as the standard deviation divided by the average. It takes into account both the average and variability around the average of a data series. The lower the value, the better. Higher values indicate greater data skew.</li><li>The <code>gp_toolkit.gp_skew_idle_fractions</code> view shows data distribution skew by calculating the percentage of the system that is idle during a table scan, which is an indicator of computational skew. The <code>siffraction</code> column shows the percentage of the system that is idle during a table scan. This is an indicator of uneven data distribution or query processing skew. For example, a value of 0.1 indicates 10% skew, a value of 0.5 indicates 50% skew, and so on. Tables that have more than10% skew should have their distribution policies evaluated.</li></ul><h3 id="processing-skew" tabindex="-1"><a id="process_skew"></a>Processing Skew <a class="header-anchor" href="#processing-skew" aria-label="Permalink to &quot;&lt;a id=&quot;process_skew&quot;&gt;&lt;/a&gt;Processing Skew&quot;">​</a></h3><p>Processing skew results when a disproportionate amount of data flows to, and is processed by, one or a few segments. It is often the culprit behind WarehousePG performance and stability issues. It can happen with operations such join, sort, aggregation, and various OLAP operations. Processing skew happens in flight while a query is running and is not as easy to detect as data skew, which is caused by uneven data distribution due to the wrong choice of distribution keys. Data skew is present at the table level, so it can be easily detected and avoided by choosing optimal distribution keys.</p><p>If single segments are failing, that is, not all segments on a host, it may be a processing skew issue. Identifying processing skew is currently a manual process. First look for spill files. If there is skew, but not enough to cause spill, it will not become a performance issue. If you determine skew exists, then find the query responsible for the skew.</p><p>The remedy for processing skew in almost all cases is to rewrite the query. Creating temporary tables can eliminate skew. Temporary tables can be randomly distributed to force a two-stage aggregation.</p><h2 id="partitioning" tabindex="-1"><a id="topic_fmc_lx1_3r"></a>Partitioning <a class="header-anchor" href="#partitioning" aria-label="Permalink to &quot;&lt;a id=&quot;topic_fmc_lx1_3r&quot;&gt;&lt;/a&gt;Partitioning&quot;">​</a></h2><p>A good partitioning strategy reduces the amount of data to be scanned by reading only the partitions needed to satisfy a query.</p><p>Each partition is a separate physical file or set of files (in the case of column-oriented tables) on <em>every</em> segment. Just as reading a complete row in a wide columnar table requires more time than reading the same row from a heap table, <em>reading all partitions in a partitioned table requires more time than reading the same data from a non-partitioned table</em>.</p><p>Following are partitioning best practices:</p><ul><li><p>Partition large tables only, do not partition small tables.</p></li><li><p>Use partitioning on large tables <em>only</em> when partition elimination (partition pruning) can be achieved based on query criteria and is accomplished by partitioning the table based on the query predicate. Whenever possible, use range partitioning instead of list partitioning.</p></li><li><p>The query planner can selectively scan partitioned tables only when the query contains a direct and simple restriction of the table using immutable operators, such as <code>=</code>, <code>&lt;</code> , <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, and <code>&lt;&gt;</code>.</p></li><li><p>Selective scanning recognizes <code>STABLE</code> and <code>IMMUTABLE</code> functions, but does not recognize <code>VOLATILE</code> functions within a query. For example, <code>WHERE</code> clauses such as</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>date &gt; CURRENT_DATE</span></span></code></pre></div><p>cause the query planner to selectively scan partitioned tables, but a <code>WHERE</code> clause such as</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>time &gt; TIMEOFDAY</span></span></code></pre></div><p>does not. It is important to validate that queries are selectively scanning partitioned tables (partitions are being eliminated) by examining the query <code>EXPLAIN</code> plan.</p></li><li><p>Do not use default partitions. The default partition is always scanned but, more importantly, in many environments they tend to overfill resulting in poor performance.</p></li><li><p><em>Never</em> partition and distribute tables on the same column.</p></li><li><p>Do not use multi-level partitioning. While sub-partitioning is supported, it is not recommended because typically sub-partitions contain little or no data. It is a myth that performance increases as the number of partitions or sub-partitions increases; the administrative overhead of maintaining many partitions and sub-partitions will outweigh any performance benefits. For performance, scalability and manageability, balance partition scan performance with the number of overall partitions.</p></li><li><p>Beware of using too many partitions with column-oriented storage.</p></li><li><p>Consider workload concurrency and the average number of partitions opened and scanned for all concurrent queries.</p></li></ul><h3 id="number-of-partition-and-columnar-storage-files" tabindex="-1"><a id="part_num"></a>Number of Partition and Columnar Storage Files <a class="header-anchor" href="#number-of-partition-and-columnar-storage-files" aria-label="Permalink to &quot;&lt;a id=&quot;part_num&quot;&gt;&lt;/a&gt;Number of Partition and Columnar Storage Files&quot;">​</a></h3><p>The only hard limit for the number of files WarehousePG supports is the operating system&#39;s open file limit. It is important, however, to consider the total number of files in the cluster, the number of files on every segment, and the total number of files on a host. In an MPP shared nothing environment, every node operates independently of other nodes. Each node is constrained by its disk, CPU, and memory. CPU and I/O constraints are not common with WarehousePG, but memory is often a limiting factor because the query execution model optimizes query performance in memory.</p><p>The optimal number of files per segment also varies based on the number of segments on the node, the size of the cluster, SQL access, concurrency, workload, and skew. There are generally six to eight segments per host, but large clusters should have fewer segments per host. When using partitioning and columnar storage it is important to balance the total number of files in the cluster, but it is <em>more</em> important to consider the number of files per segment and the total number of files on a node.</p><p>Example with 64GB Memory per Node</p><ul><li>Number of nodes: 16</li><li>Number of segments per node: 8</li><li>Average number of files per segment: 10,000</li></ul><p>The total number of files per node is <code>8*10,000 = 80,000</code> and the total number of files for the cluster is <code>8*16*10,000 = 1,280,000</code>. The number of files increases quickly as the number of partitions and the number of columns increase.</p><p>As a general best practice, limit the total number of files per node to under 100,000. As the previous example shows, the optimal number of files per segment and total number of files per node depends on the hardware configuration for the nodes (primarily memory), size of the cluster, SQL access, concurrency, workload and skew.</p><h2 id="indexes" tabindex="-1"><a id="indexes"></a>Indexes <a class="header-anchor" href="#indexes" aria-label="Permalink to &quot;&lt;a id=&quot;indexes&quot;&gt;&lt;/a&gt;Indexes&quot;">​</a></h2><p>Indexes are not generally needed in WarehousePG. Most analytical queries operate on large volumes of data, while indexes are intended for locating single rows or small numbers of rows of data. In WarehousePG, a sequential scan is an efficient method to read data as each segment contains an equal portion of the data and all segments work in parallel to read the data.</p><p>If adding an index does not produce performance gains, drop it. Verify that every index you create is used by the optimizer.</p><p>For queries with high selectivity, indexes may improve query performance. Create an index on a single column of a columnar table for drill through purposes for high cardinality columns that are required for highly selective queries.</p><p>Do not index columns that are frequently updated. Creating an index on a column that is frequently updated increases the number of writes required on updates.</p><p>Indexes on expressions should be used only if the expression is used frequently in queries.</p><p>An index with a predicate creates a partial index that can be used to select a small number of rows from large tables.</p><p>Avoid overlapping indexes. Indexes that have the same leading column are redundant.</p><p>Indexes can improve performance on compressed append-optimized tables for queries that return a targeted set of rows. For compressed data, an index access method means only the necessary pages are uncompressed.</p><p>Create selective B-tree indexes. Index selectivity is a ratio of the number of distinct values a column has divided by the number of rows in a table. For example, if a table has 1000 rows and a column has 800 distinct values, the selectivity of the index is 0.8, which is considered good.</p><p>As a general rule, drop indexes before loading data into a table. The load will run an order of magnitude faster than loading data into a table with indexes. After the load, re-create the indexes.</p><p>Bitmap indexes are suited for querying and not updating. Bitmap indexes perform best when the column has a low cardinality—100 to 100,000 distinct values. Do not use bitmap indexes for unique columns, very high, or very low cardinality data. Do not use bitmap indexes for transactional workloads.</p><p>If indexes are needed on partitioned tables, the index columns must be different than the partition columns. A benefit of indexing partitioned tables is that because the b-tree performance degrades exponentially as the size of the b-tree grows, creating indexes on partitioned tables creates smaller b-trees that perform better than with non-partitioned tables.</p><h2 id="column-sequence-and-byte-alignment" tabindex="-1"><a id="column_sequence"></a>Column Sequence and Byte Alignment <a class="header-anchor" href="#column-sequence-and-byte-alignment" aria-label="Permalink to &quot;&lt;a id=&quot;column_sequence&quot;&gt;&lt;/a&gt;Column Sequence and Byte Alignment&quot;">​</a></h2><p>For optimum performance lay out the columns of a table to achieve data type byte alignment. Lay out the columns in heap tables in the following order:</p><ol><li>Distribution and partition columns</li><li>Fixed numeric types</li><li>Variable data types</li></ol><p>Lay out the data types from largest to smallest, so that <code>BIGINT</code> and <code>TIMESTAMP</code> come before <code>INT</code> and <code>DATE</code>, and all of these types come before <code>TEXT</code>, <code>VARCHAR</code>, or <code>NUMERIC(x,y)</code>. For example, 8-byte types first (<code>BIGINT</code>, <code>TIMESTAMP</code>), 4-byte types next (<code>INT</code>, <code>DATE</code>), 2-byte types next (<code>SMALLINT</code>), and variable data type last (<code>VARCHAR</code>).</p><p>Instead of defining columns in this sequence:</p><p><code>Int</code>, <code>Bigint</code>, <code>Timestamp</code>, <code>Bigint</code>, <code>Timestamp</code>, <code>Int</code> (distribution key), <code>Date</code> (partition key), <code>Bigint</code>, <code>Smallint</code></p><p>define the columns in this sequence:</p><p><code>Int</code> (distribution key), <code>Date</code> (partition key), <code>Bigint</code>, <code>Bigint</code>, <code>Timestamp</code>, <code>Bigint</code>, <code>Timestamp</code>, <code>Int</code>, <code>Smallint</code></p>`,86)]))}const m=t(n,[["render",s]]);export{h as __pageData,m as default};
