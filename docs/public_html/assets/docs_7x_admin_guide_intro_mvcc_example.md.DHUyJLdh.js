import{_ as e,c as a,o,ag as d}from"./chunks/framework.Ds6Eueu6.js";const p=JSON.parse('{"title":"Example of Managing Transaction IDs","description":"","frontmatter":{},"headers":[],"relativePath":"docs/7x/admin_guide/intro/mvcc_example.md","filePath":"docs/7x/admin_guide/intro/mvcc_example.md"}'),s={name:"docs/7x/admin_guide/intro/mvcc_example.md"};function n(r,t,i,l,c,h){return o(),a("div",null,t[0]||(t[0]=[d('<h1 id="example-of-managing-transaction-ids" tabindex="-1">Example of Managing Transaction IDs <a class="header-anchor" href="#example-of-managing-transaction-ids" aria-label="Permalink to &quot;Example of Managing Transaction IDs&quot;">​</a></h1><hr><p>For WarehousePG, the transaction ID (XID) value an incrementing 32-bit (2<sup>32</sup>) value. The maximum unsigned 32-bit value is 4,294,967,295, or about four billion. The XID values restart at 3 after the maximum is reached. WarehousePG handles the limit of XID values with two features:</p><ul><li><p>Calculations on XID values using modulo-2<sup>32</sup> arithmetic that allow WarehousePG to reuse XID values. The modulo calculations determine the order of transactions, whether one transaction has occurred before or after another, based on the XID.</p><p>Every XID value can have up to two billion (2<sup>31</sup>) XID values that are considered previous transactions and two billion (231 -1 ) XID values that are considered newer transactions. The XID values can be considered a circular set of values with no endpoint similar to a 24 hour clock.</p><p>Using the WarehousePG modulo calculations, as long as two XIDs are within 2<sup>31</sup> transactions of each other, comparing them yields the correct result.</p></li><li><p>A frozen XID value that WarehousePG uses as the XID for current (visible) data rows. Setting a row&#39;s XID to the frozen XID performs two functions.</p><ul><li>When WarehousePG compares XIDs using the modulo calculations, the frozen XID is always smaller, earlier, when compared to any other XID. If a row&#39;s XID is not set to the frozen XID and 2<sup>31</sup> new transactions are run, the row appears to be run in the future based on the modulo calculation.</li><li>When the row&#39;s XID is set to the frozen XID, the original XID can be used, without duplicating the XID. This keeps the number of data rows on disk with assigned XIDs below (2<sup>32</sup>).</li></ul></li></ul><blockquote><p><strong>Note</strong> WarehousePG assigns XID values only to transactions that involve DDL or DML operations, which are typically the only transactions that require an XID.</p></blockquote><p><strong>Parent topic:</strong> <a href="./../intro/about_mvcc.html">About Concurrency Control in WarehousePG</a></p><h2 id="simple-mvcc-example" tabindex="-1"><a id="topic_zsw_yck_wv"></a>Simple MVCC Example <a class="header-anchor" href="#simple-mvcc-example" aria-label="Permalink to &quot;&lt;a id=&quot;topic_zsw_yck_wv&quot;&gt;&lt;/a&gt;Simple MVCC Example&quot;">​</a></h2><p>This is a simple example of the concepts of a MVCC database and how it manages data and transactions with transaction IDs. This simple MVCC database example consists of a single table:</p><ul><li>The table is a simple table with 2 columns and 4 rows of data.</li><li>The valid transaction ID (XID) values are from 0 up to 9, after 9 the XID restarts at 0.</li><li>The frozen XID is -2. This is different than the WarehousePG frozen XID.</li><li>Transactions are performed on a single row.</li><li>Only insert and update operations are performed.</li><li>All updated rows remain on disk, no operations are performed to remove obsolete rows.</li></ul><p>The example only updates the amount values. No other changes to the table.</p><p>The example shows these concepts.</p><ul><li><a href="#transactions">How transaction IDs are used to manage multiple, simultaneous transactions on a table.</a></li><li><a href="#managin_xid">How transaction IDs are managed with the frozen XID</a></li><li><a href="#table_itw_yck_wv">How the modulo calculation determines the order of transactions based on transaction IDs</a></li></ul><h3 id="managing-simultaneous-transactions" tabindex="-1"><a id="transactions"></a>Managing Simultaneous Transactions <a class="header-anchor" href="#managing-simultaneous-transactions" aria-label="Permalink to &quot;&lt;a id=&quot;transactions&quot;&gt;&lt;/a&gt;Managing Simultaneous Transactions&quot;">​</a></h3><p>This table is the initial table data on disk with no updates. The table contains two database columns for transaction IDs, <code>xmin</code> (transaction that created the row) and <code>xmax</code> (transaction that updated the row). In the table, changes are added, in order, to the bottom of the table.</p><table tabindex="0"><thead><tr><th>item</th><th>amount</th><th>xmin</th><th>xmax</th></tr></thead><tbody><tr><td>widget</td><td>100</td><td>0</td><td>null</td></tr><tr><td>giblet</td><td>200</td><td>1</td><td>null</td></tr><tr><td>sprocket</td><td>300</td><td>2</td><td>null</td></tr><tr><td>gizmo</td><td>400</td><td>3</td><td>null</td></tr></tbody></table><p>The next table shows the table data on disk after some updates on the amount values have been performed.</p><ul><li>xid = 4: <code>update tbl set amount=208 where item = &#39;widget&#39;</code></li><li>xid = 5: <code>update tbl set amount=133 where item = &#39;sprocket&#39;</code></li><li>xid = 6: <code>update tbl set amount=16 where item = &#39;widget&#39;</code></li></ul><p>In the next table, the bold items are the current rows for the table. The other rows are obsolete rows, table data that on disk but is no longer current. Using the xmax value, you can determine the current rows of the table by selecting the rows with <code>null</code> value. WarehousePG uses a slightly different method to determine current table rows.</p><table tabindex="0"><thead><tr><th>item</th><th>amount</th><th>xmin</th><th>xmax</th></tr></thead><tbody><tr><td>widget</td><td>100</td><td>0</td><td>4</td></tr><tr><td><strong>giblet</strong></td><td><strong>200</strong></td><td>1</td><td><strong>null</strong></td></tr><tr><td>sprocket</td><td>300</td><td>2</td><td>5</td></tr><tr><td><strong>gizmo</strong></td><td><strong>400</strong></td><td>3</td><td><strong>null</strong></td></tr><tr><td>widget</td><td>208</td><td>4</td><td>6</td></tr><tr><td><strong>sprocket</strong></td><td><strong>133</strong></td><td>5</td><td><strong>null</strong></td></tr><tr><td><strong>widget</strong></td><td><strong>16</strong></td><td>6</td><td><strong>null</strong></td></tr></tbody></table><p>The simple MVCC database works with XID values to determine the state of the table. For example, both these independent transactions run concurrently.</p><ul><li><code>UPDATE</code> command changes the sprocket amount value to <code>133</code> (xmin value <code>5</code>)</li><li><code>SELECT</code> command returns the value of sprocket.</li></ul><p>During the <code>UPDATE</code> transaction, the database returns the value of sprocket <code>300</code>, until the <code>UPDATE</code> transaction completes.</p><h3 id="managing-xids-and-the-frozen-xid" tabindex="-1"><a id="managin_xid"></a>Managing XIDs and the Frozen XID <a class="header-anchor" href="#managing-xids-and-the-frozen-xid" aria-label="Permalink to &quot;&lt;a id=&quot;managin_xid&quot;&gt;&lt;/a&gt;Managing XIDs and the Frozen XID&quot;">​</a></h3><p>For this simple example, the database is close to running out of available XID values. When WarehousePG is close to running out of available XID values, WarehousePG takes these actions.</p><ul><li><p>WarehousePG issues a warning stating that the database is running out of XID values.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>WARNING: database &quot;&lt;database_name&gt;&quot; must be vacuumed within &lt;number_of_transactions&gt; transactions</span></span></code></pre></div></li><li><p>Before the last XID is assigned, WarehousePG stops accepting transactions to prevent assigning an XID value twice and issues this message.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>FATAL: database is not accepting commands to avoid wraparound data loss in database &quot;&lt;database_name&gt;&quot;</span></span></code></pre></div></li></ul><p>To manage transaction IDs and table data that is stored on disk, WarehousePG provides the <code>VACUUM</code> command.</p><ul><li>A <code>VACUUM</code> operation frees up XID values so that a table can have more than 10 rows by changing the xmin values to the frozen XID.</li><li>A <code>VACUUM</code> operation manages obsolete or deleted table rows on disk. This database&#39;s <code>VACUUM</code> command changes the XID values <code>obsolete</code> to indicate obsolete rows. A WarehousePG <code>VACUUM</code> operation, without the <code>FULL</code> option, deletes the data opportunistically to remove rows on disk with minimal impact to performance and data availability.</li></ul><p>For the example table, a <code>VACUUM</code> operation has been performed on the table. The command updated table data on disk. This version of the <code>VACUUM</code> command performs slightly differently than the WarehousePG command, but the concepts are the same.</p><ul><li><p>For the widget and sprocket rows on disk that are no longer current, the rows have been marked as <code>obsolete</code>.</p></li><li><p>For the giblet and gizmo rows that are current, the xmin has been changed to the frozen XID.</p><p>The values are still current table values (the row&#39;s xmax value is <code>null</code>). However, the table row is visible to all transactions because the xmin value is frozen XID value that is older than all other XID values when modulo calculations are performed.</p></li></ul><p>After the <code>VACUUM</code> operation, the XID values <code>0</code>, <code>1</code>, <code>2</code>, and <code>3</code> available for use.</p><table tabindex="0"><thead><tr><th>item</th><th>amount</th><th>xmin</th><th>xmax</th></tr></thead><tbody><tr><td>widget</td><td>100</td><td>obsolete</td><td>obsolete</td></tr><tr><td><strong>giblet</strong></td><td><strong>200</strong></td><td>-2</td><td><strong>null</strong></td></tr><tr><td>sprocket</td><td>300</td><td>obsolete</td><td>obsolete</td></tr><tr><td><strong>gizmo</strong></td><td><strong>400</strong></td><td>-2</td><td><strong>null</strong></td></tr><tr><td>widget</td><td>208</td><td>4</td><td>6</td></tr><tr><td><strong>sprocket</strong></td><td><strong>133</strong></td><td>5</td><td><strong>null</strong></td></tr><tr><td><strong>widget</strong></td><td><strong>16</strong></td><td>6</td><td><strong>null</strong></td></tr></tbody></table><p>When a row disk with the xmin value of <code>-2</code> is updated, the xmax value is replaced with the transaction XID as usual, and the row on disk is considered obsolete after any concurrent transactions that access the row have completed.</p><p>Obsolete rows can be deleted from disk. For WarehousePG, the <code>VACUUM</code> command, with <code>FULL</code> option, does more extensive processing to reclaim disk space.</p><h3 id="example-of-xid-modulo-calculations" tabindex="-1"><a id="modulo_calc"></a>Example of XID Modulo Calculations <a class="header-anchor" href="#example-of-xid-modulo-calculations" aria-label="Permalink to &quot;&lt;a id=&quot;modulo_calc&quot;&gt;&lt;/a&gt;Example of XID Modulo Calculations&quot;">​</a></h3><p>The next table shows the table data on disk after more <code>UPDATE</code> transactions. The XID values have rolled over and start over at <code>0</code>. No additional <code>VACUUM</code> operations have been performed.</p><table tabindex="0"><thead><tr><th>item</th><th>amount</th><th>xmin</th><th>xmax</th></tr></thead><tbody><tr><td>widget</td><td>100</td><td>obsolete</td><td>obsolete</td></tr><tr><td>giblet</td><td>200</td><td>-2</td><td>1</td></tr><tr><td>sprocket</td><td>300</td><td>obsolete</td><td>obsolete</td></tr><tr><td>gizmo</td><td>400</td><td>-2</td><td>9</td></tr><tr><td>widget</td><td>208</td><td>4</td><td>6</td></tr><tr><td><strong>sprocket</strong></td><td><strong>133</strong></td><td>5</td><td><strong>null</strong></td></tr><tr><td>widget</td><td>16</td><td>6</td><td>7</td></tr><tr><td><strong>widget</strong></td><td><strong>222</strong></td><td>7</td><td><strong>null</strong></td></tr><tr><td>giblet</td><td>233</td><td>8</td><td>0</td></tr><tr><td><strong>gizmo</strong></td><td><strong>18</strong></td><td>9</td><td><strong>null</strong></td></tr><tr><td>giblet</td><td>88</td><td>0</td><td>1</td></tr><tr><td><strong>giblet</strong></td><td><strong>44</strong></td><td>1</td><td><strong>null</strong></td></tr></tbody></table><p>When performing the modulo calculations that compare XIDs, WarehousePG, considers the XIDs of the rows and the current range of available XIDs to determine if XID wrapping has occurred between row XIDs.</p><p>For the example table XID wrapping has occurred. The XID <code>1</code> for giblet row is a later transaction than the XID <code>7</code> for widget row based on the modulo calculations for XID values even though the XID value <code>7</code> is larger than <code>1</code>.</p><p>For the widget and sprocket rows, XID wrapping has not occurred and XID <code>7</code> is a later transaction than XID <code>5</code>.</p>',39)]))}const m=e(s,[["render",n]]);export{p as __pageData,m as default};
