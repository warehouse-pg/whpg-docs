import{_ as a,c as n,o as t,ag as s}from"./chunks/framework.Ds6Eueu6.js";const u=JSON.parse('{"title":"Writing a Foreign Data Wrapper","description":"","frontmatter":{},"headers":[],"relativePath":"docs/7x/admin_guide/external/devel-fdw.md","filePath":"docs/7x/admin_guide/external/devel-fdw.md"}'),o={name:"docs/7x/admin_guide/external/devel-fdw.md"};function r(i,e,l,p,d,c){return t(),n("div",null,e[0]||(e[0]=[s(`<h1 id="writing-a-foreign-data-wrapper" tabindex="-1">Writing a Foreign Data Wrapper <a class="header-anchor" href="#writing-a-foreign-data-wrapper" aria-label="Permalink to &quot;Writing a Foreign Data Wrapper&quot;">​</a></h1><hr><p>This chapter outlines how to write a new foreign-data wrapper.</p><p>All operations on a foreign table are handled through its foreign-data wrapper (FDW), a library that consists of a set of functions that the core WarehousePG server calls. The foreign-data wrapper is responsible for fetching data from the remote data store and returning it to the WarehousePG executor. If updating foreign-data is supported, the wrapper must handle that, too.</p><p>The foreign-data wrappers included in the WarehousePG open source github repository are good references when trying to write your own. You may want to examine the source code for the <a href="https://github.com/greenplum-db/gpdb/tree/main/contrib/file_fdw" target="_blank" rel="noreferrer">file_fdw</a> and <a href="https://github.com/greenplum-db/gpdb/tree/main/contrib/postgres_fdw" target="_blank" rel="noreferrer">postgres_fdw</a> modules in the <code>contrib/</code> directory. The <a href="./../../ref_guide/sql_commands/CREATE_FOREIGN_DATA_WRAPPER.html">CREATE FOREIGN DATA WRAPPER</a> reference page also provides some useful details.</p><blockquote><p><strong>Note</strong> The SQL standard specifies an interface for writing foreign-data wrappers. WarehousePG does not implement that API, however, because the effort to accommodate it into WarehousePG would be large, and the standard API hasn&#39;t yet gained wide adoption.</p></blockquote><p><strong>Parent topic:</strong> <a href="./../external/foreign.html">Accessing External Data with Foreign Tables</a></p><h2 id="requirements" tabindex="-1"><a id="reqs"></a>Requirements <a class="header-anchor" href="#requirements" aria-label="Permalink to &quot;&lt;a id=&quot;reqs&quot;&gt;&lt;/a&gt;Requirements&quot;">​</a></h2><p>When you develop with the WarehousePG foreign-data wrapper API:</p><ul><li>You must develop your code on a system with the same hardware and software architecture as that of your WarehousePG hosts.</li><li>Your code must be written in a compiled language such as C, using the version-1 interface. For details on C language calling conventions and dynamic loading, refer to <a href="https://www.postgresql.org/docs/12/xfunc-c.html" target="_blank" rel="noreferrer">C Language Functions</a> in the PostgreSQL documentation.</li><li>Symbol names in your object files must not conflict with each other nor with symbols defined in the WarehousePG server. You must rename your functions or variables if you get error messages to this effect.</li><li>Review the foreign table introduction described in <a href="./foreign.html">Accessing External Data with Foreign Tables</a>.</li></ul><h2 id="known-issues-and-limitations" tabindex="-1"><a id="limits"></a>Known Issues and Limitations <a class="header-anchor" href="#known-issues-and-limitations" aria-label="Permalink to &quot;&lt;a id=&quot;limits&quot;&gt;&lt;/a&gt;Known Issues and Limitations&quot;">​</a></h2><p>The WarehousePG 7 foreign-data wrapper implementation has the following known issues and limitations:</p><ul><li>WarehousePG supports all values of the <code>mpp_execute</code> option value for foreign table scans only. WarehousePG supports parallel write operations only when <code>mpp_execute</code> is set to <code>&#39;all segments&#39;</code>; WarehousePG initiates write operations through the coordinator for all other <code>mpp_execute</code> settings. See <a href="#topic5">WarehousePG Considerations</a>.</li></ul><h2 id="header-files" tabindex="-1"><a id="includes"></a>Header Files <a class="header-anchor" href="#header-files" aria-label="Permalink to &quot;&lt;a id=&quot;includes&quot;&gt;&lt;/a&gt;Header Files&quot;">​</a></h2><p>The WarehousePG header files that you may use when you develop a foreign-data wrapper are located in the <code>gpdb/src/include/</code> directory (when developing against the WarehousePG open source github repository), or installed in the <code>$GPHOME/include/postgresql/server/</code> directory (when developing against a WarehousePG installation):</p><ul><li><code>foreign/fdwapi.h</code> - FDW API structures and callback function signatures</li><li><code>foreign/foreign.h</code> - foreign-data wrapper helper structs and functions</li><li><code>catalog/pg_foreign_table.h</code> - foreign table definition</li><li><code>catalog/pg_foreign_server.h</code> - foreign server definition</li></ul><p>Your FDW code may also be dependent on header files and libraries required to access the remote data store.</p><h2 id="foreign-data-wrapper-functions" tabindex="-1"><a id="topic2"></a>Foreign Data Wrapper Functions <a class="header-anchor" href="#foreign-data-wrapper-functions" aria-label="Permalink to &quot;&lt;a id=&quot;topic2&quot;&gt;&lt;/a&gt;Foreign Data Wrapper Functions&quot;">​</a></h2><p>The developer of a foreign-data wrapper must implement an SQL-invokable <em>handler</em> function, and optionally an SQL-invokable <em>validator</em> function. Both functions must be written in a compiled language such as C, using the version-1 interface.</p><p>The <em>handler</em> function simply returns a struct of function pointers to callback functions that will be called by the WarehousePG planner, executor, and various maintenance commands. The <em>handler</em> function must be registered with WarehousePG as taking no arguments and returning the special pseudo-type <code>fdw_handler</code>. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE FUNCTION NEW_fdw_handler()</span></span>
<span class="line"><span>  RETURNS fdw_handler</span></span>
<span class="line"><span>  AS &#39;MODULE_PATHNAME&#39;</span></span>
<span class="line"><span>LANGUAGE C STRICT;</span></span></code></pre></div><p>Most of the effort in writing a foreign-data wrapper is in implementing the callback functions. The FDW API callback functions, plain C functions that are not visible or callable at the SQL level, are described in <a href="#topic3">Foreign Data Wrapper Callback Functions</a>.</p><p>The <em>validator</em> function is responsible for validating options provided in <code>CREATE</code> and <code>ALTER</code> commands for its foreign-data wrapper, as well as foreign servers, user mappings, and foreign tables using the wrapper. The <em>validator</em> function must be registered as taking two arguments, a text array containing the options to be validated, and an OID representing the type of object with which the options are associated. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE FUNCTION NEW_fdw_validator( text[], oid )</span></span>
<span class="line"><span>  RETURNS void</span></span>
<span class="line"><span>  AS &#39;MODULE_PATHNAME&#39;</span></span>
<span class="line"><span>LANGUAGE C STRICT;</span></span></code></pre></div><p>The OID argument reflects the type of the system catalog that the object would be stored in, one of <code>ForeignDataWrapperRelationId</code>, <code>ForeignServerRelationId</code>, <code>UserMappingRelationId</code>, or <code>ForeignTableRelationId</code>. If no <em>validator</em> function is supplied by a foreign data wrapper, WarehousePG does not check option validity at object creation time or object alteration time.</p><h2 id="foreign-data-wrapper-callback-functions" tabindex="-1"><a id="topic3"></a>Foreign Data Wrapper Callback Functions <a class="header-anchor" href="#foreign-data-wrapper-callback-functions" aria-label="Permalink to &quot;&lt;a id=&quot;topic3&quot;&gt;&lt;/a&gt;Foreign Data Wrapper Callback Functions&quot;">​</a></h2><p>The foreign-data wrapper API defines callback functions that WarehousePG invokes when scanning and updating foreign tables. The API also includes callbacks for performing explain and analyze operations on a foreign table.</p><p>The <em>handler</em> function of a foreign-data wrapper returns a <code>palloc</code>&#39;d <code>FdwRoutine</code> struct containing pointers to callback functions described below. The <code>FdwRoutine</code> struct is located in the <code>foreign/fdwapi.h</code> header file, and is defined as follows:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>/*</span></span>
<span class="line"><span> * FdwRoutine is the struct returned by a foreign-data wrapper&#39;s handler</span></span>
<span class="line"><span> * function.  It provides pointers to the callback functions needed by the</span></span>
<span class="line"><span> * planner and executor.</span></span>
<span class="line"><span> *</span></span>
<span class="line"><span> * More function pointers are likely to be added in the future.  Therefore</span></span>
<span class="line"><span> * it&#39;s recommended that the handler initialize the struct with</span></span>
<span class="line"><span> * makeNode(FdwRoutine) so that all fields are set to NULL.  This will</span></span>
<span class="line"><span> * ensure that no fields are accidentally left undefined.</span></span>
<span class="line"><span> */</span></span>
<span class="line"><span>typedef struct FdwRoutine</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>	NodeTag		type;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>	/* Functions for scanning foreign tables */</span></span>
<span class="line"><span>	GetForeignRelSize_function GetForeignRelSize;</span></span>
<span class="line"><span>	GetForeignPaths_function GetForeignPaths;</span></span>
<span class="line"><span>	GetForeignPlan_function GetForeignPlan;</span></span>
<span class="line"><span>	BeginForeignScan_function BeginForeignScan;</span></span>
<span class="line"><span>	IterateForeignScan_function IterateForeignScan;</span></span>
<span class="line"><span>	ReScanForeignScan_function ReScanForeignScan;</span></span>
<span class="line"><span>	EndForeignScan_function EndForeignScan;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>	/*</span></span>
<span class="line"><span>	 * Remaining functions are optional.  Set the pointer to NULL for any that</span></span>
<span class="line"><span>	 * are not provided.</span></span>
<span class="line"><span>	 */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>	/* Functions for updating foreign tables */</span></span>
<span class="line"><span>	AddForeignUpdateTargets_function AddForeignUpdateTargets;</span></span>
<span class="line"><span>	PlanForeignModify_function PlanForeignModify;</span></span>
<span class="line"><span>	BeginForeignModify_function BeginForeignModify;</span></span>
<span class="line"><span>	ExecForeignInsert_function ExecForeignInsert;</span></span>
<span class="line"><span>	ExecForeignUpdate_function ExecForeignUpdate;</span></span>
<span class="line"><span>	ExecForeignDelete_function ExecForeignDelete;</span></span>
<span class="line"><span>	EndForeignModify_function EndForeignModify;</span></span>
<span class="line"><span>	IsForeignRelUpdatable_function IsForeignRelUpdatable;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>	/* Support functions for EXPLAIN */</span></span>
<span class="line"><span>	ExplainForeignScan_function ExplainForeignScan;</span></span>
<span class="line"><span>	ExplainForeignModify_function ExplainForeignModify;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>	/* Support functions for ANALYZE */</span></span>
<span class="line"><span>	AnalyzeForeignTable_function AnalyzeForeignTable;</span></span>
<span class="line"><span>} FdwRoutine;</span></span></code></pre></div><p>You must implement the scan-related functions in your foreign-data wrapper; implementing the other callback functions is optional.</p><p>Scan-related callback functions include:</p><table class="table" id="topic3__in201681"><caption></caption><colgroup><col style="width:35.573122529644266%;"><col style="width:64.42687747035573%;"></colgroup><thead class="thead"><tr class="row"><th class="entry" id="topic3__in201681__entry__1">Callback Signature</th><th class="entry" id="topic3__in201681__entry__2">Description</th></tr></thead><tbody class="tbody"><tr class="row"><td class="entry" headers="topic3__in201681__entry__1"><pre class="pre codeblock"><code>void
GetForeignRelSize (PlannerInfo *root,
                   RelOptInfo *baserel,
                   Oid foreigntableid)</code></pre></td><td class="entry" headers="topic3__in201681__entry__2">Obtain relation size estimates for a foreign table. Called at the beginning of planning for a query on a foreign table.</td></tr><tr class="row"><td class="entry" headers="topic3__in201681__entry__1"><pre class="pre codeblock"><code>void
GetForeignPaths (PlannerInfo *root,
                 RelOptInfo *baserel,
                 Oid foreigntableid)</code></pre></td><td class="entry" headers="topic3__in201681__entry__2">Create possible access paths for a scan on a foreign table. Called during query planning. <div class="note note note_note"><span class="note__title">Note:</span> A WarehousePG Database-compatible FDW must call <code class="ph codeph">create_foreignscan_path()</code> in its <code class="ph codeph">GetForeignPaths()</code> callback function.</div></td></tr><tr class="row"><td class="entry" headers="topic3__in201681__entry__1"><pre class="pre codeblock"><code>ForeignScan *
GetForeignPlan (PlannerInfo *root,
                RelOptInfo *baserel,
                Oid foreigntableid,
                ForeignPath *best_path,
                List *tlist,
                List *scan_clauses)</code></pre></td><td class="entry" headers="topic3__in201681__entry__2">Create a <code class="ph codeph">ForeignScan</code> plan node from the selected foreign access path. Called at the end of query planning.</td></tr><tr class="row"><td class="entry" headers="topic3__in201681__entry__1"><pre class="pre codeblock"><code>void
BeginForeignScan (ForeignScanState *node,
                  int eflags)</code></pre></td><td class="entry" headers="topic3__in201681__entry__2">Begin running a foreign scan. Called during executor startup.</td></tr><tr class="row"><td class="entry" headers="topic3__in201681__entry__1"><pre class="pre codeblock"><code>TupleTableSlot *
IterateForeignScan (ForeignScanState *node)</code></pre></td><td class="entry" headers="topic3__in201681__entry__2">Fetch one row from the foreign source, returning it in a tuple table slot; return NULL if no more rows are available.</td></tr><tr class="row"><td class="entry" headers="topic3__in201681__entry__1"><pre class="pre codeblock"><code>void
ReScanForeignScan (ForeignScanState *node)</code></pre></td><td class="entry" headers="topic3__in201681__entry__2">Restart the scan from the beginning.</td></tr><tr class="row"><td class="entry" headers="topic3__in201681__entry__1"><pre class="pre codeblock"><code>void
EndForeignScan (ForeignScanState *node)</code></pre></td><td class="entry" headers="topic3__in201681__entry__2">End the scan and release resources.</td></tr></tbody></table><p>If a foreign data wrapper supports writable foreign tables, it should provide the update-related callback functions that are required by the capabilities of the FDW. Update-related callback functions include:</p><table class="table" id="topic3__in201681"><caption></caption><colgroup><col style="width:35.573122529644266%;"><col style="width:64.42687747035573%;"></colgroup><thead class="thead"><tr class="row"><th class="entry" id="topic3__in201681__entry__1">Callback Signature</th><th class="entry" id="topic3__in201681__entry__2">Description</th></tr></thead><tbody class="tbody"><tr class="row"><td class="entry" headers="topic3__in201681__entry__1"><pre class="pre codeblock"><code>void
AddForeignUpdateTargets (Query *parsetree,
                         RangeTblEntry *target_rte,
                         Relation target_relation)</code></pre></td><td class="entry" headers="topic3__in201681__entry__2">Add additional information in the foreign table that will be retrieved during an update or delete operation to identify the exact row on which to operate.</td></tr><tr class="row"><td class="entry" headers="topic3__in201681__entry__1"><pre class="pre codeblock"><code>List *
PlanForeignModify (PlannerInfo *root,
                   ModifyTable *plan,
                   Index resultRelation,
                   int subplan_index)</code></pre></td><td class="entry" headers="topic3__in201681__entry__2">Perform additional planning actions required for an insert, update, or delete operation on a foreign table, and return the information generated.</td></tr><tr class="row"><td class="entry" headers="topic3__in201681__entry__1"><pre class="pre codeblock"><code>void
BeginForeignModify (ModifyTableState *mtstate,
                    ResultRelInfo *rinfo,
                    List *fdw_private,
                    int subplan_index,
                    int eflags)</code></pre></td><td class="entry" headers="topic3__in201681__entry__2">Begin executing a modify operation on a foreign table. Called during executor startup.</td></tr><tr class="row"><td class="entry" headers="topic3__in201681__entry__1"><pre class="pre codeblock"><code>TupleTableSlot *
ExecForeignInsert (EState *estate,
                   ResultRelInfo *rinfo,
                   TupleTableSlot *slot,
                   TupleTableSlot *planSlot)</code></pre></td><td class="entry" headers="topic3__in201681__entry__2">Insert a single tuple into the foreign table. Return a slot containing the data that was actually inserted, or NULL if no row was inserted.</td></tr><tr class="row"><td class="entry" headers="topic3__in201681__entry__1"><pre class="pre codeblock"><code>TupleTableSlot *
ExecForeignUpdate (EState *estate,
                   ResultRelInfo *rinfo,
                   TupleTableSlot *slot,
                   TupleTableSlot *planSlot)</code></pre></td><td class="entry" headers="topic3__in201681__entry__2">Update a single tuple in the foreign table. Return a slot containing the row as it was actually updated, or NULL if no row was updated. </td></tr><tr class="row"><td class="entry" headers="topic3__in201681__entry__1"><pre class="pre codeblock"><code>TupleTableSlot *
ExecForeignDelete (EState *estate,
                   ResultRelInfo *rinfo,
                   TupleTableSlot *slot,
                   TupleTableSlot *planSlot)</code></pre></td><td class="entry" headers="topic3__in201681__entry__2">Delete a single tuple from the foreign table. Return a slot containing the row that was deleted, or NULL if no row was deleted.</td></tr><tr class="row"><td class="entry" headers="topic3__in201681__entry__1"><pre class="pre codeblock"><code>void
EndForeignModify (EState *estate,
                  ResultRelInfo *rinfo)</code></pre></td><td class="entry" headers="topic3__in201681__entry__2">End the update and release resources.</td></tr><tr class="row"><td class="entry" headers="topic3__in201681__entry__1"><pre class="pre codeblock"><code>int
IsForeignRelUpdatable (Relation rel)</code></pre></td><td class="entry" headers="topic3__in201681__entry__2">Report the update operations supported by the specified foreign table.</td></tr></tbody></table><p>Refer to <a href="https://www.postgresql.org/docs/12/fdw-callbacks.html" target="_blank" rel="noreferrer">Foreign Data Wrapper Callback Routines</a> in the PostgreSQL documentation for detailed information about the inputs and outputs of the FDW callback functions.</p><h2 id="foreign-data-wrapper-helper-functions" tabindex="-1"><a id="helper"></a>Foreign Data Wrapper Helper Functions <a class="header-anchor" href="#foreign-data-wrapper-helper-functions" aria-label="Permalink to &quot;&lt;a id=&quot;helper&quot;&gt;&lt;/a&gt;Foreign Data Wrapper Helper Functions&quot;">​</a></h2><p>The FDW API exports several helper functions from the WarehousePG core server so that authors of foreign-data wrappers have easy access to attributes of FDW-related objects, such as options provided when the user creates or alters the foreign-data wrapper, server, or foreign table. To use these helper functions, you must include <code>foreign.h</code> header file in your source file:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#include &quot;foreign/foreign.h&quot;</span></span></code></pre></div><p>The FDW API includes the helper functions listed in the table below. Refer to <a href="https://www.postgresql.org/docs/12/fdw-helpers.html" target="_blank" rel="noreferrer">Foreign Data Wrapper Helper Functions</a> in the PostgreSQL documentation for more information about these functions.</p><table class="table" id="helper__fdw_helper"><caption></caption><colgroup><col style="width:35.573122529644266%;"><col style="width:64.42687747035573%;"></colgroup><thead class="thead"><tr class="row"><th class="entry" id="helper__fdw_helper__entry__1">Helper Signature</th><th class="entry" id="helper__fdw_helper__entry__2">Description</th></tr></thead><tbody class="tbody"><tr class="row"><td class="entry" headers="helper__fdw_helper__entry__1"><pre class="pre codeblock"><code>ForeignDataWrapper *
GetForeignDataWrapper(Oid fdwid);</code></pre></td><td class="entry" headers="helper__fdw_helper__entry__2">Returns the <code class="ph codeph">ForeignDataWrapper</code> object for the foreign-data wrapper with the given OID.</td></tr><tr class="row"><td class="entry" headers="helper__fdw_helper__entry__1"><pre class="pre codeblock"><code>ForeignDataWrapper *
GetForeignDataWrapperByName(const char *name, bool missing_ok);</code></pre></td><td class="entry" headers="helper__fdw_helper__entry__2">Returns the <code class="ph codeph">ForeignDataWrapper</code> object for the foreign-data wrapper with the given name.</td></tr><tr class="row"><td class="entry" headers="helper__fdw_helper__entry__1"><pre class="pre codeblock"><code>ForeignServer *
GetForeignServer(Oid serverid);</code></pre></td><td class="entry" headers="helper__fdw_helper__entry__2">Returns the <code class="ph codeph">ForeignServer</code> object for the foreign server with the given OID.</td></tr><tr class="row"><td class="entry" headers="helper__fdw_helper__entry__1"><pre class="pre codeblock"><code>ForeignServer *
GetForeignServerByName(const char *name, bool missing_ok);</code></pre></td><td class="entry" headers="helper__fdw_helper__entry__2">Returns the <code class="ph codeph">ForeignServer</code> object for the foreign server with the given name.</td></tr><tr class="row"><td class="entry" headers="helper__fdw_helper__entry__1"><pre class="pre codeblock"><code>UserMapping *
GetUserMapping(Oid userid, Oid serverid);</code></pre></td><td class="entry" headers="helper__fdw_helper__entry__2">Returns the <code class="ph codeph">UserMapping</code> object for the user mapping of the given role on the given server.</td></tr><tr class="row"><td class="entry" headers="helper__fdw_helper__entry__1"><pre class="pre codeblock"><code>ForeignTable *
GetForeignTable(Oid relid);</code></pre></td><td class="entry" headers="helper__fdw_helper__entry__2">Returns the <code class="ph codeph">ForeignTable</code> object for the foreign table with the given OID.</td></tr><tr class="row"><td class="entry" headers="helper__fdw_helper__entry__1"><pre class="pre codeblock"><code>List *
GetForeignColumnOptions(Oid relid, AttrNumber attnum);</code></pre></td><td class="entry" headers="helper__fdw_helper__entry__2">Returns the per-column FDW options for the column with the given foreign table OID and attribute number.</td></tr></tbody></table><h2 id="warehousepg-considerations" tabindex="-1"><a id="topic5"></a>WarehousePG Considerations <a class="header-anchor" href="#warehousepg-considerations" aria-label="Permalink to &quot;&lt;a id=&quot;topic5&quot;&gt;&lt;/a&gt;WarehousePG Considerations&quot;">​</a></h2><p>A WarehousePG user can specify the <code>mpp_execute</code> option when they create or alter a foreign table, foreign server, or foreign data wrapper. A WarehousePG-compatible foreign-data wrapper examines the <code>mpp_execute</code> option value and uses it to determine where to request or send data - from the <code>coordinator</code> (the default), <code>any</code> (coordinator or any one segment), or <code>all segments</code> (parallel read/write).</p><p>WarehousePG supports all <code>mpp_execute</code> settings for a scan.</p><p>WarehousePG supports parallel write when <code>mpp_execute &#39;all segments&quot;</code> is set. For all other <code>mpp_execute</code> settings, WarehousePG executes write/update operations initiated by a foreign data wrapper on the WarehousePG coordinator node.</p><blockquote><p><strong>Note</strong> When <code>mpp_execute &#39;all segments&#39;</code> is set, WarehousePG creates the foreign table with a random partition policy. This enables a foreign data wrapper to write to a foreign table from all segments.</p></blockquote><p>The following scan code snippet probes the <code>mpp_execute</code> value associated with a foreign table:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ForeignTable *table = GetForeignTable(foreigntableid);</span></span>
<span class="line"><span>if (table-&gt;exec_location == FTEXECLOCATION_ALL_SEGMENTS)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    ...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>else if (table-&gt;exec_location == FTEXECLOCATION_ANY)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    ...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>else if (table-&gt;exec_location == FTEXECLOCATION_COORDINATOR)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    ...</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>If the foreign table was not created with an <code>mpp_execute</code> option setting, the <code>mpp_execute</code> setting of the foreign server, and then the foreign data wrapper, is probed and used. If none of the foreign-data-related objects has an <code>mpp_execute</code> setting, the default setting is <code>coordinator</code>.</p><p>If a foreign-data wrapper supports <code>mpp_execute &#39;all&#39;</code>, it will implement a policy that matches WarehousePG segments to data. So as not to duplicate data retrieved from the remote, the FDW on each segment must be able to establish which portion of the data is their responsibility. An FDW may use the segment identifier and the number of segments to help make this determination. The following code snippet demonstrates how a foreign-data wrapper may retrieve the segment number and total number of segments:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int segmentNumber = GpIdentity.segindex;</span></span>
<span class="line"><span>int totalNumberOfSegments = getgpsegmentCount();</span></span></code></pre></div><h2 id="building-a-foreign-data-wrapper-extension-with-pgxs" tabindex="-1"><a id="pkg"></a>Building a Foreign Data Wrapper Extension with PGXS <a class="header-anchor" href="#building-a-foreign-data-wrapper-extension-with-pgxs" aria-label="Permalink to &quot;&lt;a id=&quot;pkg&quot;&gt;&lt;/a&gt;Building a Foreign Data Wrapper Extension with PGXS&quot;">​</a></h2><p>You compile the foreign-data wrapper functions that you write with the FDW API into one or more shared libraries that the WarehousePG server loads on demand.</p><p>You can use the PostgreSQL build extension infrastructure (PGXS) to build the source code for your foreign-data wrapper against a WarehousePG installation. This framework automates common build rules for simple modules. If you have a more complicated use case, you will need to write your own build system.</p><p>To use the PGXS infrastructure to generate a shared library for your FDW, create a simple <code>Makefile</code> that sets PGXS-specific variables.</p><blockquote><p><strong>Note</strong> Refer to <a href="https://www.postgresql.org/docs/12/extend-pgxs.html" target="_blank" rel="noreferrer">Extension Building Infrastructure</a> in the PostgreSQL documentation for information about the <code>Makefile</code> variables supported by PGXS.</p></blockquote><p>For example, the following <code>Makefile</code> generates a shared library in the current working directory named <code>base_fdw.so</code> from two C source files, base_fdw_1.c and base_fdw_2.c:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MODULE_big = base_fdw</span></span>
<span class="line"><span>OBJS = base_fdw_1.o base_fdw_2.o</span></span>
<span class="line"><span></span></span>
<span class="line"><span>PG_CONFIG = pg_config</span></span>
<span class="line"><span>PGXS := $(shell $(PG_CONFIG) --pgxs)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>PG_CPPFLAGS = -I$(shell $(PG_CONFIG) --includedir)</span></span>
<span class="line"><span>SHLIB_LINK = -L$(shell $(PG_CONFIG) --libdir)</span></span>
<span class="line"><span>include $(PGXS)</span></span></code></pre></div><p>A description of the directives used in this <code>Makefile</code> follows:</p><ul><li><code>MODULE_big</code> - identifes the base name of the shared library generated by the <code>Makefile</code></li><li><code>PG_CPPFLAGS</code> - adds the WarehousePG installation <code>include/</code> directory to the compiler header file search path</li><li><code>SHLIB_LINK</code> adds the WarehousePG installation library directory (<code>$GPHOME/lib/</code>) to the linker search path</li><li>The <code>PG_CONFIG</code> and <code>PGXS</code> variable settings and the <code>include</code> statement are required and typically reside in the last three lines of the <code>Makefile</code>.</li></ul><p>To package the foreign-data wrapper as a WarehousePG extension, you create script (<code>newfdw--version.sql</code>) and control (<code>newfdw.control</code>) files that register the FDW <em>handler</em> and <em>validator</em> functions, create the foreign data wrapper, and identify the characteristics of the FDW shared library file.</p><blockquote><p><strong>Note</strong> <a href="https://www.postgresql.org/docs/12/extend-extensions.html" target="_blank" rel="noreferrer">Packaging Related Objects into an Extension</a> in the PostgreSQL documentation describes how to package an extension.</p></blockquote><p>Example foreign-data wrapper extension script file named <code>base_fdw--1.0.sql</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE FUNCTION base_fdw_handler()</span></span>
<span class="line"><span>  RETURNS fdw_handler</span></span>
<span class="line"><span>  AS &#39;MODULE_PATHNAME&#39;</span></span>
<span class="line"><span>LANGUAGE C STRICT;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>CREATE FUNCTION base_fdw_validator(text[], oid)</span></span>
<span class="line"><span>  RETURNS void</span></span>
<span class="line"><span>  AS &#39;MODULE_PATHNAME&#39;</span></span>
<span class="line"><span>LANGUAGE C STRICT;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>CREATE FOREIGN DATA WRAPPER base_fdw</span></span>
<span class="line"><span>  HANDLER base_fdw_handler</span></span>
<span class="line"><span>  VALIDATOR base_fdw_validator;</span></span></code></pre></div><p>Example FDW control file named <code>base_fdw.control</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># base_fdw FDW extension</span></span>
<span class="line"><span>comment = &#39;base foreign-data wrapper implementation; does not do much&#39;</span></span>
<span class="line"><span>default_version = &#39;1.0&#39;</span></span>
<span class="line"><span>module_pathname = &#39;$libdir/base_fdw&#39;</span></span>
<span class="line"><span>relocatable = true</span></span></code></pre></div><p>When you add the following directives to the <code>Makefile</code>, you identify the FDW extension control file base name (<code>EXTENSION</code>) and SQL script (<code>DATA</code>):</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>EXTENSION = base_fdw</span></span>
<span class="line"><span>DATA = base_fdw--1.0.sql</span></span></code></pre></div><p>Running <code>make install</code> with these directives in the <code>Makefile</code> copies the shared library and FDW SQL and control files into the specified or default locations in your WarehousePG installation (<code>$GPHOME</code>).</p><h2 id="deployment-considerations" tabindex="-1"><a id="deployconsider"></a>Deployment Considerations <a class="header-anchor" href="#deployment-considerations" aria-label="Permalink to &quot;&lt;a id=&quot;deployconsider&quot;&gt;&lt;/a&gt;Deployment Considerations&quot;">​</a></h2><p>You must package the FDW shared library and extension files in a form suitable for deployment in a WarehousePG cluster. When you construct and deploy the package, take into consideration the following:</p><ul><li>The FDW shared library must be installed to the same file system location on the coordinator host and on every segment host in the WarehousePG cluster. You specify this location in the <code>.control</code> file. This location is typically the <code>$GPHOME/lib/postgresql/</code> directory.</li><li>The FDW <code>.sql</code> and <code>.control</code> files must be installed to the <code>$GPHOME/share/postgresql/extension/</code> directory on the coordinator host and on every segment host in the WarehousePG cluster.</li><li>The <code>gpadmin</code> user must have permission to traverse the complete file system path to the FDW shared library file and extension files.</li></ul>`,71)]))}const g=a(o,[["render",r]]);export{u as __pageData,g as default};
