import{_ as t,c as a,o as i,ag as s}from"./chunks/framework.Ds6Eueu6.js";const h=JSON.parse('{"title":"Just-in-Time Compilation (JIT)","description":"","frontmatter":{},"headers":[],"relativePath":"docs/7x/admin_guide/query/topics/just-in-time.md","filePath":"docs/7x/admin_guide/query/topics/just-in-time.md"}'),n={name:"docs/7x/admin_guide/query/topics/just-in-time.md"};function o(r,e,p,l,c,d){return i(),a("div",null,e[0]||(e[0]=[s(`<h1 id="just-in-time-compilation-jit" tabindex="-1">Just-in-Time Compilation (JIT) <a class="header-anchor" href="#just-in-time-compilation-jit" aria-label="Permalink to &quot;Just-in-Time Compilation (JIT)&quot;">​</a></h1><hr><p>This topic provides an explanation of what Just-in-Time compilation is and how to configure it in WarehousePG.</p><p><strong>Parent topic:</strong> <a href="./../../query/topics/query.html">SQL: Querying Data</a></p><h2 id="what-is-jit-compilation" tabindex="-1"><a id="topic2"></a>What is JIT compilation? <a class="header-anchor" href="#what-is-jit-compilation" aria-label="Permalink to &quot;&lt;a id=&quot;topic2&quot;&gt;&lt;/a&gt;What is JIT compilation?&quot;">​</a></h2><p>Just-in-Time (JIT) compilation is the process of turning some form of interpreted program evaluation into a native program, and doing so at run time. For example, instead of using general-purpose code that can evaluate arbitrary SQL expressiones to evaluate a particular SQL predicate like <code>WHERE a.col=3</code>, it is possible to generate a function that is specific to that expression and can be natively executed by the CPU, resulting in faster execution.</p><p>WarehousePG uses LLVM for JIT compilation and it is enabled with all RPM distributions of WarehousePG. If you build WarehousePG from source, you must include the <code>--with-llvm</code> build option to include JIT compilation support.</p><p>It is possible to use JIT with both GPORCA and Postgres-based planner. Since GPORCA and Postgres-based planner use different algorithms and the values for the calculated costs are different, you must tune the JIT thresholds according to your usage. See <a href="#topic3">When to JIT?</a> for more information.</p><h3 id="jit-accelerated-operations" tabindex="-1"><a id="topic21"></a>JIT accelerated operations <a class="header-anchor" href="#jit-accelerated-operations" aria-label="Permalink to &quot;&lt;a id=&quot;topic21&quot;&gt;&lt;/a&gt;JIT accelerated operations&quot;">​</a></h3><p>Currently WarehousePG&#39;s JIT implementation supports for accelerating expression evaluation and tuple deforming.</p><p>Expression evaluation is used to evaluate <code>WHERE</code> clauses, target lists, aggregates and projections. It can be accelerated by generating code specific to each case.</p><p>Tuple deforming is the process of transforming an on-disk tuple into its in-memory representation. It can be accelerated by creating a function specific to the table layout and the number of columns to be extracted.</p><h3 id="in-line-compilation-inlining" tabindex="-1"><a id="topic22"></a>In-line compilation (inlining) <a class="header-anchor" href="#in-line-compilation-inlining" aria-label="Permalink to &quot;&lt;a id=&quot;topic22&quot;&gt;&lt;/a&gt;In-line compilation (inlining)&quot;">​</a></h3><p>WarehousePG is very extensible and allows new data types, functions, operators and other database objects to be defined. In fact, the built-in objects are implemented using nearly the same mechanisms. This extensibility implies some overhead, for example due to function calls. To reduce that overhead, JIT can use in-line compilation to fit the bodies of small functions into the expressions using them. That allows a significant percentage of the overhead to be optimized away.</p><h3 id="optimization" tabindex="-1"><a id="topic23"></a>Optimization <a class="header-anchor" href="#optimization" aria-label="Permalink to &quot;&lt;a id=&quot;topic23&quot;&gt;&lt;/a&gt;Optimization&quot;">​</a></h3><p>LLVM has support for optimizing generated code. Some of the optimizations are cheap enough to be performed whenever JIT is used, while others are only beneficial for longer-running queries. See the <a href="https://llvm.org/docs/Passes.html#transform-passes" target="_blank" rel="noreferrer">LLVM Documentation</a> for more details about optimizations.</p><h2 id="when-to-jit" tabindex="-1"><a id="topic3"></a>When to JIT? <a class="header-anchor" href="#when-to-jit" aria-label="Permalink to &quot;&lt;a id=&quot;topic3&quot;&gt;&lt;/a&gt;When to JIT?&quot;">​</a></h2><p>JIT compilation is beneficial primarily for long-running CPU-bound queries. Frequently these are analytical queries. For short queries the added overhead of performing JIT compilation will often be higher than the time it can save.</p><blockquote><p><strong>Note</strong> In order to use JIT, you must first install the LLVM libraries in your system by running the command <code>yum install llvm-libs</code>.</p></blockquote><p>The internal workflow of JIT can be divided into three different stages:</p><ol><li><p>Planner Stage</p><p>This stage takes place in the WarehousePG coordinator. The planner generates the plan tree of a query and its estimated cost. By default, WarehousePG uses GPORCA to generate a query plan. Otherwise it uses Postgres-based planner as a fallback method.</p><p>The planner decides to trigger JIT compilation if:</p><ul><li>The server configuration parameter <a href="./../../../ref_guide/config_params/guc-list.html#jit">jit</a> is <code>true</code>.</li><li>The estimated cost of the query is higher than the value of the configuration parameter <a href="./../../../ref_guide/config_params/guc-list.html#optimizer_jit_above_cost">optimizer_jit_above_cost</a> (or <a href="./../../../ref_guide/config_params/guc-list.html#jit_above_cost">jit_above_cost</a> for Postgres-based planner).</li></ul><p>If the parameter <a href="./../../../ref_guide/config_params/guc-list.html#jit_expressions">jit_expressions</a> is enabled, the planner suggests to the executor to compile the expressions in JIT space. Additionally, the planner must make other decisions; if the estimated cost is more than the setting of <a href="./../../../ref_guide/config_params/guc-list.html#optimizer_jit_inline_above_cost">optimizer_jit_inline_above_cost</a> (or <a href="./../../../ref_guide/config_params/guc-list.html#jit_inline_above_cost">jit_inline_above_cost</a> for Postgres-based planner), the planner compiles short functions and operators used in the query using in-line compilation. If the estimated cost is more than the setting of <a href="./../../../ref_guide/config_params/guc-list.html#optimizer_jit_optimize_above_cost">optimizer_jit_optimize_above_cost</a> (or <a href="./../../../ref_guide/config_params/guc-list.html#jit_optimize_above_cost">jit_optimize_above_cost</a> for Postgres-based planner), it applies expensive optimizations to improve the generated code. If the configuration parameter <a href="./../../../ref_guide/config_params/guc-list.html#jit_tuple_deforming">jit_tuple_deforming</a> is enabled, it generates a custom function to deform the target table. Each of these options increases the JIT compilation overhead, but can reduce query execution time considerably.</p><p>Verify the values of these configuration parameters for both GPORCA and Postgres-based planner, as the meaning of cost is different. When using GPORCA, WarehousePG may sometimes fall back to Postgres-based planner for some operations. Note that setting the JIT cost parameters to ‘0’ forces all queries to be JIT-compiled and, as a result, slows down queries. Setting them to a negative value will disable the feature the parameter provides.</p><p>When the plan is ready, the planner provides the plan trees and JIT flags to the executor.</p></li><li><p>Executor Initialization Stage</p><p>This stage takes place in the WarehousePG segments. WarehousePG creates the expression evaluation steps. If JIT is used, it re-writes the steps as functions in the JIT space. The decisions made at plan time determine whether or not JIT compilation is adviced to be triggered in execution stage, along with the JIT strategy to apply if it is triggered. However, it is at execution time when WarehousePG makes the decision of using JIT if the configuration parameter <code>jit</code> is enabled and the JIT libraries are loaded successfully. The executor may ignore the cached decisions if <code>jit</code> or <code>jit_expression</code> has been changed to <code>false</code> between planner and execution stages or if it encounters an error.</p><p>Additionally, the executor checks the following developer configuration parameters:</p><ul><li><a href="./../../../ref_guide/config_params/guc-list.html#jit_provider">jit_provider</a> : Specifies the name of the JIT provider library to be used.</li><li><a href="./../../../ref_guide/config_params/guc-list.html#jit_dump_bitcode">jit_dump_bitcode</a>: Writes the generated LLVM IR out to the file system, inside <a href="./../../../install_guide/create_data_dirs.html">data_directory</a>.</li><li><a href="./../../../ref_guide/config_params/guc-list.html#jit_profiling_support">jit_profiling_support</a>: If LLVM has the required functionality, emits the data needed to allow <code>perf</code> command to profile functions generated by JIT.</li><li><a href="./../../../ref_guide/config_params/guc-list.html#jit_debugging_support">jit_debugging_support</a>: If LLVM has the required functionality, registers generated functions with GDB.</li></ul></li><li><p>Executor Run Stage</p><p>This stage also occurs in the WarehousePG segments which execute the steps provided by the initialization stage. The functions in JIT space are combined as a whole before the first call.</p></li></ol><p>The JIT workflow can also handle executor fault tolerance: if JIT fails to load on the segments, the execution mode fails back to non-JIT.</p><h2 id="examples" tabindex="-1"><a id="topic4"></a>Examples <a class="header-anchor" href="#examples" aria-label="Permalink to &quot;&lt;a id=&quot;topic4&quot;&gt;&lt;/a&gt;Examples&quot;">​</a></h2><p>In the examples below, the configuration parameter <code>optimizer_jit_above_cost</code>/<code>jit_above_cost</code> was modified so it would trigger JIT compilation. Note that the use of JIT might add more overhead than the potential savings. JIT was used, but inlining and expensive optimization were not. If <code>optimizer_jit_inline_above_cost</code>/<code>jit_inline_above_cost</code> or <code>optimizer_jit_optimize_above_cost</code>/<code>jit_optimize_above_cost</code> were also lowered, they could be triggered.</p><p>You may enable the configuration parameter <a href="./../../../ref_guide/config_params/guc-list.html#gp_explain_jit">gp_explain_jit</a> to display summarized JIT information from all query executions when running the <code>EXPLAIN</code> command. You must turn it off when running regression tests.</p><p>Note that the output from <code>EXPLAIN</code> provides information on JIT such as the slice average timing spent in JIT, what segment the maximum vector comes from, or how many JIT functions are created and total time spent in JIT tasks. This information can be helpful when tuning JIT or debugging a timing problem. Run <code>EXPLAIN (ANALYZE, VERBOSE)</code> to view this information.</p><p>With GPORCA:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>EXPLAIN (ANALYZE) SELECT * FROM jit_explain_output LIMIT 10;</span></span>
<span class="line"><span>QUERY PLAN</span></span>
<span class="line"><span>Limit  (cost=0.00..431.00 rows=1 width=4) (actual time=1.103..1.107 rows=10 loops=1)</span></span>
<span class="line"><span>  -&gt;  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..431.00 rows=1 width=4) (actual time=0.013..0.014 rows=10 loops=1)</span></span>
<span class="line"><span>        -&gt;  Seq Scan on jit_explain_output  (cost=0.00..431.00 rows=1 width=4) (actual time=0.025..0.030 rows=38 loops=1)</span></span>
<span class="line"><span>Optimizer: GPORCA</span></span>
<span class="line"><span>Planning Time: 5.824 ms</span></span>
<span class="line"><span>  (slice0)    Executor memory: 37K bytes.</span></span>
<span class="line"><span>  (slice1)    Executor memory: 36K bytes avg x 3 workers, 36K bytes max (seg0).</span></span>
<span class="line"><span>Memory used:  128000kB</span></span>
<span class="line"><span>JIT:</span></span>
<span class="line"><span>  Options: Inlining false, Optimization false, Expressions true, Deforming true.</span></span>
<span class="line"><span>  (slice0): Functions: 2.00. Timing: 1.137 ms total.</span></span>
<span class="line"><span>Execution Time: 1.597 ms</span></span>
<span class="line"><span>(12 rows)</span></span></code></pre></div><p>With Postgres-based planner:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>EXPLAIN (ANALYZE) SELECT * FROM jit_explain_output LIMIT 10;</span></span>
<span class="line"><span>QUERY PLAN</span></span>
<span class="line"><span>Limit  (cost=35.50..35.67 rows=10 width=4) (actual time=13.199..13.310 rows=10 loops=1)</span></span>
<span class="line"><span>  -&gt;  Gather Motion 3:1  (slice1; segments: 3)  (cost=35.50..36.01 rows=30 width=4) (actual time=11.848..11.890 rows=10 loops=1)</span></span>
<span class="line"><span>        -&gt;  Limit  (cost=35.50..35.61 rows=10 width=4) (actual time=0.861..0.971 rows=10 loops=1)</span></span>
<span class="line"><span>              -&gt;  Seq Scan on jit_explain_output  (cost=0.00..355.00 rows=32100 width=4) (actual time=0.029..0.070 rows=10 loops=1)</span></span>
<span class="line"><span>Optimizer: Postgres-based planner</span></span>
<span class="line"><span>Planning Time: 0.158 ms</span></span>
<span class="line"><span>  (slice0)    Executor memory: 37K bytes.</span></span>
<span class="line"><span>  (slice1)    Executor memory: 36K bytes avg x 3 workers, 36K bytes max (seg0).</span></span>
<span class="line"><span>Memory used:  128000kB</span></span>
<span class="line"><span>JIT:</span></span>
<span class="line"><span>  Options: Inlining false, Optimization false, Expressions true, Deforming true.</span></span>
<span class="line"><span>  (slice0): Functions: 2.00. Timing: 1.381 ms total.</span></span>
<span class="line"><span>  (slice1): Functions: 1.00 avg x 3 workers, 1.00 max (seg0). Timing: 0.830 ms avg x 3 workers, 0.854 ms max (seg1).</span></span>
<span class="line"><span>Execution Time: 24.023 ms</span></span>
<span class="line"><span>(14 rows)</span></span></code></pre></div>`,30)]))}const m=t(n,[["render",o]]);export{h as __pageData,m as default};
