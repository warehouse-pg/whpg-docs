import{_ as s,c as e,o as n,ag as t}from"./chunks/framework.Ds6Eueu6.js";const u=JSON.parse('{"title":"PL/pgSQL Language","description":"","frontmatter":{},"headers":[],"relativePath":"docs/7x/analytics/pl_sql.md","filePath":"docs/7x/analytics/pl_sql.md"}'),i={name:"docs/7x/analytics/pl_sql.md"};function p(l,a,o,c,r,d){return n(),e("div",null,a[0]||(a[0]=[t(`<h1 id="pl-pgsql-language" tabindex="-1">PL/pgSQL Language <a class="header-anchor" href="#pl-pgsql-language" aria-label="Permalink to &quot;PL/pgSQL Language&quot;">​</a></h1><hr><p>This section contains an overview of the WarehousePG PL/pgSQL language.</p><ul><li><a href="#topic2">About WarehousePG PL/pgSQL</a></li><li><a href="#topic67">PL/pgSQL Plan Caching</a></li><li><a href="#topic6">PL/pgSQL Examples</a></li><li><a href="#about_procs">About Developing PL/pgSQL Procedures</a></li><li><a href="#topic10">References</a></li></ul><h2 id="about-warehousepg-pl-pgsql" tabindex="-1"><a id="topic2"></a>About WarehousePG PL/pgSQL <a class="header-anchor" href="#about-warehousepg-pl-pgsql" aria-label="Permalink to &quot;&lt;a id=&quot;topic2&quot;&gt;&lt;/a&gt;About WarehousePG PL/pgSQL&quot;">​</a></h2><p>WarehousePG PL/pgSQL is a loadable procedural language that is installed and registered by default with WarehousePG. You can create user-defined functions and procedures using SQL statements, functions, and operators.</p><p>With PL/pgSQL you can group a block of computation and a series of SQL queries inside the database server, thus having the power of a procedural language and the ease of use of SQL. Also, with PL/pgSQL you can use all the data types, operators and functions of WarehousePG SQL.</p><p>The PL/pgSQL language is a subset of Oracle PL/SQL. WarehousePG PL/pgSQL is based on Postgres PL/pgSQL. The Postgres PL/pgSQL documentation is at <a href="https://www.postgresql.org/docs/12/plpgsql.html" target="_blank" rel="noreferrer">https://www.postgresql.org/docs/12/plpgsql.html</a></p><p>When using PL/pgSQL functions, function attributes affect how WarehousePG creates query plans. You can specify the attribute <code>IMMUTABLE</code>, <code>STABLE</code>, or <code>VOLATILE</code> as part of the <code>LANGUAGE</code> clause to classify the type of function. For information about the creating functions and function attributes, see the <a href="./../ref_guide/sql_commands/CREATE_FUNCTION.html">CREATE FUNCTION</a> command in the <em>WarehousePG Reference Guide</em>.</p><p>You can run PL/SQL code blocks as anonymous code blocks. See the <a href="./../ref_guide/sql_commands/DO.html">DO</a> command in the <em>WarehousePG Reference Guide</em>.</p><h3 id="warehousepg-sql-limitations" tabindex="-1"><a id="topic3"></a>WarehousePG SQL Limitations <a class="header-anchor" href="#warehousepg-sql-limitations" aria-label="Permalink to &quot;&lt;a id=&quot;topic3&quot;&gt;&lt;/a&gt;WarehousePG SQL Limitations&quot;">​</a></h3><p>When using WarehousePG PL/pgSQL, limitations include</p><ul><li>Triggers are not supported</li><li>Cursors are forward moving only (not scrollable)</li><li>Updatable cursors (<code>UPDATE...WHERE CURRENT OF</code> and <code>DELETE...WHERE CURRENT OF</code>) are not supported.</li><li>Parallel retrieve cursors (<code>DECLARE...PARALLEL RETRIEVE</code>) are not supported.</li></ul><p>For information about WarehousePG SQL conformance, see <a href="./../ref_guide/feature_summary.html">Summary of WarehousePG Features</a> in the <em>WarehousePG Reference Guide</em>.</p><h3 id="the-pl-pgsql-language" tabindex="-1"><a id="topic4"></a>The PL/pgSQL Language <a class="header-anchor" href="#the-pl-pgsql-language" aria-label="Permalink to &quot;&lt;a id=&quot;topic4&quot;&gt;&lt;/a&gt;The PL/pgSQL Language&quot;">​</a></h3><p>PL/pgSQL is a block-structured language. The complete text of a function definition must be a block. A block is defined as:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[ &lt;label&gt; ]</span></span>
<span class="line"><span>[ DECLARE</span></span>
<span class="line"><span>   declarations ]</span></span>
<span class="line"><span>BEGIN</span></span>
<span class="line"><span>   statements</span></span>
<span class="line"><span>END [ &lt;label&gt; ];</span></span></code></pre></div><p>Each declaration and each statement within a block is terminated by a semicolon (;). A block that appears within another block must have a semicolon after <code>END</code>, as shown in the previous block. The <code>END</code> that concludes a function body does not require a semicolon.</p><p>A label is required only if you want to identify the block for use in an <code>EXIT</code> statement, or to qualify the names of variables declared in the block. If you provide a label after <code>END</code>, it must match the label at the block&#39;s beginning.</p><blockquote><p><strong>Important</strong> Do not confuse the use of the <code>BEGIN</code> and <code>END</code> keywords for grouping statements in PL/pgSQL with the database commands for transaction control. The PL/pgSQL <code>BEGIN</code> and <code>END</code> keywords are only for grouping; they do not start or end a transaction. Functions are always run within a transaction established by an outer query — they cannot start or commit that transaction, since there would be no context for them to run in. However, a PL/pgSQL block that contains an <code>EXCEPTION</code> clause effectively forms a subtransaction that can be rolled back without affecting the outer transaction. For more about the <code>EXCEPTION</code> clause, see the PostgreSQL documentation on trapping errors at <a href="https://www.postgresql.org/docs/12/plpgsql-control-structures.html#PLPGSQL-ERROR-TRAPPING" target="_blank" rel="noreferrer">https://www.postgresql.org/docs/12/plpgsql-control-structures.html#PLPGSQL-ERROR-TRAPPING</a>.</p></blockquote><p>Keywords are case-insensitive. Identifiers are implicitly converted to lowercase unless double-quoted, just as they are in ordinary SQL commands.</p><p>Comments work the same way in PL/pgSQL code as in ordinary SQL:</p><ul><li><p>A double dash (--) starts a comment that extends to the end of the line.</p></li><li><p>A /* starts a block comment that extends to the matching occurrence of */.</p><p>Block comments nest.</p></li></ul><p>Any statement in the statement section of a block can be a subblock. Subblocks can be used for logical grouping or to localize variables to a small group of statements.</p><p>Variables declared in a subblock mask any similarly-named variables of outer blocks for the duration of the subblock. You can access the outer variables if you qualify their names with their block&#39;s label. For example this function declares a variable named <code>quantity</code> several times:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE FUNCTION testfunc() RETURNS integer AS $$</span></span>
<span class="line"><span>&lt;&lt; outerblock &gt;&gt;</span></span>
<span class="line"><span>DECLARE</span></span>
<span class="line"><span>   quantity integer := 30;</span></span>
<span class="line"><span>BEGIN</span></span>
<span class="line"><span>   RAISE NOTICE &#39;Quantity here is %&#39;, quantity;  -- Prints 30</span></span>
<span class="line"><span>   quantity := 50;</span></span>
<span class="line"><span>   --</span></span>
<span class="line"><span>   -- Create a subblock</span></span>
<span class="line"><span>   --</span></span>
<span class="line"><span>   DECLARE</span></span>
<span class="line"><span>      quantity integer := 80;</span></span>
<span class="line"><span>   BEGIN</span></span>
<span class="line"><span>      RAISE NOTICE &#39;Quantity here is %&#39;, quantity;  -- Prints 80</span></span>
<span class="line"><span>      RAISE NOTICE &#39;Outer quantity here is %&#39;, outerblock.quantity;  -- Prints 50</span></span>
<span class="line"><span>   END;</span></span>
<span class="line"><span>   RAISE NOTICE &#39;Quantity here is %&#39;, quantity;  -- Prints 50</span></span>
<span class="line"><span>   RETURN quantity;</span></span>
<span class="line"><span>END;</span></span>
<span class="line"><span>$$ LANGUAGE plpgsql;</span></span></code></pre></div><h4 id="running-sql-commands" tabindex="-1"><a id="topic5"></a>Running SQL Commands <a class="header-anchor" href="#running-sql-commands" aria-label="Permalink to &quot;&lt;a id=&quot;topic5&quot;&gt;&lt;/a&gt;Running SQL Commands&quot;">​</a></h4><p>You can run SQL commands with PL/pgSQL statements such as <code>EXECUTE</code>, <code>PERFORM</code>, and <code>SELECT ... INTO</code>. For information about the PL/pgSQL statements, see <a href="https://www.postgresql.org/docs/12/plpgsql-statements.html" target="_blank" rel="noreferrer">https://www.postgresql.org/docs/12/plpgsql-statements.html</a>.</p><blockquote><p><strong>Note</strong> The PL/pgSQL statement <code>SELECT INTO</code> is not supported in the <code>EXECUTE</code> statement.</p></blockquote><h2 id="pl-pgsql-plan-caching" tabindex="-1"><a id="topic67"></a>PL/pgSQL Plan Caching <a class="header-anchor" href="#pl-pgsql-plan-caching" aria-label="Permalink to &quot;&lt;a id=&quot;topic67&quot;&gt;&lt;/a&gt;PL/pgSQL Plan Caching&quot;">​</a></h2><p>A PL/pgSQL function’s volatility classification has implications on how WarehousePG caches plans that reference the function. Refer to <a href="./../admin_guide/query/topics/functions-operators.html#topic281">Function Volatility and Plan Caching</a> in the <em>WarehousePG Administrator Guide</em> for information on plan caching considerations for WarehousePG function volatility categories.</p><p>When a PL/pgSQL function runs for the first time in a database session, the PL/pgSQL interpreter parses the function’s SQL expressions and commands. The interpreter creates a prepared execution plan as each expression and SQL command is first run in the function. The PL/pgSQL interpreter reuses the execution plan for a specific expression and SQL command for the life of the database connection. While this reuse substantially reduces the total amount of time required to parse and generate plans, errors in a specific expression or command cannot be detected until run time when that part of the function is run.</p><p>WarehousePG will automatically re-plan a saved query plan if there is any schema change to any relation used in the query, or if any user-defined function used in the query is redefined. This makes the re-use of a prepared plan transparent in most cases.</p><p>The SQL commands that you use in a PL/pgSQL function must refer to the same tables and columns on every execution. You cannot use a parameter as the name of a table or a column in an SQL command.</p><p>PL/pgSQL caches a separate query plan for each combination of actual argument types in which you invoke a polymorphic function to ensure that data type differences do not cause unexpected failures.</p><p>Refer to the PostgreSQL <a href="https://www.postgresql.org/docs/12/plpgsql-implementation.html#PLPGSQL-PLAN-CACHING" target="_blank" rel="noreferrer">Plan Caching</a> documentation for a detailed discussion of plan caching considerations in the PL/pgSQL language.</p><h2 id="pl-pgsql-examples" tabindex="-1"><a id="topic6"></a>PL/pgSQL Examples <a class="header-anchor" href="#pl-pgsql-examples" aria-label="Permalink to &quot;&lt;a id=&quot;topic6&quot;&gt;&lt;/a&gt;PL/pgSQL Examples&quot;">​</a></h2><p>The following are examples of PL/pgSQL user-defined functions.</p><h3 id="example-aliases-for-function-parameters" tabindex="-1"><a id="topic7"></a>Example: Aliases for Function Parameters <a class="header-anchor" href="#example-aliases-for-function-parameters" aria-label="Permalink to &quot;&lt;a id=&quot;topic7&quot;&gt;&lt;/a&gt;Example: Aliases for Function Parameters&quot;">​</a></h3><p>Parameters passed to functions are named with identifiers such as <code>$1</code>, <code>$2</code>. Optionally, aliases can be declared for <code>$n</code> parameter names for increased readability. Either the alias or the numeric identifier can then be used to refer to the parameter value.</p><p>There are two ways to create an alias. The preferred way is to give a name to the parameter in the <code>CREATE FUNCTION</code> command, for example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE FUNCTION sales_tax(subtotal real) RETURNS real AS $$</span></span>
<span class="line"><span>BEGIN</span></span>
<span class="line"><span>   RETURN subtotal * 0.06;</span></span>
<span class="line"><span>END;</span></span>
<span class="line"><span>$$ LANGUAGE plpgsql;</span></span></code></pre></div><p>You can also explicitly declare an alias, using the declaration syntax:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>name ALIAS FOR $n;</span></span></code></pre></div><p>This example, creates the same function with the <code>DECLARE</code> syntax.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE FUNCTION sales_tax(real) RETURNS real AS $$</span></span>
<span class="line"><span>DECLARE</span></span>
<span class="line"><span>    subtotal ALIAS FOR $1;</span></span>
<span class="line"><span>BEGIN</span></span>
<span class="line"><span>    RETURN subtotal * 0.06;</span></span>
<span class="line"><span>END;</span></span>
<span class="line"><span>$$ LANGUAGE plpgsql;</span></span></code></pre></div><h3 id="example-using-the-data-type-of-a-table-column" tabindex="-1"><a id="topic8"></a>Example: Using the Data Type of a Table Column <a class="header-anchor" href="#example-using-the-data-type-of-a-table-column" aria-label="Permalink to &quot;&lt;a id=&quot;topic8&quot;&gt;&lt;/a&gt;Example: Using the Data Type of a Table Column&quot;">​</a></h3><p>When declaring a variable, you can use the <code>%TYPE</code> construct to specify the data type of a variable or table column. This is the syntax for declaring a variable whose type is the data type of a table column:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>name table.column_name%TYPE;</span></span></code></pre></div><p>You can use the <code>%TYPE</code> construct to declare variables that will hold database values. For example, suppose you have a column named <code>user_id</code> in your <code>users</code> table. To declare a variable named <code>my_userid</code> with the same data type as the <code>users.user_id</code> column:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>my_userid users.user_id%TYPE;</span></span></code></pre></div><p><code>%TYPE</code> is particularly valuable in polymorphic functions, since the data types needed for internal variables may change from one call to the next. Appropriate variables can be created by applying <code>%TYPE</code> to the function’s arguments or result placeholders.</p><h3 id="example-composite-type-based-on-a-table-row" tabindex="-1"><a id="topic_mbj_vfg_mjb"></a>Example: Composite Type Based on a Table Row <a class="header-anchor" href="#example-composite-type-based-on-a-table-row" aria-label="Permalink to &quot;&lt;a id=&quot;topic_mbj_vfg_mjb&quot;&gt;&lt;/a&gt;Example: Composite Type Based on a Table Row&quot;">​</a></h3><p>A variable of a composite type is called a row variable. The following syntax declares a composite variable based on table row:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>name table_name%ROWTYPE;</span></span></code></pre></div><p>Such a row variable can hold a whole row of a <code>SELECT</code> or <code>FOR</code> query result, so long as that query&#39;s column set matches the declared type of the variable. The individual fields of the row value are accessed using the usual dot notation, for example <code>rowvar.column</code>.</p><p>Parameters to a function can be composite types (complete table rows). In that case, the corresponding identifier <code>$n</code> will be a row variable, and fields can be selected from it, for <code>example $1.user_id</code>.</p><p>Only the user-defined columns of a table row are accessible in a row-type variable, not the OID or other system columns. The fields of the row type inherit the table’s field size or precision for data types such as <code>char(n)</code>.</p><p>The next example function uses a row variable composite type. Before creating the function, create the table that is used by the function with this command.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE TABLE table1 (</span></span>
<span class="line"><span>  f1 text,</span></span>
<span class="line"><span>  f2 numeric,</span></span>
<span class="line"><span>  f3 integer</span></span>
<span class="line"><span>) distributed by (f1);</span></span></code></pre></div><p>This <code>INSERT</code> command adds data to the table.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>INSERT INTO table1 values </span></span>
<span class="line"><span> (&#39;test1&#39;, 14.1, 3),</span></span>
<span class="line"><span> (&#39;test2&#39;, 52.5, 2),</span></span>
<span class="line"><span> (&#39;test3&#39;, 32.22, 6),</span></span>
<span class="line"><span> (&#39;test4&#39;, 12.1, 4) ;</span></span></code></pre></div><p>This function uses a column <code>%TYPE</code> variable and <code>%ROWTYPE</code> composite variable based on <code>table1</code>.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE OR REPLACE FUNCTION t1_calc( name text) RETURNS integer </span></span>
<span class="line"><span>AS $$ </span></span>
<span class="line"><span>DECLARE</span></span>
<span class="line"><span>    t1_row   table1%ROWTYPE;</span></span>
<span class="line"><span>    calc_int table1.f3%TYPE;</span></span>
<span class="line"><span>BEGIN</span></span>
<span class="line"><span>    SELECT * INTO t1_row FROM table1 WHERE table1.f1 = $1 ;</span></span>
<span class="line"><span>    calc_int = (t1_row.f2 * t1_row.f3)::integer ;</span></span>
<span class="line"><span>    RETURN calc_int ;</span></span>
<span class="line"><span>END;</span></span>
<span class="line"><span>$$ LANGUAGE plpgsql VOLATILE;</span></span></code></pre></div><blockquote><p><strong>Note</strong> The previous function is classified as a <code>VOLATILE</code> function because function values could change within a single table scan.</p></blockquote><p>The following <code>SELECT</code> command uses the function.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>select t1_calc( &#39;test1&#39; );</span></span></code></pre></div><blockquote><p><strong>Note</strong> The example PL/pgSQL function uses <code>SELECT</code> with the <code>INTO</code> clause. It is different from the SQL command <code>SELECT INTO</code>. If you want to create a table from a <code>SELECT</code> result inside a PL/pgSQL function, use the SQL command <code>CREATE TABLE AS</code>.</p></blockquote><h3 id="example-using-a-variable-number-of-arguments" tabindex="-1"><a id="topic_lsh_5n5_2z1717"></a>Example: Using a Variable Number of Arguments <a class="header-anchor" href="#example-using-a-variable-number-of-arguments" aria-label="Permalink to &quot;&lt;a id=&quot;topic_lsh_5n5_2z1717&quot;&gt;&lt;/a&gt;Example: Using a Variable Number of Arguments&quot;">​</a></h3><p>You can declare a PL/pgSQL function to accept variable numbers of arguments, as long as all of the optional arguments are of the same data type. You must mark the last argument of the function as <code>VARIADIC</code> and declare the argument using an array type. You can refer to a function that includes <code>VARIADIC</code> arguments as a variadic function.</p><p>For example, this variadic function returns the minimum value of a variable array of numerics:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE FUNCTION mleast (VARIADIC numeric[]) </span></span>
<span class="line"><span>    RETURNS numeric AS $$</span></span>
<span class="line"><span>  DECLARE minval numeric;</span></span>
<span class="line"><span>  BEGIN</span></span>
<span class="line"><span>    SELECT min($1[i]) FROM generate_subscripts( $1, 1) g(i) INTO minval;</span></span>
<span class="line"><span>    RETURN minval;</span></span>
<span class="line"><span>END;</span></span>
<span class="line"><span>$$ LANGUAGE plpgsql;</span></span>
<span class="line"><span>CREATE FUNCTION</span></span>
<span class="line"><span></span></span>
<span class="line"><span>SELECT mleast(10, -1, 5, 4.4);</span></span>
<span class="line"><span> mleast</span></span>
<span class="line"><span>--------</span></span>
<span class="line"><span>     -1</span></span>
<span class="line"><span>(1 row)</span></span></code></pre></div><p>Effectively, all of the actual arguments at or beyond the <code>VARIADIC</code> position are gathered up into a one-dimensional array.</p><p>You can pass an already-constructed array into a variadic function. This is particularly useful when you want to pass arrays between variadic functions. Specify <code>VARIADIC</code> in the function call as follows:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT mleast(VARIADIC ARRAY[10, -1, 5, 4.4]);</span></span></code></pre></div><p>This prevents PL/pgSQL from expanding the function&#39;s variadic parameter into its element type.</p><h3 id="example-using-default-argument-values" tabindex="-1"><a id="topic_lsh_5n5_2z1313"></a>Example: Using Default Argument Values <a class="header-anchor" href="#example-using-default-argument-values" aria-label="Permalink to &quot;&lt;a id=&quot;topic_lsh_5n5_2z1313&quot;&gt;&lt;/a&gt;Example: Using Default Argument Values&quot;">​</a></h3><p>You can declare PL/pgSQL functions with default values for some or all input arguments. The default values are inserted whenever the function is called with fewer than the declared number of arguments. Because arguments can only be omitted from the end of the actual argument list, you must provide default values for all arguments after an argument defined with a default value.</p><p>For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE FUNCTION use_default_args(a int, b int DEFAULT 2, c int DEFAULT 3)</span></span>
<span class="line"><span>    RETURNS int AS $$</span></span>
<span class="line"><span>DECLARE</span></span>
<span class="line"><span>    sum int;</span></span>
<span class="line"><span>BEGIN</span></span>
<span class="line"><span>    sum := $1 + $2 + $3;</span></span>
<span class="line"><span>    RETURN sum;</span></span>
<span class="line"><span>END;</span></span>
<span class="line"><span>$$ LANGUAGE plpgsql;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>SELECT use_default_args(10, 20, 30);</span></span>
<span class="line"><span> use_default_args</span></span>
<span class="line"><span>------------------</span></span>
<span class="line"><span>               60</span></span>
<span class="line"><span>(1 row)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>SELECT use_default_args(10, 20);</span></span>
<span class="line"><span> use_default_args</span></span>
<span class="line"><span>------------------</span></span>
<span class="line"><span>               33</span></span>
<span class="line"><span>(1 row)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>SELECT use_default_args(10);</span></span>
<span class="line"><span> use_default_args</span></span>
<span class="line"><span>------------------</span></span>
<span class="line"><span>               15</span></span>
<span class="line"><span>(1 row)</span></span></code></pre></div><p>You can also use the <code>=</code> sign in place of the keyword <code>DEFAULT</code>.</p><h3 id="example-using-polymorphic-data-types" tabindex="-1"><a id="topic_lsh_5n5_2z"></a>Example: Using Polymorphic Data Types <a class="header-anchor" href="#example-using-polymorphic-data-types" aria-label="Permalink to &quot;&lt;a id=&quot;topic_lsh_5n5_2z&quot;&gt;&lt;/a&gt;Example: Using Polymorphic Data Types&quot;">​</a></h3><p>PL/pgSQL supports the polymorphic <em>anyelement</em>, <em>anyarray</em>, <em>anyenum</em>, and <em>anynonarray</em> types. Using these types, you can create a single PL/pgSQL function that operates on multiple data types. Refer to <a href="./../ref_guide/data_types.html">WarehousePG Data Types</a> for additional information on polymorphic type support in WarehousePG.</p><p>A special parameter named <code>$0</code> is created when the return type of a PL/pgSQL function is declared as a polymorphic type. The data type of <code>$0</code> identifies the return type of the function as deduced from the actual input types.</p><p>In this example, you create a polymorphic function that returns the sum of two values:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE FUNCTION add_two_values(v1 anyelement,v2 anyelement)</span></span>
<span class="line"><span>    RETURNS anyelement AS $$ </span></span>
<span class="line"><span>DECLARE </span></span>
<span class="line"><span>    sum ALIAS FOR $0;</span></span>
<span class="line"><span>BEGIN</span></span>
<span class="line"><span>    sum := v1 + v2;</span></span>
<span class="line"><span>    RETURN sum;</span></span>
<span class="line"><span>END;</span></span>
<span class="line"><span>$$ LANGUAGE plpgsql;</span></span></code></pre></div><p>Run <code>add_two_values()</code> providing integer input values:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT add_two_values(1, 2);</span></span>
<span class="line"><span> add_two_values</span></span>
<span class="line"><span>----------------</span></span>
<span class="line"><span>              3</span></span>
<span class="line"><span>(1 row)</span></span></code></pre></div><p>The return type of <code>add_two_values()</code> is integer, the type of the input arguments. Now execute <code>add_two_values()</code> providing float input values:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT add_two_values (1.1, 2.2);</span></span>
<span class="line"><span> add_two_values</span></span>
<span class="line"><span>----------------</span></span>
<span class="line"><span>            3.3</span></span>
<span class="line"><span>(1 row)</span></span></code></pre></div><p>The return type of <code>add_two_values()</code> in this case is float.</p><p>You can also specify <code>VARIADIC</code> arguments in polymorphic functions.</p><h3 id="example-anonymous-block" tabindex="-1"><a id="topic_isw_3sx_cz"></a>Example: Anonymous Block <a class="header-anchor" href="#example-anonymous-block" aria-label="Permalink to &quot;&lt;a id=&quot;topic_isw_3sx_cz&quot;&gt;&lt;/a&gt;Example: Anonymous Block&quot;">​</a></h3><p>This example runs the statements in the <code>t1_calc()</code> function from a previous example as an anonymous block using the <code>DO</code> command. In the example, the anonymous block retrieves the input value from a temporary table.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE TEMP TABLE list AS VALUES (&#39;test1&#39;) DISTRIBUTED RANDOMLY;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>DO $$ </span></span>
<span class="line"><span>DECLARE</span></span>
<span class="line"><span>    t1_row   table1%ROWTYPE;</span></span>
<span class="line"><span>    calc_int table1.f3%TYPE;</span></span>
<span class="line"><span>BEGIN</span></span>
<span class="line"><span>    SELECT * INTO t1_row FROM table1, list WHERE table1.f1 = list.column1 ;</span></span>
<span class="line"><span>    calc_int = (t1_row.f2 * t1_row.f3)::integer ;</span></span>
<span class="line"><span>    RAISE NOTICE &#39;calculated value is %&#39;, calc_int ;</span></span>
<span class="line"><span>END $$ LANGUAGE plpgsql ;</span></span></code></pre></div><h2 id="about-developing-pl-pgsql-procedures" tabindex="-1"><a id="about_procs"></a>About Developing PL/pgSQL Procedures <a class="header-anchor" href="#about-developing-pl-pgsql-procedures" aria-label="Permalink to &quot;&lt;a id=&quot;about_procs&quot;&gt;&lt;/a&gt;About Developing PL/pgSQL Procedures&quot;">​</a></h2><p>A PL/pgSQL procedure is similar to a PL/pgSQL function. Refer to <a href="./../admin_guide/query/topics/functions-operators.html#topic28a">User-Defined Procedures</a> for more information on procedures in WarehousePG and how they differ from functions.</p><p>A PL/pgSQL procedure does not have a return value, and as such can end without a <code>RETURN</code> statement. If you wish to use a <code>RETURN</code> statement to exit the code early, write just <code>RETURN</code> with no expression.</p><p>If the PL/pgSQL procedure has output parameters, the final values of the output parameter variables will be returned to the caller.</p><p>A PL/pgSQL function, procedure, or <code>DO</code> block can call a procedure using <code>CALL</code>. Output parameters are handled differently from the way that <code>CALL</code> works in plain SQL. Each <code>INOUT</code> parameter of the procedure must correspond to a variable in the <code>CALL</code> statement, and whatever the procedure returns is assigned back to that variable after it returns. For example:</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">CREATE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> PROCEDURE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> triple(INOUT x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">LANGUAGE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> plpgsql</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">AS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $$</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">BEGIN</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    x :</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">END</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$$;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">DO $$</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">DECLARE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myvar </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> :</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">BEGIN</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  CALL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> triple(myvar);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  RAISE NOTICE </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;myvar = %&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, myvar;  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- prints 15</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">END</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$$;</span></span></code></pre></div><h3 id="about-transaction-management-in-procedures" tabindex="-1"><a id="proc_transmgmt"></a>About Transaction Management in Procedures <a class="header-anchor" href="#about-transaction-management-in-procedures" aria-label="Permalink to &quot;&lt;a id=&quot;proc_transmgmt&quot;&gt;&lt;/a&gt;About Transaction Management in Procedures&quot;">​</a></h3><p>In procedures invoked by the <code>CALL</code> command as well as in anonymous code blocks (<code>DO</code> command), it is possible to end transactions using the commands <code>COMMIT</code> and <code>ROLLBACK</code>. A new transaction is started automatically after a transaction is ended using these commands, so there is no separate <code>START TRANSACTION</code> command. (Note that <code>BEGIN</code> and <code>END</code> have different meanings in PL/pgSQL.)</p><p>Here is a simple example:</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">CREATE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> PROCEDURE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> transaction_test1()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">LANGUAGE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> plpgsql</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">AS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $$</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">BEGIN</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    FOR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">IN</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">..</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">9</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> LOOP</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        INSERT INTO</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> test1 (a) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">VALUES</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        IF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i % </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> THEN</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            COMMIT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        ELSE</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            ROLLBACK</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        END</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> IF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    END</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> LOOP</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">END</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$$;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">CALL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> transaction_test1();</span></span></code></pre></div><p>A new transaction starts out with default transaction characteristics such as transaction isolation level. In cases where transactions are committed in a loop, it might be desirable to start new transactions automatically with the same characteristics as the previous one. The commands COMMIT AND CHAIN and ROLLBACK AND CHAIN accomplish this.</p><p>Transaction control is only possible in <code>CALL</code> or <code>DO</code> invocations from the top level or nested <code>CALL</code> or <code>DO</code> invocations without any other intervening command. For example, if the call stack is <code>CALL proc1()</code> → <code>CALL proc2()</code> → <code>CALL proc3()</code>, then the second and third procedures can perform transaction control actions. But if the call stack is <code>CALL proc1()</code> → <code>SELECT func2()</code> → <code>CALL proc3()</code>, the last procedure cannot perform transaction control because of the <code>SELECT</code> in between.</p><h2 id="references" tabindex="-1"><a id="topic10"></a>References <a class="header-anchor" href="#references" aria-label="Permalink to &quot;&lt;a id=&quot;topic10&quot;&gt;&lt;/a&gt;References&quot;">​</a></h2><p>The PostgreSQL documentation about PL/pgSQL is at <a href="https://www.postgresql.org/docs/12/plpgsql.html" target="_blank" rel="noreferrer">https://www.postgresql.org/docs/12/plpgsql.html</a></p><p>Also, see the <a href="./../ref_guide/sql_commands/CREATE_FUNCTION.html">CREATE FUNCTION</a> command in the <em>WarehousePG Reference Guide</em>.</p><p>For a summary of built-in WarehousePG functions, see <a href="./../ref_guide/function-summary.html">Summary of Built-in Functions</a> in the <em>WarehousePG Reference Guide</em>. For information about using WarehousePG functions see &quot;SQL: Querying Data&quot; in the <em>WarehousePG Administrator Guide</em></p><p>For information about porting Oracle functions, see <a href="https://www.postgresql.org/docs/12/plpgsql-porting.html" target="_blank" rel="noreferrer">https://www.postgresql.org/docs/12/plpgsql-porting.html</a>. For information about installing and using the Oracle compatibility functions with WarehousePG, see &quot;Oracle Compatibility Functions&quot; in the <em>WarehousePG Utility Guide</em>.</p>`,112)]))}const g=s(i,[["render",p]]);export{u as __pageData,g as default};
