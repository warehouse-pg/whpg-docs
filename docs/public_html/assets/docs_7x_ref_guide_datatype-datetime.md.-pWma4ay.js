import{_ as t,c as a,o,ag as d}from"./chunks/framework.Ds6Eueu6.js";const m=JSON.parse('{"title":"Date/Time Types","description":"","frontmatter":{},"headers":[],"relativePath":"docs/7x/ref_guide/datatype-datetime.md","filePath":"docs/7x/ref_guide/datatype-datetime.md"}'),i={name:"docs/7x/ref_guide/datatype-datetime.md"};function s(n,e,r,c,l,h){return o(),a("div",null,e[0]||(e[0]=[d(`<h1 id="date-time-types" tabindex="-1">Date/Time Types <a class="header-anchor" href="#date-time-types" aria-label="Permalink to &quot;Date/Time Types&quot;">​</a></h1><p>WarehousePG supports the full set of SQL date and time types, shown in <a href="#datatype-datetime-table">Table 1</a>. The operations available on these data types are described in <a href="https://www.postgresql.org/docs/12/functions-datetime.html" target="_blank" rel="noreferrer">Date/Time Functions and Operators</a> in the PostgreSQL documentation. Dates are counted according to the Gregorian calendar, even in years before that calendar was introduced (see <a href="https://www.postgresql.org/docs/12/datetime-units-history.html" target="_blank" rel="noreferrer">History of Units</a> in the PostgreSQL documentation for more information).</p><table tabindex="0"><thead><tr><th>Name</th><th>Storage Size</th><th>Description</th><th>Low Value</th><th>High Value</th><th>Resolution</th></tr></thead><tbody><tr><td>timestamp [ (p) ] [ without time zone ]</td><td>8 bytes</td><td>both date and time (no time zone)</td><td>4713 BC</td><td>294276 AD</td><td>1 microsecond / 14 digits</td></tr><tr><td>timestamp [ (p) ] with time zone</td><td>8 bytes</td><td>both date and time, with time zone</td><td>4713 BC</td><td>294276 AD</td><td>1 microsecond / 14 digits</td></tr><tr><td>date</td><td>4 bytes</td><td>date (no time of day)</td><td>4713 BC</td><td>5874897 AD</td><td>1 day</td></tr><tr><td>time [ (p) ] [ without time zone ]</td><td>8 bytes</td><td>time of day (no date)</td><td>00:00:00</td><td>24:00:00</td><td>1 microsecond / 14 digits</td></tr><tr><td>time [ (p) ] with time zone</td><td>12 bytes</td><td>times of day only, with time zone</td><td>00:00:00+1459</td><td>24:00:00-1459</td><td>1 microsecond / 14 digits</td></tr><tr><td>interval [ fields ] [ (p) ]</td><td>16 bytes</td><td>time interval</td><td>-178000000 years</td><td>178000000 years</td><td>1 microsecond / 14 digits</td></tr></tbody></table><blockquote><p><strong>Note</strong> The SQL standard requires that writing just <code>timestamp</code> be equivalent to <code>timestamp without time zone</code>, and WarehousePG honors that behavior. <code>timestamptz</code> is accepted as an abbreviation for <code>timestamp with time zone</code>; this is a PostgreSQL extension.</p></blockquote><p><code>time</code>, <code>timestamp</code>, and <code>interval</code> accept an optional precision value p which specifies the number of fractional digits retained in the seconds field. By default, there is no explicit bound on precision. The allowed range of p is from 0 to 6 for the <code>timestamp</code> and <code>interval</code> types.</p><blockquote><p><strong>Note</strong> When <code>timestamp</code> values are stored as eight-byte integers (currently the default), microsecond precision is available over the full range of values. When <code>timestamp</code> values are stored as double precision floating-point numbers instead (a deprecated compile-time option), the effective limit of precision might be less than 6. <code>timestamp</code> values are stored as seconds before or after midnight 2000-01-01. When <code>timestamp</code> values are implemented using floating-point numbers, microsecond precision is achieved for dates within a few years of 2000-01-01, but the precision degrades for dates further away. Note that using floating-point datetimes allows a larger range of <code>timestamp</code> values to be represented than shown above: from 4713 BC up to 5874897 AD.</p></blockquote><p>The same compile-time option also determines whether <code>time</code> and <code>interval</code> values are stored as floating-point numbers or eight-byte integers. In the floating-point case, large <code>interval</code> values degrade in precision as the size of the interval increases.</p><p>For the <code>time</code> types, the allowed range of p is from 0 to 6 when eight-byte integer storage is used, or from 0 to 10 when floating-point storage is used.</p><p>The <code>interval</code> type has an additional option, which is to restrict the set of stored fields by writing one of these phrases:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>YEAR</span></span>
<span class="line"><span>MONTH</span></span>
<span class="line"><span>DAY</span></span>
<span class="line"><span>HOUR</span></span>
<span class="line"><span>MINUTE</span></span>
<span class="line"><span>SECOND</span></span>
<span class="line"><span>YEAR TO MONTH</span></span>
<span class="line"><span>DAY TO HOUR</span></span>
<span class="line"><span>DAY TO MINUTE</span></span>
<span class="line"><span>DAY TO SECOND</span></span>
<span class="line"><span>HOUR TO MINUTE</span></span>
<span class="line"><span>HOUR TO SECOND</span></span>
<span class="line"><span>MINUTE TO SECOND</span></span></code></pre></div><p>Note that if both fields and p are specified, the fields must include <code>SECOND</code>, since the precision applies only to the seconds.</p><p>The type <code>time with time zone</code> is defined by the SQL standard, but the definition exhibits properties which lead to questionable usefulness. In most cases, a combination of <code>date</code>, <code>time</code>, <code>timestamp without time zone</code>, and <code>timestamp with time zone</code> should provide a complete range of date/time functionality required by any application.</p><p>The types <code>abstime</code> and <code>reltime</code> are lower precision types which are used internally. You are discouraged from using these types in applications; these internal types might disappear in a future release.</p><p>WarehousePG 6 and later releases do not automatically cast text from the deprecated timestamp format <code>YYYYMMDDHH24MISS</code>. The format could not be parsed unambiguously in previous WarehousePG releases.</p><p>For example, this command returns an error in WarehousePG 6. In previous releases, a timestamp is returned.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># select to_timestamp(&#39;20190905140000&#39;);</span></span></code></pre></div><p>In WarehousePG 6, this command returns a timestamp.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># select to_timestamp(&#39;20190905140000&#39;,&#39;YYYYMMDDHH24MISS&#39;);</span></span></code></pre></div><h2 id="date-time-input" tabindex="-1"><a id="datatype-datetime-input"></a>Date/Time Input <a class="header-anchor" href="#date-time-input" aria-label="Permalink to &quot;&lt;a id=&quot;datatype-datetime-input&quot;&gt;&lt;/a&gt;Date/Time Input&quot;">​</a></h2><p>Date and time input is accepted in almost any reasonable format, including ISO 8601, SQL-compatible, traditional POSTGRES, and others. For some formats, ordering of day, month, and year in date input is ambiguous and there is support for specifying the expected ordering of these fields. Set the <a href="./config_params/guc-list.html">DateStyle</a> parameter to <code>MDY</code> to select month-day-year interpretation, <code>DMY</code> to select day-month-year interpretation, or <code>YMD</code> to select year-month-day interpretation.</p><p>WarehousePG is more flexible in handling date/time input than the SQL standard requires. See <a href="https://www.postgresql.org/docs/12/datetime-appendix.html" target="_blank" rel="noreferrer">Appendix B. Date/Time Support</a> in the PostgreSQL documentation for the exact parsing rules of date/time input and for the recognized text fields including months, days of the week, and time zones.</p><p>Remember that any date or time literal input needs to be enclosed in single quotes, like text strings. SQL requires the following syntax</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>&lt;type&gt; [ (&lt;p&gt;) ] &#39;&lt;value&gt;&#39;</span></span></code></pre></div><p>where p is an optional precision specification giving the number of fractional digits in the seconds field. Precision can be specified for <code>time</code>, <code>timestamp</code>, and <code>interval</code> types. The allowed values are mentioned above. If no precision is specified in a constant specification, it defaults to the precision of the literal value.</p><h2 id="dates" tabindex="-1"><a id="dates"></a>Dates <a class="header-anchor" href="#dates" aria-label="Permalink to &quot;&lt;a id=&quot;dates&quot;&gt;&lt;/a&gt;Dates&quot;">​</a></h2><p><a href="#table_owm_dfr_qfb">Table 2</a> shows some possible inputs for the <code>date</code> type.</p><table tabindex="0"><thead><tr><th>Example</th><th>Description</th></tr></thead><tbody><tr><td>1999-01-08</td><td>ISO 8601; January 8 in any mode (recommended format)</td></tr><tr><td>January 8, 1999</td><td>unambiguous in any datestyle input mode</td></tr><tr><td>1/8/1999</td><td>January 8 in <code>MDY</code> mode; August 1 in <code>DMY</code> mode</td></tr><tr><td>1/18/1999</td><td>January 18 in <code>MDY</code> mode; rejected in other modes</td></tr><tr><td>01/02/03</td><td>January 2, 2003 in <code>MDY</code> mode; February 1, 2003 in <code>DMY</code> mode; February 3, 2001 in <code>YMD</code> mode</td></tr><tr><td>1999-Jan-08</td><td>January 8 in any mode</td></tr><tr><td>Jan-08-1999</td><td>January 8 in any mode</td></tr><tr><td>08-Jan-1999</td><td>January 8 in any mode</td></tr><tr><td>99-Jan-08</td><td>January 8 in <code>YMD</code> mode, else error</td></tr><tr><td>08-Jan-99</td><td>January 8, except error in <code>YMD</code> mode</td></tr><tr><td>Jan-08-99</td><td>January 8, except error in <code>YMD</code> mode</td></tr><tr><td>19990108</td><td>ISO 8601; January 8, 1999 in any mode</td></tr><tr><td>990108</td><td>ISO 8601; January 8, 1999 in any mode</td></tr><tr><td>1999.008</td><td>year and day of year</td></tr><tr><td>J2451187</td><td>Julian date</td></tr><tr><td>January 8, 99 BC</td><td>year 99 BC</td></tr></tbody></table><h2 id="times" tabindex="-1"><a id="times"></a>Times <a class="header-anchor" href="#times" aria-label="Permalink to &quot;&lt;a id=&quot;times&quot;&gt;&lt;/a&gt;Times&quot;">​</a></h2><p>The time-of-day types are <code>time [ (p) ] without time zone</code> and <code>time [ (p) ] with time zone</code>. <code>time</code> alone is equivalent to <code>time without time zone</code>.</p><p>Valid input for these types consists of a time of day followed by an optional time zone. (See <a href="#datatype-datetime-time-table">Table 3</a> and <a href="#datatype-timezone-table">Table 4</a>.) If a time zone is specified in the input for <code>time without time zone</code>, it is silently ignored. You can also specify a date but it will be ignored, except when you use a time zone name that involves a daylight-savings rule, such as <code>America/New_York</code>. In this case specifying the date is required in order to determine whether standard or daylight-savings time applies. The appropriate time zone offset is recorded in the <code>time with time zone</code> value.</p><table tabindex="0"><thead><tr><th>Example</th><th>Description</th></tr></thead><tbody><tr><td><code>04:05:06.789</code></td><td>ISO 8601</td></tr><tr><td><code>04:05:06</code></td><td>ISO 8601</td></tr><tr><td><code>04:05</code></td><td>ISO 8601</td></tr><tr><td><code>040506</code></td><td>ISO 8601</td></tr><tr><td><code>04:05 AM</code></td><td>same as 04:05; AM does not affect value</td></tr><tr><td><code>04:05 PM</code></td><td>same as 16:05; input hour must be &lt;= 12</td></tr><tr><td><code>04:05:06.789-8</code></td><td>ISO 8601</td></tr><tr><td><code>04:05:06-08:00</code></td><td>ISO 8601</td></tr><tr><td><code>04:05-08:00</code></td><td>ISO 8601</td></tr><tr><td><code>040506-08</code></td><td>ISO 8601</td></tr><tr><td><code>04:05:06 PST</code></td><td>time zone specified by abbreviation</td></tr><tr><td><code>2003-04-12 04:05:06 America/New_York</code></td><td>time zone specified by full name</td></tr></tbody></table><table tabindex="0"><thead><tr><th>Example</th><th>Description</th></tr></thead><tbody><tr><td><code>PST</code></td><td>Abbreviation (for Pacific Standard Time)</td></tr><tr><td><code>America/New_York</code></td><td>Full time zone name</td></tr><tr><td><code>PST8PDT</code></td><td>POSIX-style time zone specification</td></tr><tr><td><code>-8:00</code></td><td>ISO-8601 offset for PST</td></tr><tr><td><code>-800</code></td><td>ISO-8601 offset for PST</td></tr><tr><td><code>-8</code></td><td>ISO-8601 offset for PST</td></tr><tr><td><code>zulu</code></td><td>Military abbreviation for UTC</td></tr><tr><td><code>z</code></td><td>Short form of <code>zulu</code></td></tr></tbody></table><p>Refer to <a href="#datatype-timezones">Time Zones</a> for more information on how to specify time zones.</p><h2 id="time-stamps" tabindex="-1"><a id="tstamps"></a>Time Stamps <a class="header-anchor" href="#time-stamps" aria-label="Permalink to &quot;&lt;a id=&quot;tstamps&quot;&gt;&lt;/a&gt;Time Stamps&quot;">​</a></h2><p>Valid input for the time stamp types consists of the concatenation of a date and a time, followed by an optional time zone, followed by an optional <code>AD</code> or <code>BC</code>. (Alternatively, <code>AD</code>/<code>BC</code> can appear before the time zone, but this is not the preferred ordering.) Thus: <code>1999-01-08 04:05:06</code> and: <code>1999-01-08 04:05:06 -8:00</code> are valid values, which follow the ISO 8601 standard. In addition, the common format: <code>January 8 04:05:06 1999 PST</code> is supported.</p><p>The SQL standard differentiates <code>timestamp without time zone</code> and <code>timestamp with time zone</code> literals by the presence of a <code>+</code> or <code>-</code> symbol and time zone offset after the time. Hence, according to the standard, <code>TIMESTAMP &#39;2004-10-19 10:23:54&#39;</code> is a <code>timestamp without time zone</code>, while <code>TIMESTAMP &#39;2004-10-19 10:23:54+02&#39;</code> is a <code>timestamp with time zone</code>. WarehousePG never examines the content of a literal string before determining its type, and therefore will treat both of the above as <code>timestamp without time zone</code>. To ensure that a literal is treated as <code>timestamp with time zone</code>, give it the correct explicit type: <code>TIMESTAMP WITH TIME ZONE &#39;2004-10-19 10:23:54+02&#39;</code> In a literal that has been determined to be <code>timestamp without time zone</code>, WarehousePG will silently ignore any time zone indication. That is, the resulting value is derived from the date/time fields in the input value, and is not adjusted for time zone.</p><p>For <code>timestamp with time zone</code>, the internally stored value is always in UTC (Universal Coordinated Time, traditionally known as Greenwich Mean Time, GMT). An input value that has an explicit time zone specified is converted to UTC using the appropriate offset for that time zone. If no time zone is stated in the input string, then it is assumed to be in the time zone indicated by the system&#39;s <code>TimeZone</code> parameter, and is converted to UTC using the offset for the timezone zone.</p><p>When a <code>timestamp with time zone</code> value is output, it is always converted from UTC to the current timezone zone, and displayed as local time in that zone. To see the time in another time zone, either change timezone or use the <code>AT TIME ZONE</code> construct (see <a href="https://www.postgresql.org/docs/12/functions-datetime.html#FUNCTIONS-DATETIME-ZONECONVERT" target="_blank" rel="noreferrer">AT TIME ZONE</a> in the PostgreSQL documentation).</p><p>Conversions between <code>timestamp without time zone</code> and <code>timestamp with time zone</code> normally assume that the <code>timestamp without time zone</code> value should be taken or given as timezone local time. A different time zone can be specified for the conversion using <code>AT TIME ZONE</code>.</p><h2 id="special-values" tabindex="-1"><a id="specialvals"></a>Special Values <a class="header-anchor" href="#special-values" aria-label="Permalink to &quot;&lt;a id=&quot;specialvals&quot;&gt;&lt;/a&gt;Special Values&quot;">​</a></h2><p>WarehousePG supports several special date/time input values for convenience, as shown in <a href="#datatype-datetime-special-table">Table 5</a>. The values <code>infinity</code> and <code>-infinity</code> are specially represented inside the system and will be displayed unchanged; but the others are simply notational shorthands that will be converted to ordinary date/time values when read. (In particular, <code>now</code> and related strings are converted to a specific time value as soon as they are read.) All of these values need to be enclosed in single quotes when used as constants in SQL commands.</p><table tabindex="0"><thead><tr><th>Input String</th><th>Valid Types</th><th>Description</th></tr></thead><tbody><tr><td><code>epoch</code></td><td><code>date</code>, <code>timestamp</code></td><td>1970-01-01 00:00:00+00 (Unix system time zero)</td></tr><tr><td><code>infinity</code></td><td><code>date</code>, <code>timestamp</code></td><td>later than all other time stamps</td></tr><tr><td><code>-infinity</code></td><td><code>date</code>, <code>timestamp</code></td><td>earlier than all other time stamps</td></tr><tr><td><code>now</code></td><td><code>date</code>, <code>time</code>, <code>timestamp</code></td><td>current transaction&#39;s start time</td></tr><tr><td><code>today</code></td><td><code>date</code>, <code>timestamp</code></td><td>midnight today</td></tr><tr><td><code>tomorrow</code></td><td><code>date</code>, <code>timestamp</code></td><td>midnight tomorrow</td></tr><tr><td><code>yesterday</code></td><td><code>date</code>, <code>timestamp</code></td><td>midnight yesterday</td></tr><tr><td><code>allballs</code></td><td><code>time</code></td><td>00:00:00.00 UTC</td></tr></tbody></table><p>The following SQL-compatible functions can also be used to obtain the current time value for the corresponding data type: <code>CURRENT_DATE</code>, <code>CURRENT_TIME</code>, <code>CURRENT_TIMESTAMP</code>, <code>LOCALTIME</code>, <code>LOCALTIMESTAMP</code>. The latter four accept an optional subsecond precision specification. (See <a href="https://www.postgresql.org/docs/12/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT" target="_blank" rel="noreferrer">Current Date/Time</a> in the PostgreSQL documentation.) Note that these are SQL functions and are <em>not</em> recognized in data input strings.</p><h2 id="date-time-output" tabindex="-1"><a id="datatype-datetime-output"></a>Date/Time Output <a class="header-anchor" href="#date-time-output" aria-label="Permalink to &quot;&lt;a id=&quot;datatype-datetime-output&quot;&gt;&lt;/a&gt;Date/Time Output&quot;">​</a></h2><p>The output format of the date/time types can be set to one of the four styles ISO 8601, SQL (Ingres), traditional POSTGRES (Unix <code>date</code> format), or German. The default is the ISO format. (The SQL standard requires the use of the ISO 8601 format. The name of the <code>SQL</code> output format is a historical accident.) <a href="#datatype-datetime-output-table">Table 6</a> shows examples of each output style. The output of the <code>date</code> and <code>time</code> types is generally only the date or time part in accordance with the given examples. However, the POSTGRES style outputs date-only values in ISO format.</p><table tabindex="0"><thead><tr><th>Style Specification</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td><code>ISO</code></td><td>ISO 8601, SQL standard</td><td><code>1997-12-17 07:37:16-08</code></td></tr><tr><td><code>SQL</code></td><td>traditional style</td><td><code>12/17/1997 07:37:16.00 PST</code></td></tr><tr><td><code>Postgres</code></td><td>original style</td><td><code>Wed Dec 17 07:37:16 1997 PST</code></td></tr><tr><td><code>German</code></td><td>regional style</td><td><code>17.12.1997 07:37:16.00 PST</code></td></tr></tbody></table><blockquote><p><strong>Note</strong> ISO 8601 specifies the use of uppercase letter <code>T</code> to separate the date and time. WarehousePG accepts that format on input, but on output it uses a space rather than <code>T</code>, as shown above. This is for readability and for consistency with RFC 3339 as well as some other database systems.</p></blockquote><p>In the SQL and POSTGRES styles, day appears before month if DMY field ordering has been specified, otherwise month appears before day. (See <a href="#table_owm_dfr_qfb">Table 2</a> for how this setting also affects interpretation of input values.) <a href="#datatype-datetime-output2-table">Table 7</a> shows examples.</p><table tabindex="0"><thead><tr><th>datestyle Setting</th><th>Input Ordering</th><th>Example Output</th></tr></thead><tbody><tr><td><code>SQL, DMY</code></td><td>day/month/year</td><td><code>17/12/1997 15:37:16.00 CET</code></td></tr><tr><td><code>SQL, MDY</code></td><td>month/day/year</td><td><code>12/17/1997 07:37:16.00 PST</code></td></tr><tr><td><code>Postgres, DMY</code></td><td>day/month/year</td><td><code>Wed 17 Dec 07:37:16 1997 PST</code></td></tr></tbody></table><p>The date/time style can be selected by the user using the <code>SET datestyle</code> command, the <code>DateStyle</code> parameter in the <code>postgresql.conf</code> configuration file, or the <code>PGDATESTYLE</code> environment variable on the server or client.</p><p>The formatting function <code>to_char</code> (see <a href="https://www.postgresql.org/docs/12/functions-formatting.html" target="_blank" rel="noreferrer">Data Type Formatting Functions</a>) is also available as a more flexible way to format date/time output.</p><h2 id="time-zones" tabindex="-1"><a id="datatype-timezones"></a>Time Zones <a class="header-anchor" href="#time-zones" aria-label="Permalink to &quot;&lt;a id=&quot;datatype-timezones&quot;&gt;&lt;/a&gt;Time Zones&quot;">​</a></h2><p>Time zones, and time-zone conventions, are influenced by political decisions, not just earth geometry. Time zones around the world became somewhat standardized during the 1900s, but continue to be prone to arbitrary changes, particularly with respect to daylight-savings rules. WarehousePG uses the widely-used IANA (Olson) time zone database for information about historical time zone rules. For times in the future, the assumption is that the latest known rules for a given time zone will continue to be observed indefinitely far into the future.</p><p>WarehousePG endeavors to be compatible with the SQL standard definitions for typical usage. However, the SQL standard has an odd mix of date and time types and capabilities. Two obvious problems are:</p><ol><li>Although the <code>date</code> type cannot have an associated time zone, the <code>time</code> type can. Time zones in the real world have little meaning unless associated with a date as well as a time, since the offset can vary through the year with daylight-saving time boundaries.</li><li>The default time zone is specified as a constant numeric offset from UTC. It is therefore impossible to adapt to daylight-saving time when doing date/time arithmetic across DST boundaries.</li></ol><p>To address these difficulties, we recommend using date/time types that contain both date and time when using time zones. We do <em>not</em> recommend using the type <code>time with time zone</code> (though it is supported by WarehousePG for legacy applications and for compliance with the SQL standard). WarehousePG assumes your local time zone for any type containing only date or time.</p><p>All timezone-aware dates and times are stored internally in UTC. They are converted to local time in the zone specified by the <code>TimeZone</code> configuration parameter before being displayed to the client.</p><p>WarehousePG allows you to specify time zones in three different forms:</p><ol><li>A full time zone name, for example <code>America/New_York</code>. The recognized time zone names are listed in the <code>pg_timezone_names</code> view. WarehousePG uses the widely-used IANA time zone data for this purpose, so the same time zone names are also recognized by other software.</li><li>A time zone abbreviation, for example <code>PST</code>. Such a specification merely defines a particular offset from UTC, in contrast to full time zone names which can imply a set of daylight savings transition-date rules as well. The recognized abbreviations are listed in the <code>pg_timezone_abbrevs</code> view. You cannot set the configuration parameters <a href="./config_params/guc-list.html">TimeZone</a> or <a href="./config_params/guc-list.html">log_timezone</a> to a time zone abbreviation, but you can use abbreviations in date/time input values and with the <code>AT TIME ZONE</code> operator.</li><li>In addition to the timezone names and abbreviations, WarehousePG will accept POSIX-style time zone specifications of the form STDoffset or STDoffsetDST, where STD is a zone abbreviation, offset is a numeric offset in hours west from UTC, and DST is an optional daylight-savings zone abbreviation, assumed to stand for one hour ahead of the given offset. For example, if <code>EST5EDT</code> were not already a recognized zone name, it would be accepted and would be functionally equivalent to United States East Coast time. In this syntax, a zone abbreviation can be a string of letters, or an arbitrary string surrounded by angle brackets (<code>&lt;&gt;</code>). When a daylight-savings zone abbreviation is present, it is assumed to be used according to the same daylight-savings transition rules used in the IANA time zone database&#39;s entry. In a standard WarehousePG installation, is the same as <code>US/Eastern</code>, so that POSIX-style time zone specifications follow USA daylight-savings rules. If needed, you can adjust this behavior by replacing the file.</li></ol><p>In short, this is the difference between abbreviations and full names: abbreviations represent a specific offset from UTC, whereas many of the full names imply a local daylight-savings time rule, and so have two possible UTC offsets. As an example, <code>2014-06-04 12:00 America/New_York</code> represents noon local time in New York, which for this particular date was Eastern Daylight Time (UTC-4). So <code>2014-06-04 12:00 EDT</code> specifies that same time instant. But <code>2014-06-04 12:00 EST</code> specifies noon Eastern Standard Time (UTC-5), regardless of whether daylight savings was nominally in effect on that date.</p><p>To complicate matters, some jurisdictions have used the same timezone abbreviation to mean different UTC offsets at different times; for example, in Moscow <code>MSK</code> has meant UTC+3 in some years and UTC+4 in others. WarehousePG interprets such abbreviations according to whatever they meant (or had most recently meant) on the specified date; but, as with the <code>EST</code> example above, this is not necessarily the same as local civil time on that date.</p><p>One should be wary that the POSIX-style time zone feature can lead to silently accepting bogus input, since there is no check on the reasonableness of the zone abbreviations. For example, <code>SET TIMEZONE TO FOOBAR0</code> will work, leaving the system effectively using a rather peculiar abbreviation for UTC. Another issue to keep in mind is that in POSIX time zone names, positive offsets are used for locations of Greenwich. Everywhere else, WarehousePG follows the ISO-8601 convention that positive timezone offsets are of Greenwich.</p><p>In all cases, timezone names and abbreviations are recognized case-insensitively.</p><p>Neither timezone names nor abbreviations are hard-wired into the server; they are obtained from configuration files (see <a href="./../install_guide/localization.html">Configuring Localization Settings</a>).</p><p>The <code>TimeZone</code> configuration parameter can be set in the file , or in any of the other standard ways for setting configuration parameters. There are also some special ways to set it:</p><ol><li>The SQL command <code>SET TIME ZONE</code> sets the time zone for the session. This is an alternative spelling of <code>SET TIMEZONE TO</code> with a more SQL-spec-compatible syntax.</li><li>The <code>PGTZ</code> environment variable is used by <code>libpq</code> clients to send a <code>SET TIME ZONE</code> command to the server upon connection.</li></ol><h2 id="interval-input" tabindex="-1"><a id="datatype-interval-input"></a>Interval Input <a class="header-anchor" href="#interval-input" aria-label="Permalink to &quot;&lt;a id=&quot;datatype-interval-input&quot;&gt;&lt;/a&gt;Interval Input&quot;">​</a></h2><p><code>interval</code> values can be written using the following verbose syntax:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>&lt;@&gt; &lt;quantity&gt; &lt;unit&gt; &lt;quantity&gt; &lt;unit&gt;... &lt;direction&gt;</span></span></code></pre></div><p>where quantity is a number (possibly signed); unit is <code>microsecond</code>, <code>millisecond</code>, <code>second</code>, <code>minute</code>, <code>hour</code>, <code>day</code>, <code>week</code>, <code>month</code>, <code>year</code>, <code>decade</code>, <code>century</code>, <code>millennium</code>, or abbreviations or plurals of these units; direction can be <code>ago</code> or empty. The at sign (<code>@</code>) is optional noise. The amounts of the different units are implicitly added with appropriate sign accounting. <code>ago</code> negates all the fields. This syntax is also used for interval output, if <a href="./config_params/guc-list.html">IntervalStyle</a> is set to <code>postgres_verbose</code>.</p><p>Quantities of days, hours, minutes, and seconds can be specified without explicit unit markings. For example, <code>&#39;1 12:59:10&#39;</code> is read the same as <code>&#39;1 day 12 hours 59 min 10 sec&#39;</code>. Also, a combination of years and months can be specified with a dash; for example <code>&#39;200-10&#39;</code> is read the same as <code>&#39;200 years 10 months&#39;</code>. (These shorter forms are in fact the only ones allowed by the SQL standard, and are used for output when IntervalStyle is set to <code>sql_standard</code>.)</p><p>Interval values can also be written as ISO 8601 time intervals, using either the <code>format with designators</code> of the standard&#39;s section 4.4.3.2 or the <code>alternative format</code> of section 4.4.3.3. The format with designators looks like this:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>P &lt;quantity&gt; &lt;unit&gt; &lt;quantity&gt; &lt;unit&gt; ...  T  &lt;quantity&gt; &lt;unit&gt; ...</span></span></code></pre></div><p>The string must start with a <code>P</code>, and may include a <code>T</code> that introduces the time-of-day units. The available unit abbreviations are given in <a href="#datatype-interval-iso8601-units">Table 8</a>. Units may be omitted, and may be specified in any order, but units smaller than a day must appear after <code>T</code>. In particular, the meaning of <code>M</code> depends on whether it is before or after <code>T</code>.</p><table tabindex="0"><thead><tr><th>Abbreviation</th><th>Meaning</th></tr></thead><tbody><tr><td>Y</td><td>Years</td></tr><tr><td>M</td><td>Months (in the date part)</td></tr><tr><td>W</td><td>Weeks</td></tr><tr><td>D</td><td>Days</td></tr><tr><td>H</td><td>Hours</td></tr><tr><td>M</td><td>Minutes (in the time part)</td></tr><tr><td>S</td><td>Seconds</td></tr></tbody></table><p>In the alternative format:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>P  &lt;years&gt;-&lt;months&gt;-&lt;days&gt;   T &lt;hours&gt;:&lt;minutes&gt;:&lt;seconds&gt;</span></span></code></pre></div><p>the string must begin with <code>P</code>, and a <code>T</code> separates the date and time parts of the interval. The values are given as numbers similar to ISO 8601 dates.</p><p>When writing an interval constant with a fields specification, or when assigning a string to an interval column that was defined with a fields specification, the interpretation of unmarked quantities depends on the fields. For example <code>INTERVAL &#39;1&#39; YEAR</code> is read as 1 year, whereas <code>INTERVAL &#39;1&#39;</code> means 1 second. Also, field values <code>to the right</code> of the least significant field allowed by the fields specification are silently discarded. For example, writing <code>INTERVAL &#39;1 day 2:03:04&#39; HOUR TO MINUTE</code> results in dropping the seconds field, but not the day field.</p><p>According to the SQL standard all fields of an interval value must have the same sign, so a leading negative sign applies to all fields; for example the negative sign in the interval literal <code>&#39;-1 2:03:04&#39;</code> applies to both the days and hour/minute/second parts. WarehousePG allows the fields to have different signs, and traditionally treats each field in the textual representation as independently signed, so that the hour/minute/second part is considered positive in this example. If IntervalStyle is set to <code>sql_standard</code> then a leading sign is considered to apply to all fields (but only if no additional signs appear). Otherwise the traditional WarehousePG interpretation is used. To avoid ambiguity, it&#39;s recommended to attach an explicit sign to each field if any field is negative.</p><p>In the verbose input format, and in some fields of the more compact input formats, field values can have fractional parts; for example <code>&#39;1.5 week&#39;</code> or <code>&#39;01:02:03.45&#39;</code>. Such input is converted to the appropriate number of months, days, and seconds for storage. When this would result in a fractional number of months or days, the fraction is added to the lower-order fields using the conversion factors 1 month = 30 days and 1 day = 24 hours. For example, <code>&#39;1.5 month&#39;</code> becomes 1 month and 15 days. Only seconds will ever be shown as fractional on output.</p><p><a href="#datatype-interval-input-examples">Table 9</a> shows some examples of valid <code>interval</code> input.</p><table tabindex="0"><thead><tr><th>Example</th><th>Description</th></tr></thead><tbody><tr><td>1-2</td><td>SQL standard format: 1 year 2 months</td></tr><tr><td>3 4:05:06</td><td>SQL standard format: 3 days 4 hours 5 minutes 6 seconds</td></tr><tr><td>1 year 2 months 3 days 4 hours 5 minutes 6 seconds</td><td>Traditional Postgres format: 1 year 2 months 3 days 4 hours 5 minutes 6 seconds</td></tr><tr><td>P1Y2M3DT4H5M6S</td><td>ISO 8601 <code>format with designators</code>: same meaning as above</td></tr><tr><td>P0001-02-03T04:05:06</td><td>ISO 8601 <code>alternative format</code>: same meaning as above</td></tr></tbody></table><p>Internally <code>interval</code> values are stored as months, days, and seconds. This is done because the number of days in a month varies, and a day can have 23 or 25 hours if a daylight savings time adjustment is involved. The months and days fields are integers while the seconds field can store fractions. Because intervals are usually created from constant strings or <code>timestamp</code> subtraction, this storage method works well in most cases, but can cause unexpected results: <code>SELECT EXTRACT(hours from &#39;80 minutes&#39;::interval); date_part ----------- 1 SELECT EXTRACT(days from &#39;80 hours&#39;::interval); date_part ----------- 0</code> Functions <code>justify_days</code> and <code>justify_hours</code> are available for adjusting days and hours that overflow their normal ranges.</p><h2 id="interval-output" tabindex="-1"><a id="datatype-interval-output"></a>Interval Output <a class="header-anchor" href="#interval-output" aria-label="Permalink to &quot;&lt;a id=&quot;datatype-interval-output&quot;&gt;&lt;/a&gt;Interval Output&quot;">​</a></h2><p>The output format of the interval type can be set to one of the four styles <code>sql_standard</code>, <code>postgres</code>, <code>postgres_verbose</code>, or <code>iso_8601</code>, using the command <code>SET intervalstyle</code>. The default is the <code>postgres</code> format. <a href="#interval-style-output-table">Table 10</a> shows examples of each output style.</p><p>The <code>sql_standard</code> style produces output that conforms to the SQL standard&#39;s specification for interval literal strings, if the interval value meets the standard&#39;s restrictions (either year-month only or day-time only, with no mixing of positive and negative components). Otherwise the output looks like a standard year-month literal string followed by a day-time literal string, with explicit signs added to disambiguate mixed-sign intervals.</p><p>The output of the <code>postgres</code> style matches the output of PostgreSQL releases prior to 8.4 when the <a href="./config_params/guc-list.html">DateStyle</a> parameter was set to <code>ISO</code>.</p><p>The output of the <code>postgres_verbose</code> style matches the output of PostgreSQL releases prior to 8.4 when the DateStyle parameter was set to non-<code>ISO</code> output.</p><p>The output of the <code>iso_8601</code> style matches the <code>format with designators</code> described in section 4.4.3.2 of the ISO 8601 standard.</p><table tabindex="0"><thead><tr><th>Style Specification</th><th>Year-Month Interval</th><th>Day-Time Interval</th><th>Mixed Interval</th></tr></thead><tbody><tr><td><code>sql_standard</code></td><td>1-2</td><td>3 4:05:06</td><td>-1-2 +3 -4:05:06</td></tr><tr><td><code>postgres</code></td><td>1 year 2 mons</td><td>3 days 04:05:06</td><td>-1 year -2 mons +3 days -04:05:06</td></tr><tr><td><code>postgres_verbose</code></td><td>@ 1 year 2 mons</td><td>@ 3 days 4 hours 5 mins 6 secs</td><td>@ 1 year 2 mons -3 days 4 hours 5 mins 6 secs ago</td></tr><tr><td><code>iso_8601</code></td><td>P1Y2M</td><td>P3DT4H5M6S</td><td>P-1Y-2M3DT-4H-5M-6S</td></tr></tbody></table><p><strong>Parent topic:</strong> <a href="./data_types.html">Data Types</a></p>`,92)]))}const u=t(i,[["render",s]]);export{m as __pageData,u as default};
