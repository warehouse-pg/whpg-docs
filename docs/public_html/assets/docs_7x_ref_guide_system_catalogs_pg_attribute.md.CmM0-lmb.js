import{_ as e,c as d,o,ag as a}from"./chunks/framework.Ds6Eueu6.js";const p=JSON.parse('{"title":"pg_attribute","description":"","frontmatter":{},"headers":[],"relativePath":"docs/7x/ref_guide/system_catalogs/pg_attribute.md","filePath":"docs/7x/ref_guide/system_catalogs/pg_attribute.md"}'),r={name:"docs/7x/ref_guide/system_catalogs/pg_attribute.md"};function n(c,t,s,i,l,h){return o(),d("div",null,t[0]||(t[0]=[a('<h1 id="pg-attribute" tabindex="-1">pg_attribute <a class="header-anchor" href="#pg-attribute" aria-label="Permalink to &quot;pg_attribute&quot;">â€‹</a></h1><p>The <code>pg_attribute</code> table stores information about table columns. There will be exactly one <code>pg_attribute</code> row for every column in every table in the database. (There will also be attribute entries for indexes, and all objects that have <code>pg_class</code> entries.) The term attribute is equivalent to column.</p><p>In a dropped column&#39;s <code>pg_attribute</code> entry, <code>atttypid</code> is reset to zero, but <code>attlen</code> and the other fields copied from <code>pg_type</code> are still valid. This arrangement is needed to address the situation where the dropped column&#39;s data type was later dropped, and so there is no <code>pg_type</code> row anymore. <code>attlen</code> and the other fields can be used to interpret the contents of a row of the table</p><table tabindex="0"><thead><tr><th>column</th><th>type</th><th>references</th><th>description</th></tr></thead><tbody><tr><td><code>attrelid</code></td><td>oid</td><td><a href="./pg_class.html">pg_class</a>.oid</td><td>The table this column belongs to.</td></tr><tr><td><code>attname</code></td><td>name</td><td></td><td>The column name.</td></tr><tr><td><code>atttypid</code></td><td>oid</td><td><a href="./pg_type.html">pg_type</a>.oid</td><td>The data type of this column.</td></tr><tr><td><code>attstattarget</code></td><td>integer</td><td></td><td>Controls the level of detail of statistics accumulated for this column by <a href="./../sql_commands/ANALYZE.html">ANALYZE</a>. A zero value indicates that no statistics should be collected. A negative value says to use the system default statistics target. The exact meaning of positive values is data type-dependent. For scalar data types, it is both the target number of &quot;most common values&quot; to collect, and the target number of histogram bins to create.</td></tr><tr><td><code>attlen</code></td><td>smallint</td><td></td><td>A copy of <code>pg_type.typlen</code> of this column&#39;s type.</td></tr><tr><td><code>attnum</code></td><td>smallint</td><td></td><td>The number of the column. Ordinary columns are numbered from 1 up. System columns, such as <code>ctid</code>, have (arbitrary) negative numbers.</td></tr><tr><td><code>attndims</code></td><td>integer</td><td></td><td>Number of dimensions, if the column is an array type; otherwise <code>0</code>. (Presently, the number of dimensions of an array is not enforced, so any nonzero value effectively means it is an array.)</td></tr><tr><td><code>attcacheoff</code></td><td>integer</td><td></td><td>Always <code>-1</code> in storage, but when loaded into a row descriptor in memory this may be updated to cache the offset of the attribute within the row.</td></tr><tr><td><code>atttypmod</code></td><td>integer</td><td></td><td>Records type-specific data supplied at table creation time (for example, the maximum length of a <code>varchar</code> column). It is passed to type-specific input functions and length coercion functions. The value will generally be <code>-1</code> for types that do not need it.</td></tr><tr><td><code>attbyval</code></td><td>boolean</td><td></td><td>A copy of <code>pg_type.typbyval</code> of this column&#39;s type.</td></tr><tr><td><code>attstorage</code></td><td>char</td><td></td><td>Normally a copy of <code>pg_type.typstorage</code> of this column&#39;s type. For TOAST-able data types, this can be altered after column creation to control storage policy.</td></tr><tr><td><code>attalign</code></td><td>char</td><td></td><td>A copy of <code>pg_type.typalign</code> of this column&#39;s type.</td></tr><tr><td><code>attnotnull</code></td><td>boolean</td><td></td><td>This represents a not-null constraint.</td></tr><tr><td><code>atthasdef</code></td><td>boolean</td><td></td><td>This column has a default expression or generation expression, in which case there will be a corresponding entry in the <code>pg_attrdef</code> catalog that actually defines the value. (Check <code>attgenerated</code> to determine whether this is a default or a generation expression.)</td></tr><tr><td><code>atthasmissing</code></td><td>boolean</td><td></td><td>This column has a value which is used where the column is entirely missing from the row, as happens when a column is added with a non-volatile <code>DEFAULT</code> value after the row is created. The actual value used is stored in the <code>attmissingval</code> column.</td></tr><tr><td><code>attidentity</code></td><td>char</td><td></td><td>If a zero byte (&#39;&#39;), then not an identity column. Otherwise, <code>a</code> = generated always, <code>d</code> = generated by default.</td></tr><tr><td><code>attgenerated</code></td><td>char</td><td></td><td>If a zero byte (&#39;&#39;), then not a generated column. Otherwise, <code>s</code> = stored. (Other values might be added in the future.)</td></tr><tr><td><code>attisdropped</code></td><td>boolean</td><td></td><td>This column has been dropped and is no longer valid. A dropped column is still physically present in the table, but is ignored by the parser and so cannot be accessed via SQL.</td></tr><tr><td><code>attislocal</code></td><td>boolean</td><td></td><td>This column is defined locally in the relation. Note that a column may be locally defined and inherited simultaneously.</td></tr><tr><td><code>attinhcount</code></td><td>integer</td><td></td><td>The number of direct ancestors this column has. A column with a nonzero number of ancestors cannot be dropped nor renamed.</td></tr><tr><td><code>attcollation</code></td><td>oid</td><td>pg_collation.oid</td><td>The defined collation of the column, or zero if the is not of a collatable data type.</td></tr><tr><td><code>attacl</code></td><td>aclitem[]</td><td></td><td>Column-level access privileges, if any have been granted specifically on this column.</td></tr><tr><td><code>attoptions</code></td><td>text[]</td><td></td><td>Attribute-level options, as &quot;keyword=value&quot; strings.</td></tr><tr><td><code>attfdwoptions</code></td><td>text[]</td><td></td><td>Attribute-level foreign data wrapper options, as &quot;keyword=value&quot; strings.</td></tr><tr><td><code>attmissingval</code></td><td>anyarray</td><td></td><td>This column has a one element array containing the value used when the column is entirely missing from the row, as happens when the column is added with a non-volatile <code>DEFAULT</code> value after the row is created. The value is only used when <code>atthasmissing</code> is <code>true</code>. If there is no value the column is null.</td></tr></tbody></table><p><strong>Parent topic:</strong> <a href="./../system_catalogs/catalog_ref-html.html">System Catalogs Definitions</a></p>',5)]))}const m=e(r,[["render",n]]);export{p as __pageData,m as default};
