import{_ as s,c as e,o as n,ag as t}from"./chunks/framework.Ds6Eueu6.js";const u=JSON.parse('{"title":"Creating and Managing Tables","description":"","frontmatter":{},"headers":[],"relativePath":"docs/7x/admin_guide/ddl/ddl-table.md","filePath":"docs/7x/admin_guide/ddl/ddl-table.md"}'),i={name:"docs/7x/admin_guide/ddl/ddl-table.md"};function o(p,a,l,r,c,d){return n(),e("div",null,a[0]||(a[0]=[t(`<h1 id="creating-and-managing-tables" tabindex="-1">Creating and Managing Tables <a class="header-anchor" href="#creating-and-managing-tables" aria-label="Permalink to &quot;Creating and Managing Tables&quot;">​</a></h1><hr><p>WarehousePG tables are similar to tables in any relational database, except that table rows are distributed across the different segments in the system. When you create a table, you specify the table&#39;s distribution policy.</p><h2 id="creating-a-table" tabindex="-1"><a id="topic26"></a>Creating a Table <a class="header-anchor" href="#creating-a-table" aria-label="Permalink to &quot;&lt;a id=&quot;topic26&quot;&gt;&lt;/a&gt;Creating a Table&quot;">​</a></h2><p>The <code>CREATE TABLE</code> command creates a table and defines its structure. When you create a table, you define:</p><ul><li>The columns of the table and their associated data types. See <a href="#topic27">Choosing Column Data Types</a>.</li><li>Any table or column constraints to limit the data that a column or table can contain. See <a href="#topic28">Setting Table and Column Constraints</a>.</li><li>The distribution policy of the table, which determines how WarehousePG divides data across the segments. See <a href="#topic34">Choosing the Table Distribution Policy</a>.</li><li>The way the table is stored on disk. See <a href="./ddl-storage.html">Choosing the Table Storage Model</a>.</li><li>The table partitioning strategy for large tables. See <a href="./ddl-database.html">Creating and Managing Databases</a>.</li></ul><h3 id="choosing-column-data-types" tabindex="-1"><a id="topic27"></a>Choosing Column Data Types <a class="header-anchor" href="#choosing-column-data-types" aria-label="Permalink to &quot;&lt;a id=&quot;topic27&quot;&gt;&lt;/a&gt;Choosing Column Data Types&quot;">​</a></h3><p>The data type of a column determines the types of data values the column can contain. Choose the data type that uses the least possible space but can still accommodate your data and that best constrains the data. For example, use character data types for strings, date or timestamp data types for dates, and numeric data types for numbers.</p><p>For table columns that contain textual data, specify the data type <code>VARCHAR</code> or <code>TEXT</code>. Specifying the data type <code>CHAR</code> is not recommended. In WarehousePG, the data types <code>VARCHAR</code> or <code>TEXT</code> handle padding added to the data (space characters added after the last non-space character) as significant characters, the data type <code>CHAR</code> does not. For information on the character data types, see the <code>CREATE TABLE</code> command in the <em>WarehousePG Reference Guide</em>.</p><p>Use the smallest numeric data type that will accommodate your numeric data and allow for future expansion. For example, using <code>BIGINT</code> for data that fits in <code>INT</code> or <code>SMALLINT</code> wastes storage space. If you expect that your data values will expand over time, consider that changing from a smaller datatype to a larger datatype after loading large amounts of data is costly. For example, if your current data values fit in a <code>SMALLINT</code> but it is likely that the values will expand, <code>INT</code> is the better long-term choice.</p><p>Use the same data types for columns that you plan to use in cross-table joins. Cross-table joins usually use the primary key in one table and a foreign key in the other table. When the data types are different, the database must convert one of them so that the data values can be compared correctly, which adds unnecessary overhead.</p><p>WarehousePG has a rich set of native data types available to users. See the <em>WarehousePG Reference Guide</em> for information about the built-in data types.</p><h3 id="setting-table-and-column-constraints" tabindex="-1"><a id="topic28"></a>Setting Table and Column Constraints <a class="header-anchor" href="#setting-table-and-column-constraints" aria-label="Permalink to &quot;&lt;a id=&quot;topic28&quot;&gt;&lt;/a&gt;Setting Table and Column Constraints&quot;">​</a></h3><p>You can define constraints on columns and tables to restrict the data in your tables. WarehousePG support for constraints is the same as PostgreSQL with some limitations, including:</p><ul><li><p><code>CHECK</code> constraints can refer only to the table on which they are defined.</p></li><li><p><code>UNIQUE</code> and <code>PRIMARY KEY</code> constraints must be compatible with their tableʼs distribution key and partitioning key, if any.</p><blockquote><p><strong>Note</strong> <code>UNIQUE</code> and <code>PRIMARY KEY</code> constraints are not allowed on append-optimized tables because the <code>UNIQUE</code> indexes that are created by the constraints are not allowed on append-optimized tables.</p></blockquote></li><li><p><code>FOREIGN KEY</code> constraints are allowed, but not enforced.</p></li><li><p>Constraints that you define on partitioned tables apply to the partitioned table as a whole. You cannot define constraints on the individual parts of the table.</p></li></ul><h4 id="check-constraints" tabindex="-1"><a id="topic29"></a>Check Constraints <a class="header-anchor" href="#check-constraints" aria-label="Permalink to &quot;&lt;a id=&quot;topic29&quot;&gt;&lt;/a&gt;Check Constraints&quot;">​</a></h4><p>Check constraints allow you to specify that the value in a certain column must satisfy a Boolean (truth-value) expression. For example, to require positive product prices:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>=&gt; CREATE TABLE products </span></span>
<span class="line"><span>            ( product_no integer, </span></span>
<span class="line"><span>              name text, </span></span>
<span class="line"><span>              price numeric CHECK (price &gt; 0) );</span></span></code></pre></div><h4 id="not-null-constraints" tabindex="-1"><a id="topic30"></a>Not-Null Constraints <a class="header-anchor" href="#not-null-constraints" aria-label="Permalink to &quot;&lt;a id=&quot;topic30&quot;&gt;&lt;/a&gt;Not-Null Constraints&quot;">​</a></h4><p>Not-null constraints specify that a column must not assume the null value. A not-null constraint is always written as a column constraint. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>=&gt; CREATE TABLE products </span></span>
<span class="line"><span>       ( product_no integer NOT NULL,</span></span>
<span class="line"><span>         name text NOT NULL,</span></span>
<span class="line"><span>         price numeric );</span></span></code></pre></div><h4 id="unique-constraints" tabindex="-1"><a id="topic31"></a>Unique Constraints <a class="header-anchor" href="#unique-constraints" aria-label="Permalink to &quot;&lt;a id=&quot;topic31&quot;&gt;&lt;/a&gt;Unique Constraints&quot;">​</a></h4><p>Unique constraints ensure that the data contained in a column or a group of columns is unique with respect to all the rows in the table. The table must be hash-distributed or replicated (not <code>DISTRIBUTED RANDOMLY</code>). If the table is hash-distributed, the constraint columns must be the same as (or a superset of) the table&#39;s distribution key columns. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>=&gt; CREATE TABLE products </span></span>
<span class="line"><span>       ( \`product_no\` integer \`UNIQUE\`, </span></span>
<span class="line"><span>         name text, </span></span>
<span class="line"><span>         price numeric)</span></span>
<span class="line"><span>\`      DISTRIBUTED BY (\`\`product_no\`\`)\`;</span></span></code></pre></div><h4 id="primary-keys" tabindex="-1"><a id="topic32"></a>Primary Keys <a class="header-anchor" href="#primary-keys" aria-label="Permalink to &quot;&lt;a id=&quot;topic32&quot;&gt;&lt;/a&gt;Primary Keys&quot;">​</a></h4><p>A primary key constraint is a combination of a <code>UNIQUE</code> constraint and a <code>NOT NULL</code> constraint. The table must be hash-distributed (not <code>DISTRIBUTED RANDOMLY</code>), and the primary key columns must be the same as (or a superset of) the table&#39;s distribution key columns. If a table has a primary key, this column (or group of columns) is chosen as the distribution key for the table by default. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>=&gt; CREATE TABLE products </span></span>
<span class="line"><span>       ( \`product_no\` integer \`PRIMARY KEY\`, </span></span>
<span class="line"><span>         name text, </span></span>
<span class="line"><span>         price numeric)</span></span>
<span class="line"><span>\`      DISTRIBUTED BY (\`\`product_no\`\`)\`;</span></span></code></pre></div><h4 id="foreign-keys" tabindex="-1"><a id="topic33"></a>Foreign Keys <a class="header-anchor" href="#foreign-keys" aria-label="Permalink to &quot;&lt;a id=&quot;topic33&quot;&gt;&lt;/a&gt;Foreign Keys&quot;">​</a></h4><p>Foreign keys are not supported. You can declare them, but referential integrity is not enforced.</p><p>Foreign key constraints specify that the values in a column or a group of columns must match the values appearing in some row of another table to maintain referential integrity between two related tables. Referential integrity checks cannot be enforced between the distributed table segments of a WarehousePG.</p><h4 id="exclusion-constraints" tabindex="-1"><a id="exclusion"></a>Exclusion Constraints <a class="header-anchor" href="#exclusion-constraints" aria-label="Permalink to &quot;&lt;a id=&quot;exclusion&quot;&gt;&lt;/a&gt;Exclusion Constraints&quot;">​</a></h4><p>Exclusion constraints ensure that if any two rows are compared on the specified columns or expressions using the specified operators, at least one of these operator comparisons will return false or null. The syntax is:</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">CREATE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> TABLE</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> circles</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">circle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    EXCLUDE </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">USING</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> gist (c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WITH</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &amp;&amp;)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">DISTRIBUTED</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> REPLICATED</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>Similar to unique constraints, an exclusion constraint is permitted only for replicated tables or when the distribution key columns are part of the constraint, with the same <code>=</code> operator as in the distribution key&#39;s hash operator class.</p><p>Exclusion constraints are not supported for partitioned tables.</p><p>See also <a href="./../../ref_guide/sql_commands/CREATE_TABLE.html">CREATE TABLE ... CONSTRAINT ... EXCLUDE</a> for details.</p><p>Adding an exclusion constraint automatically creates an index of the type specified in the constraint declaration.</p><h3 id="choosing-the-table-distribution-policy" tabindex="-1"><a id="topic34"></a>Choosing the Table Distribution Policy <a class="header-anchor" href="#choosing-the-table-distribution-policy" aria-label="Permalink to &quot;&lt;a id=&quot;topic34&quot;&gt;&lt;/a&gt;Choosing the Table Distribution Policy&quot;">​</a></h3><p>All WarehousePG tables are distributed. When you create or alter a table, you optionally specify <code>DISTRIBUTED BY</code> (hash distribution), <code>DISTRIBUTED RANDOMLY</code> (random distribution), or <code>DISTRIBUTED REPLICATED</code> (fully distributed) to determine the table row distribution.</p><blockquote><p><strong>Note</strong> The WarehousePG server configuration parameter <code>gp_create_table_random_default_distribution</code> controls the table distribution policy if the DISTRIBUTED BY clause is not specified when you create a table.</p></blockquote><p>For information about the parameter, see &quot;Server Configuration Parameters&quot; of the <em>WarehousePG Reference Guide</em>.</p><p>Consider the following points when deciding on a table distribution policy.</p><ul><li><strong>Even Data Distribution</strong> — For the best possible performance, all segments should contain equal portions of data. If the data is unbalanced or skewed, the segments with more data must work harder to perform their portion of the query processing. Choose a distribution key that is unique for each record, such as the primary key.</li><li><strong>Local and Distributed Operations</strong> — Local operations are faster than distributed operations. Query processing is fastest if the work associated with join, sort, or aggregation operations is done locally, at the segment level. Work done at the system level requires distributing tuples across the segments, which is less efficient. When tables share a common distribution key, the work of joining or sorting on their shared distribution key columns is done locally. With a random distribution policy, local join operations are not an option.</li><li><strong>Even Query Processing</strong> — For best performance, all segments should handle an equal share of the query workload. Query workload can be skewed if a table&#39;s data distribution policy and the query predicates are not well matched. For example, suppose that a sales transactions table is distributed on the customer ID column (the distribution key). If a predicate in a query references a single customer ID, the query processing work is concentrated on just one segment.</li></ul><p>The replicated table distribution policy (<code>DISTRIBUTED REPLICATED</code>) should be used only for small tables. Replicating data to every segment is costly in both storage and maintenance, and prohibitive for large fact tables. The primary use cases for replicated tables are to:</p><ul><li>remove restrictions on operations that user-defined functions can perform on segments, and</li><li>improve query performance by making it unnecessary to broadcast frequently used tables to all segments.</li></ul><blockquote><p><strong>Note</strong> The hidden system columns (<code>ctid</code>, <code>cmin</code>, <code>cmax</code>, <code>xmin</code>, <code>xmax</code>, and <code>gp_segment_id</code>) cannot be referenced in user queries on replicated tables because they have no single, unambiguous value. WarehousePG returns a <code>column does not exist</code> error for the query.</p></blockquote><h4 id="declaring-distribution-keys" tabindex="-1"><a id="topic35"></a>Declaring Distribution Keys <a class="header-anchor" href="#declaring-distribution-keys" aria-label="Permalink to &quot;&lt;a id=&quot;topic35&quot;&gt;&lt;/a&gt;Declaring Distribution Keys&quot;">​</a></h4><p><code>CREATE TABLE</code>&#39;s optional clauses <code>DISTRIBUTED BY</code>, <code>DISTRIBUTED RANDOMLY</code>, and <code>DISTRIBUTED REPLICATED</code> specify the distribution policy for a table. The default is a hash distribution policy that uses either the <code>PRIMARY KEY</code> (if the table has one) or the first column of the table as the distribution key. Columns with geometric or user-defined data types are not eligible as WarehousePG distribution key columns. If a table does not have an eligible column, WarehousePG distributes the rows randomly.</p><p>Replicated tables have no distribution key because every row is distributed to every WarehousePG segment instance.</p><p>To ensure even distribution of hash-distributed data, choose a distribution key that is unique for each record. If that is not possible, choose <code>DISTRIBUTED RANDOMLY</code>. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>=&gt; CREATE TABLE products</span></span>
<span class="line"><span>\`                        (name varchar(40),</span></span>
<span class="line"><span>                         prod_id integer,</span></span>
<span class="line"><span>                         supplier_id integer)</span></span>
<span class="line"><span>             DISTRIBUTED BY (prod_id);</span></span>
<span class="line"><span>\`</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>=&gt; CREATE TABLE random_stuff</span></span>
<span class="line"><span>\`                        (things text,</span></span>
<span class="line"><span>                         doodads text,</span></span>
<span class="line"><span>                         etc text)</span></span>
<span class="line"><span>             DISTRIBUTED RANDOMLY;</span></span>
<span class="line"><span>\`</span></span></code></pre></div><blockquote><p><strong>Important</strong> If a primary key exists, it is the default distribution key for the table. If no primary key exists, but a unique key exists, this is the default distribution key for the table.</p></blockquote><h4 id="custom-distribution-key-hash-functions" tabindex="-1"><a id="topic36"></a>Custom Distribution Key Hash Functions <a class="header-anchor" href="#custom-distribution-key-hash-functions" aria-label="Permalink to &quot;&lt;a id=&quot;topic36&quot;&gt;&lt;/a&gt;Custom Distribution Key Hash Functions&quot;">​</a></h4><p>The hash function used for hash distribution policy is defined by the hash operator class for the column&#39;s data type. As the default WarehousePG uses the data type&#39;s default hash operator class, the same operator class used for hash joins and hash aggregates, which is suitable for most use cases. However, you can declare a non-default hash operator class in the <code>DISTRIBUTED BY</code> clause.</p><p>Using a custom hash operator class can be useful to support co-located joins on a different operator than the default equality operator (<code>=</code>).</p><h5 id="example-custom-hash-operator-class" tabindex="-1"><a id="exhash"></a>Example Custom Hash Operator Class <a class="header-anchor" href="#example-custom-hash-operator-class" aria-label="Permalink to &quot;&lt;a id=&quot;exhash&quot;&gt;&lt;/a&gt;Example Custom Hash Operator Class&quot;">​</a></h5><p>This example creates a custom hash operator class for the integer data type that is used to improve query performance. The operator class compares the absolute values of integers.</p><p>Create a function and an equality operator that returns true if the absolute values of two integers are equal.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE FUNCTION abseq(int, int) RETURNS BOOL AS</span></span>
<span class="line"><span>$$</span></span>
<span class="line"><span>  begin return abs($1) = abs($2); end;</span></span>
<span class="line"><span>$$ LANGUAGE plpgsql STRICT IMMUTABLE;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>CREATE OPERATOR |=| (</span></span>
<span class="line"><span>  PROCEDURE = abseq,</span></span>
<span class="line"><span>  LEFTARG = int,</span></span>
<span class="line"><span>  RIGHTARG = int,</span></span>
<span class="line"><span>  COMMUTATOR = |=|,</span></span>
<span class="line"><span>  hashes, merges);</span></span></code></pre></div><p>Now, create a hash function and operator class that uses the operator.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE FUNCTION abshashfunc(int) RETURNS int AS</span></span>
<span class="line"><span>$$</span></span>
<span class="line"><span>  begin return hashint4(abs($1)); end;</span></span>
<span class="line"><span>$$ LANGUAGE plpgsql STRICT IMMUTABLE;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>CREATE OPERATOR CLASS abs_int_hash_ops FOR TYPE int4</span></span>
<span class="line"><span>  USING hash AS</span></span>
<span class="line"><span>  OPERATOR 1 |=|,</span></span>
<span class="line"><span>  FUNCTION 1 abshashfunc(int);</span></span></code></pre></div><p>Also, create less than and greater than operators, and a btree operator class for them. We don&#39;t need them for our queries, but the Postgres-based planner will not consider co-location of joins without them.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE FUNCTION abslt(int, int) RETURNS BOOL AS</span></span>
<span class="line"><span>$$</span></span>
<span class="line"><span>  begin return abs($1) &lt; abs($2); end;</span></span>
<span class="line"><span>$$ LANGUAGE plpgsql STRICT IMMUTABLE;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>CREATE OPERATOR |&lt;| (</span></span>
<span class="line"><span>  PROCEDURE = abslt,</span></span>
<span class="line"><span>  LEFTARG = int,</span></span>
<span class="line"><span>  RIGHTARG = int);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>CREATE FUNCTION absgt(int, int) RETURNS BOOL AS</span></span>
<span class="line"><span>$$</span></span>
<span class="line"><span>  begin return abs($1) &gt; abs($2); end;</span></span>
<span class="line"><span>$$ LANGUAGE plpgsql STRICT IMMUTABLE;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>CREATE OPERATOR |&gt;| (</span></span>
<span class="line"><span>  PROCEDURE = absgt,</span></span>
<span class="line"><span>  LEFTARG = int,</span></span>
<span class="line"><span>  RIGHTARG = int);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>CREATE FUNCTION abscmp(int, int) RETURNS int AS</span></span>
<span class="line"><span>$$</span></span>
<span class="line"><span>  begin return btint4cmp(abs($1),abs($2)); end;</span></span>
<span class="line"><span>$$ LANGUAGE plpgsql STRICT IMMUTABLE;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>CREATE OPERATOR CLASS abs_int_btree_ops FOR TYPE int4</span></span>
<span class="line"><span>  USING btree AS</span></span>
<span class="line"><span>  OPERATOR 1 |&lt;|,</span></span>
<span class="line"><span>  OPERATOR 3 |=|,</span></span>
<span class="line"><span>  OPERATOR 5 |&gt;|,</span></span>
<span class="line"><span>  FUNCTION 1 abscmp(int, int);</span></span></code></pre></div><p>Now, you can use the custom hash operator class in tables.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE TABLE atab (a int) DISTRIBUTED BY (a abs_int_hash_ops);</span></span>
<span class="line"><span>CREATE TABLE btab (b int) DISTRIBUTED BY (b abs_int_hash_ops);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>INSERT INTO atab VALUES (-1), (0), (1);</span></span>
<span class="line"><span>INSERT INTO btab VALUES (-1), (0), (1), (2);</span></span></code></pre></div><p>Queries that perform a join that use the custom equality operator <code>|=|</code> can take advantage of the co-location.</p><p>With the default integer opclass, this query requires Redistribute Motion nodes.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>EXPLAIN (COSTS OFF) SELECT a, b FROM atab, btab WHERE a = b;</span></span>
<span class="line"><span>                            QUERY PLAN</span></span>
<span class="line"><span>------------------------------------------------------------------</span></span>
<span class="line"><span> Gather Motion 4:1  (slice3; segments: 4)</span></span>
<span class="line"><span>   -&gt;  Hash Join</span></span>
<span class="line"><span>         Hash Cond: (atab.a = btab.b)</span></span>
<span class="line"><span>         -&gt;  Redistribute Motion 4:4  (slice1; segments: 4)</span></span>
<span class="line"><span>               Hash Key: atab.a</span></span>
<span class="line"><span>               -&gt;  Seq Scan on atab</span></span>
<span class="line"><span>         -&gt;  Hash</span></span>
<span class="line"><span>               -&gt;  Redistribute Motion 4:4  (slice2; segments: 4)</span></span>
<span class="line"><span>                     Hash Key: btab.b</span></span>
<span class="line"><span>                     -&gt;  Seq Scan on btab</span></span>
<span class="line"><span> Optimizer: Postgres-based planner</span></span>
<span class="line"><span>(11 rows)</span></span></code></pre></div><p>With the custom opclass, a more efficient plan is possible.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>EXPLAIN (COSTS OFF) SELECT a, b FROM atab, btab WHERE a |=| b;</span></span>
<span class="line"><span>                            QUERY PLAN                            </span></span>
<span class="line"><span>------------------------------------------------------------------</span></span>
<span class="line"><span>  Gather Motion 4:1  (slice1; segments: 4)</span></span>
<span class="line"><span>   -&gt;  Hash Join</span></span>
<span class="line"><span>         Hash Cond: (atab.a |=| btab.b)</span></span>
<span class="line"><span>         -&gt;  Seq Scan on atab</span></span>
<span class="line"><span>         -&gt;  Hash</span></span>
<span class="line"><span>               -&gt;  Seq Scan on btab</span></span>
<span class="line"><span> Optimizer: Postgres-based planner</span></span>
<span class="line"><span>(7 rows)</span></span></code></pre></div>`,71)]))}const b=s(i,[["render",o]]);export{u as __pageData,b as default};
