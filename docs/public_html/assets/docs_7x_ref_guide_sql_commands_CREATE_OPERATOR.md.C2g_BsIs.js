import{_ as a,c as t,o,ag as s}from"./chunks/framework.Ds6Eueu6.js";const m=JSON.parse('{"title":"CREATE OPERATOR","description":"","frontmatter":{},"headers":[],"relativePath":"docs/7x/ref_guide/sql_commands/CREATE_OPERATOR.md","filePath":"docs/7x/ref_guide/sql_commands/CREATE_OPERATOR.md"}'),n={name:"docs/7x/ref_guide/sql_commands/CREATE_OPERATOR.md"};function r(i,e,p,c,l,d){return o(),t("div",null,e[0]||(e[0]=[s(`<h1 id="create-operator" tabindex="-1">CREATE OPERATOR <a class="header-anchor" href="#create-operator" aria-label="Permalink to &quot;CREATE OPERATOR&quot;">​</a></h1><p>Defines a new operator.</p><h2 id="synopsis" tabindex="-1"><a id="section2"></a>Synopsis <a class="header-anchor" href="#synopsis" aria-label="Permalink to &quot;&lt;a id=&quot;section2&quot;&gt;&lt;/a&gt;Synopsis&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE OPERATOR &lt;name&gt; ( </span></span>
<span class="line"><span>       { FUNCTION | PROCEDURE } = &lt;function\\_name&gt;</span></span>
<span class="line"><span>       [, LEFTARG = &lt;left_type&gt;] [, RIGHTARG = &lt;right_type&gt;]</span></span>
<span class="line"><span>       [, COMMUTATOR = &lt;com_op&gt;] [, NEGATOR = &lt;neg_op&gt;]</span></span>
<span class="line"><span>       [, RESTRICT = &lt;res_proc&gt;] [, JOIN = &lt;join_proc&gt;]</span></span>
<span class="line"><span>       [, HASHES] [, MERGES] )</span></span></code></pre></div><h2 id="description" tabindex="-1"><a id="section3"></a>Description <a class="header-anchor" href="#description" aria-label="Permalink to &quot;&lt;a id=&quot;section3&quot;&gt;&lt;/a&gt;Description&quot;">​</a></h2><p><code>CREATE OPERATOR</code> defines a new operator. The user who defines an operator becomes its owner. If a schema name is given, then the operator is created in the specified schema. Otherwise, it is created in the current schema.</p><p>The operator name is a sequence of up to <code>NAMEDATALEN</code>-1 (63 by default) characters from the following list: <code>+ - * / &lt; &gt; = ~ ! @ # % ^ &amp; | \` ?</code>.</p><p>There are a few restrictions on your choice of name:</p><ul><li><p><code>--</code> and <code>/*</code> cannot appear anywhere in an operator name, since they will be taken as the start of a comment.</p></li><li><p>A multicharacter operator name cannot end in <code>+</code> or <code>-</code>, unless the name also contains at least one of these characters: <code>~ ! @ # % ^ &amp; | \` ?</code></p><p>For example, <code>@-</code> is an allowed operator name, but <code>*-</code> is not. This restriction allows WarehousePG to parse SQL-compliant commands without requiring spaces between tokens.</p></li><li><p>The use of <code>=&gt;</code> as an operator name is deprecated. It may be disallowed altogether in a future release.</p></li></ul><p>The operator <code>!=</code> is mapped to <code>&lt;&gt;</code> on input, so these two names are always equivalent.</p><p>At least one of <code>LEFTARG</code> and <code>RIGHTARG</code> must be defined. For binary operators, both must be defined. For right unary operators, only <code>LEFTARG</code> should be defined, while for left unary operators only <code>RIGHTARG</code> should be defined.</p><p><strong>Note:</strong> Right unary, also called postfix, operators are deprecated and may be removed in a future WarehousePG release.</p><p>The function_name function must have been previously defined using <code>CREATE FUNCTION</code>, must be <code>IMMUTABLE</code>, and must be defined to accept the correct number of arguments (either one or two) of the indicated types.</p><p>In the syntax of <code>CREATE OPERATOR</code>, the keywords <code>FUNCTION</code> and <code>PROCEDURE</code> are equivalent, but the referenced function must in any case be a function, not a procedure. The use of the keyword <code>PROCEDURE</code> here is historical and deprecated.</p><p>The other clauses specify optional operator optimization clauses. Their meaning is detailed in the PostgreSQL <a href="https://www.postgresql.org/docs/12/xoper-optimization.html" target="_blank" rel="noreferrer">Operator Optimization Information</a> documentation.</p><p>To be able to create an operator, you must have <code>USAGE</code> privilege on the argument types and the return type, as well as <code>EXECUTE</code> privilege on the underlying function. If a commutator or negator operator is specified, you must own these operators.</p><h2 id="parameters" tabindex="-1"><a id="section4"></a>Parameters <a class="header-anchor" href="#parameters" aria-label="Permalink to &quot;&lt;a id=&quot;section4&quot;&gt;&lt;/a&gt;Parameters&quot;">​</a></h2><p>name : The (optionally schema-qualified) name of the operator to be defined. Refer to the <em>Description</em> above for allowable characters. The name can be schema-qualified, for example <code>CREATE OPERATOR myschema.+ (...)</code>. If not, then the operator is created in the current schema. Two operators in the same schema can have the same name if they operate on different data types. This is called <em>overloading</em>.</p><p>function_name : The function used to implement this operator (must be an <code>IMMUTABLE</code> function).</p><p>left_type : The data type of the operator&#39;s left operand, if any. This option would be omitted for a left-unary operator.</p><p>right_type : The data type of the operator&#39;s right operand, if any. This option would be omitted for a right-unary operator.</p><p>com_op : The commutator of this operator. The optional <code>COMMUTATOR</code> clause names an operator that is the commutator of the operator being defined. We say that operator A is the commutator of operator B if (x A y) equals (y B x) for all possible input values x, y. Notice that B is also the commutator of A. For example, operators <code>&lt;</code> and <code>&gt;</code> for a particular data type are usually each others commutators, and operator + is usually commutative with itself. But operator <code>-</code> is usually not commutative with anything. The left operand type of a commutable operator is the same as the right operand type of its commutator, and vice versa. So the name of the commutator operator is all that needs to be provided in the <code>COMMUTATOR</code> clause.</p><p>neg_op : The negator of this operator. The optional <code>NEGATOR</code> clause names an operator that is the negator of the operator being defined. We say that operator A is the negator of operator B if both return Boolean results and (x A y) equals NOT (x B y) for all possible inputs x, y. Notice that B is also the negator of A. For example, <code>&lt;</code> and <code>&gt;=</code> are a negator pair for most data types. An operator&#39;s negator must have the same left and/or right operand types as the operator to be defined, so only the operator name need be given in the <code>NEGATOR</code> clause.</p><p>res_proc : The restriction selectivity estimator function for this operator. The optional <code>RESTRICT</code> names a restriction selectivity estimation function for the operator. (Note that this is a function name, not an operator name.) <code>RESTRICT</code> clauses only make sense for binary operators that return <code>boolean</code>.</p><p>join_proc : The join selectivity estimator function for this operator. The optional <code>JOIN</code> clause names a join selectivity estimation function for the operator. (Note that this is a function name, not an operator name.) <code>JOIN</code> clauses only make sense for binary operators that return <code>boolean</code>.</p><p>HASHES : Indicates this operator can support a hash join. The optional <code>HASHES</code> clause tells the system that it is permissible to use the hash join method for a join based on this operator. <code>HASHES</code> only makes sense for a binary operator that returns <code>boolean</code>. The hash join operator can only return true for pairs of left and right values that hash to the same hash code. If two values are put in different hash buckets, the join will never compare them, implicitly assuming that the result of the join operator must be false. Because of this, it never makes sense to specify <code>HASHES</code> for operators that do not represent equality.</p><p>MERGES : Indicates this operator can support a merge join. The <code>MERGES</code> clause, if present, tells the system that it is permissible to use the merge-join method for a join based on this operator. <code>MERGES</code> only makes sense for a binary operator that returns <code>boolean</code>, and in practice the operator must represent equality for some data type or pair of data types.</p><p>To give a schema-qualified operator name in com_op or the other optional arguments, use the <code>OPERATOR()</code> syntax, for example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>COMMUTATOR = OPERATOR(myschema.===) ,</span></span></code></pre></div><h2 id="notes" tabindex="-1"><a id="section5"></a>Notes <a class="header-anchor" href="#notes" aria-label="Permalink to &quot;&lt;a id=&quot;section5&quot;&gt;&lt;/a&gt;Notes&quot;">​</a></h2><p>Refer to <a href="https://www.postgresql.org/docs/12/xoper.html" target="_blank" rel="noreferrer">User-defined Operators</a> in the PostgreSQL documentation for further information.</p><p>Any functions used to implement the operator must be defined as <code>IMMUTABLE</code>.</p><p>It is not possible to specify an operator&#39;s lexical precedence in <code>CREATE OPERATOR</code>, because the parser&#39;s precedence behavior is hard-wired. See <a href="https://www.postgresql.org/docs/12/sql-syntax-lexical.html#SQL-PRECEDENCE" target="_blank" rel="noreferrer">Operator Precedence</a> in the PostgreSQL documentation for precedence details.</p><p>Use <a href="./DROP_OPERATOR.html">DROP OPERATOR</a> to delete user-defined operators from a database. Use <a href="./ALTER_OPERATOR.html">ALTER OPERATOR</a> to modify operators in a database.</p><h2 id="examples" tabindex="-1"><a id="section6"></a>Examples <a class="header-anchor" href="#examples" aria-label="Permalink to &quot;&lt;a id=&quot;section6&quot;&gt;&lt;/a&gt;Examples&quot;">​</a></h2><p>The following command defines a new operator, area-equality, for the data type <code>box</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE OPERATOR === (</span></span>
<span class="line"><span>    LEFTARG = box,</span></span>
<span class="line"><span>    RIGHTARG = box,</span></span>
<span class="line"><span>    FUNCTION = area_equal_function,</span></span>
<span class="line"><span>    COMMUTATOR = ===,</span></span>
<span class="line"><span>    NEGATOR = !==,</span></span>
<span class="line"><span>    RESTRICT = area_restriction_function,</span></span>
<span class="line"><span>    JOIN = area_join_function,</span></span>
<span class="line"><span>    HASHES, MERGES</span></span>
<span class="line"><span>);</span></span></code></pre></div><p>The following example creates an operator for adding two complex numbers. The example assumes that we have already created the definition of type <code>complex</code>. First define the function that does the work, then define the operator:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE FUNCTION complex_add(complex, complex)</span></span>
<span class="line"><span>    RETURNS complex</span></span>
<span class="line"><span>    AS &#39;filename&#39;, &#39;complex_add&#39;</span></span>
<span class="line"><span>    LANGUAGE C IMMUTABLE STRICT;</span></span>
<span class="line"><span>CREATE OPERATOR + (</span></span>
<span class="line"><span>    leftarg = complex,</span></span>
<span class="line"><span>    rightarg = complex,</span></span>
<span class="line"><span>    procedure = complex_add,</span></span>
<span class="line"><span>    commutator = +</span></span>
<span class="line"><span>);</span></span></code></pre></div><p>To use this operator in a query:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT (a + b) AS c FROM test_complex;</span></span></code></pre></div><h2 id="compatibility" tabindex="-1"><a id="section7"></a>Compatibility <a class="header-anchor" href="#compatibility" aria-label="Permalink to &quot;&lt;a id=&quot;section7&quot;&gt;&lt;/a&gt;Compatibility&quot;">​</a></h2><p><code>CREATE OPERATOR</code> is a WarehousePG extension to the SQL standard. The SQL standard does not provide for user-defined operators.</p><h2 id="see-also" tabindex="-1"><a id="section8"></a>See Also <a class="header-anchor" href="#see-also" aria-label="Permalink to &quot;&lt;a id=&quot;section8&quot;&gt;&lt;/a&gt;See Also&quot;">​</a></h2><p><a href="./CREATE_FUNCTION.html">CREATE FUNCTION</a>, <a href="./CREATE_TYPE.html">CREATE TYPE</a>, <a href="./ALTER_OPERATOR.html">ALTER OPERATOR</a>, <a href="./CREATE_OPERATOR_CLASS.html">CREATE OPERATOR CLASS</a>, <a href="./DROP_OPERATOR.html">DROP OPERATOR</a></p><p><strong>Parent topic:</strong> <a href="./../sql_commands/sql_ref.html">SQL Commands</a></p>`,46)]))}const u=a(n,[["render",r]]);export{m as __pageData,u as default};
