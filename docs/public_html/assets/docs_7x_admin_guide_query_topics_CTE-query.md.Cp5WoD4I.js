import{_ as e,c as a,o as n,ag as i}from"./chunks/framework.Ds6Eueu6.js";const u=JSON.parse('{"title":"WITH Queries (Common Table Expressions)","description":"","frontmatter":{},"headers":[],"relativePath":"docs/7x/admin_guide/query/topics/CTE-query.md","filePath":"docs/7x/admin_guide/query/topics/CTE-query.md"}'),t={name:"docs/7x/admin_guide/query/topics/CTE-query.md"};function p(l,s,o,r,h,c){return n(),a("div",null,s[0]||(s[0]=[i(`<h1 id="with-queries-common-table-expressions" tabindex="-1">WITH Queries (Common Table Expressions) <a class="header-anchor" href="#with-queries-common-table-expressions" aria-label="Permalink to &quot;WITH Queries (Common Table Expressions)&quot;">​</a></h1><hr><p>The <code>WITH</code> clause provides a way to write auxiliary statements for use in a larger query. These statements, which are often referred to as Common Table Expressions or CTEs, can be thought of as defining temporary tables that exist just for one query.</p><blockquote><p><strong>Note</strong> Limitations when using a <code>WITH</code> clause in WarehousePG include:</p><ul><li>For a <code>SELECT</code> command that includes a <code>WITH</code> clause, the clause can contain at most a single clause that modifies table data (<code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code> command).</li><li>For a data-modifying command (<code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code>) that includes a <code>WITH</code> clause, the clause can only contain a <code>SELECT</code> command; it cannot contain a data-modifying command.</li></ul></blockquote><p>By default, WarehousePG enables the <code>RECURSIVE</code> keyword for the <code>WITH</code> clause. <code>RECURSIVE</code> can be deactivated by setting the server configuration parameter <a href="./../../../ref_guide/config_params/guc-list.html">gp_recursive_cte</a> to <code>false</code>.</p><p><strong>Parent topic:</strong> <a href="./../../query/topics/query.html">SQL: Querying Data</a></p><h2 id="select-in-a-with-clause" tabindex="-1"><a id="topic_xyn_dgh_5gb"></a>SELECT in a WITH Clause <a class="header-anchor" href="#select-in-a-with-clause" aria-label="Permalink to &quot;&lt;a id=&quot;topic_xyn_dgh_5gb&quot;&gt;&lt;/a&gt;SELECT in a WITH Clause&quot;">​</a></h2><p>One use of CTEs is to break down complicated queries into simpler parts. The examples in this section show the <code>WITH</code> clause being used with a <code>SELECT</code> command. The example <code>WITH</code> clauses can be used the same manner with <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code>.</p><p>A <code>SELECT</code> command in the <code>WITH</code> clause is evaluated only once per execution of the parent query, even if it is referred to more than once by the parent query or sibling <code>WITH</code> clauses. Thus, expensive calculations that are needed in multiple places can be placed within a <code>WITH</code> clause to avoid redundant work. Another possible application is to prevent unwanted multiple evaluations of functions with side-effects. However, the other side of this coin is that the optimizer is less able to push restrictions from the parent query down into a <code>WITH</code> query than an ordinary sub-query. The <code>WITH</code> query will generally be evaluated as written, without suppression of rows that the parent query might discard afterwards. However, evaluation might stop early if the references to the query demand only a limited number of rows.</p><p>The following example query displays per-product sales totals in only the top sales regions:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>WITH regional_sales AS (</span></span>
<span class="line"><span>     SELECT region, SUM(amount) AS total_sales</span></span>
<span class="line"><span>     FROM orders</span></span>
<span class="line"><span>     GROUP BY region</span></span>
<span class="line"><span>  ), top_regions AS (</span></span>
<span class="line"><span>     SELECT region</span></span>
<span class="line"><span>     FROM regional_sales</span></span>
<span class="line"><span>     WHERE total_sales &gt; (SELECT SUM(total_sales)/10 FROM regional_sales)</span></span>
<span class="line"><span>  )</span></span>
<span class="line"><span>SELECT region,</span></span>
<span class="line"><span>    product,</span></span>
<span class="line"><span>    SUM(quantity) AS product_units,</span></span>
<span class="line"><span>    SUM(amount) AS product_sales</span></span>
<span class="line"><span>FROM orders</span></span>
<span class="line"><span>WHERE region IN (SELECT region FROM top_regions)</span></span>
<span class="line"><span>GROUP BY region, product;</span></span></code></pre></div><p>The <code>WITH</code> clause defines two auxiliary statements named <code>regional_sales</code> and <code>top_regions</code>, where the output of <code>regional_sales</code> is used in <code>top_regions</code> and the output of <code>top_regions</code> is used in the primary <code>SELECT</code> query. The query could have been written without the <code>WITH</code> clause, but would have required two levels of nested sub-<code>SELECT</code>s.</p><p>When you specify the optional <code>RECURSIVE</code> keyword, the <code>WITH</code> clause can accomplish operations not otherwise possible in standard SQL. Using <code>RECURSIVE</code>, a <code>WITH</code> query can refer to its own output. This simple example computes the sum of integers from 1 through 100:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>WITH RECURSIVE t(n) AS (</span></span>
<span class="line"><span>    VALUES (1)</span></span>
<span class="line"><span>  UNION ALL</span></span>
<span class="line"><span>    SELECT n+1 FROM t WHERE n &lt; 100</span></span>
<span class="line"><span>)</span></span>
<span class="line"><span>SELECT sum(n) FROM t;</span></span></code></pre></div><p>The general form of a recursive <code>WITH</code> query always follows the pattern of: a <em>non-recursive term</em>, followed by a <code>UNION</code> (or <code>UNION ALL</code>), and then a <em>recursive term</em>, where only the <em>recursive term</em> can contain a reference to the query output.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;non_recursive_term&gt; UNION [ ALL ] &lt;recursive_term&gt;</span></span></code></pre></div><p>A recursive <code>WITH</code> query that contains a <code>UNION [ ALL ]</code> is evaluated as follows:</p><ol><li><p>Evaluate the non-recursive term. For <code>UNION</code> (but not <code>UNION ALL</code>), discard duplicate rows. Include all remaining rows in the result of the recursive query, and also place them in a temporary <em>working table</em>.</p></li><li><p>As long as the working table is not empty, repeat these steps:</p><ol><li>Evaluate the recursive term, substituting the current contents of the working table for the recursive self-reference. For <code>UNION</code> (but not <code>UNION ALL</code>), discard duplicate rows and rows that duplicate any previous result row. Include all remaining rows in the result of the recursive query, and also place them in a temporary <em>intermediate table</em>.</li><li>Replace the contents of the <em>working table</em> with the contents of the <em>intermediate table</em>, then empty the <em>intermediate table</em>.</li></ol><blockquote><p><strong>Note</strong> While <code>RECURSIVE</code> allows queries to be specified recursively, WarehousePG evaluates such queries iteratively internally.</p></blockquote></li></ol><p>In the example above, the working table has just a single row in each step, and it takes on the values from 1 through 100 in successive steps. In the 100th step, there is no output because of the <code>WHERE</code> clause, and so the query terminates.</p><p>Recursive <code>WITH</code> queries are typically used to deal with hierarchical or tree-structured data. For example, this query locates all of the direct and indirect sub-parts of a product, given only a table that shows immediate inclusions:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>WITH RECURSIVE included_parts(sub_part, part, quantity) AS (</span></span>
<span class="line"><span>    SELECT sub_part, part, quantity FROM parts WHERE part = &#39;our_product&#39;</span></span>
<span class="line"><span>  UNION ALL</span></span>
<span class="line"><span>    SELECT p.sub_part, p.part, p.quantity * pr.quantity</span></span>
<span class="line"><span>    FROM included_parts pr, parts p</span></span>
<span class="line"><span>    WHERE p.part = pr.sub_part</span></span>
<span class="line"><span>)</span></span>
<span class="line"><span>SELECT sub_part, SUM(quantity) as total_quantity</span></span>
<span class="line"><span>FROM included_parts</span></span>
<span class="line"><span>GROUP BY sub_part;</span></span></code></pre></div><p>When working with recursive <code>WITH</code> queries, you must ensure that the recursive part of the query eventually returns no tuples, or else the query loops indefinitely.</p><p>For some queries, using <code>UNION</code> instead of <code>UNION ALL</code> can ensure that the recursive part of the query eventually returns no tuples by discarding rows that duplicate previous output rows. However, often a cycle does not involve output rows that are complete duplicates: it might be sufficient to check just one or a few fields to see if the same point has been reached before. The standard method for handling such situations is to compute an array of the visited values. For example, consider the following query that searches a table <code>graph</code> using a <code>link</code> field:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>WITH RECURSIVE search_graph(id, link, data, depth) AS (</span></span>
<span class="line"><span>    SELECT g.id, g.link, g.data, 1</span></span>
<span class="line"><span>    FROM graph g</span></span>
<span class="line"><span>  UNION ALL</span></span>
<span class="line"><span>    SELECT g.id, g.link, g.data, sg.depth + 1</span></span>
<span class="line"><span>    FROM graph g, search_graph sg</span></span>
<span class="line"><span>    WHERE g.id = sg.link</span></span>
<span class="line"><span>)</span></span>
<span class="line"><span>SELECT * FROM search_graph;</span></span></code></pre></div><p>This query loops if the <code>link</code> relationships contain cycles. Because the query requires a <code>depth</code> output, changing <code>UNION ALL</code> to <code>UNION</code> does not eliminate the looping. Instead the query needs to recognize whether it has reached the same row again while following a particular path of links. This modified query adds two columns, <code>path</code> and <code>cycle</code>, to the loop-prone query:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>WITH RECURSIVE search_graph(id, link, data, depth, path, cycle) AS (</span></span>
<span class="line"><span>    SELECT g.id, g.link, g.data, 1,</span></span>
<span class="line"><span>      ARRAY[g.id],</span></span>
<span class="line"><span>      false</span></span>
<span class="line"><span>    FROM graph g</span></span>
<span class="line"><span>  UNION ALL</span></span>
<span class="line"><span>    SELECT g.id, g.link, g.data, sg.depth + 1,</span></span>
<span class="line"><span>      path || g.id,</span></span>
<span class="line"><span>      g.id = ANY(path)</span></span>
<span class="line"><span>    FROM graph g, search_graph sg</span></span>
<span class="line"><span>    WHERE g.id = sg.link AND NOT cycle</span></span>
<span class="line"><span>)</span></span>
<span class="line"><span>SELECT * FROM search_graph;</span></span></code></pre></div><p>Aside from detecting cycles, the array value is useful in its own right since it represents the &quot;path&quot; taken to reach any particular row.</p><p>In the general case where more than one field needs to be checked to recognize a cycle, use an array of rows. For example, if we needed to compare fields <code>f1</code> and <code>f2</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>WITH RECURSIVE search_graph(id, link, data, depth, path, cycle) AS (</span></span>
<span class="line"><span>    SELECT g.id, g.link, g.data, 1,</span></span>
<span class="line"><span>      ARRAY[ROW(g.f1, g.f2)],</span></span>
<span class="line"><span>      false</span></span>
<span class="line"><span>    FROM graph g</span></span>
<span class="line"><span>  UNION ALL</span></span>
<span class="line"><span>    SELECT g.id, g.link, g.data, sg.depth + 1,</span></span>
<span class="line"><span>      path || ROW(g.f1, g.f2),</span></span>
<span class="line"><span>      ROW(g.f1, g.f2) = ANY(path)</span></span>
<span class="line"><span>    FROM graph g, search_graph sg</span></span>
<span class="line"><span>    WHERE g.id = sg.link AND NOT cycle</span></span>
<span class="line"><span>)</span></span>
<span class="line"><span>SELECT * FROM search_graph;</span></span></code></pre></div><p><strong>Tip:</strong> Omit the <code>ROW()</code> syntax in the case where only one field must be checked to recognize a cycle. This uses a simple array rather than a composite-type array, gaining efficiency.</p><p><strong>Tip:</strong> The recursive query evaluation algorithm produces its output in breadth-first search order. You can display the results in depth-first search order by making the outer query <code>ORDER BY</code> a &quot;path&quot; column constructed in this way.</p><p>A helpful technique for testing a query when you are not certain if it might loop indefinitely is to place a <code>LIMIT</code> in the parent query. For example, the following query would loop forever without the <code>LIMIT</code> clause:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>WITH RECURSIVE t(n) AS (</span></span>
<span class="line"><span>    SELECT 1</span></span>
<span class="line"><span>  UNION ALL</span></span>
<span class="line"><span>    SELECT n+1 FROM t</span></span>
<span class="line"><span>)</span></span>
<span class="line"><span>SELECT n FROM t LIMIT 100;</span></span></code></pre></div><p>This technique works because WarehousePG evaluates only as many rows of a <code>WITH</code> query as are actually fetched by the parent query. <em>Using this technique in production environments is not recommended</em>, because other systems might work differently. Also, the technique might not work if the outer query sorts the recursive <code>WITH</code> results or joins the results to another table, because in such cases the outer query will usually try to fetch all of the <code>WITH</code> query&#39;s output anyway.</p><p>A useful property of <code>WITH</code> queries is that they are normally evaluated only once per execution of the parent query, even if they are referred to more than once by the parent query or sibling <code>WITH</code> queries. Thus, expensive calculations that are needed in multiple places can be placed within a <code>WITH</code> query to avoid redundant work. Another possible application is to prevent unwanted multiple evaluations of functions with side-effects. However, the other side of this coin is that the optimizer is not able to push restrictions from the parent query down into a multiply-referenced <code>WITH</code> query, since that might affect all uses of the <code>WITH</code> query&#39;s output when it should affect only one. WarehousePG evalues the multiply-referenced <code>WITH</code> query as written, without suppression of rows that the parent query might discard afterwards. (But, as mentioned above, evaluation might stop early if the reference(s) to the query demand only a limited number of rows.)</p><p>If a <code>WITH</code> query is non-recursive and side-effect-free (that is, it is a <code>SELECT</code> containing no volatile functions) then it can be folded into the parent query, allowing joint optimization of the two query levels. By default, this happens if the parent query references the <code>WITH</code> query just once, but not if it references the <code>WITH</code> query more than once. You can override that decision by specifying <code>MATERIALIZED</code> to force separate calculation of the <code>WITH</code> query, or by specifying <code>NOT MATERIALIZED</code> to force it to be merged into the parent query. The latter choice risks duplicate computation of the <code>WITH</code> query, but it can still give a net savings if each usage of the <code>WITH</code> query needs only a small part of the <code>WITH</code> query&#39;s full output.</p><p>A simple example of these rules follows:</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WITH</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> w </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">AS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> big_table</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> w </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WHERE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 123</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>This <code>WITH</code> query will be folded, producing the same execution plan as:</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> big_table </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WHERE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 123</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>In particular, if there&#39;s an index on <code>key</code>, WarehousePG uses it to fetch just the rows having <code>key = 123</code>. On the other hand, in:</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WITH</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> w </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">AS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> big_table</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> w </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">AS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> w1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">JOIN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> w </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">AS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> w2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ON</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> w1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> w2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ref</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WHERE</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> w2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 123</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>the <code>WITH</code> query will be materialized, producing a temporary copy of <code>big_table</code> that is then joined with itself — without benefit of any index. This query will run much more efficiently if written as:</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WITH</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> w </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">AS</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> NOT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MATERIALIZED (</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> big_table</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> w </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">AS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> w1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">JOIN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> w </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">AS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> w2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ON</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> w1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> w2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ref</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WHERE</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> w2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 123</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>so that the parent query&#39;s restrictions can be applied directly to scans of <code>big_table</code>.</p><p>An example where <code>NOT MATERIALIZED</code> could be undesirable is:</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WITH</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> w </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">AS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, very_expensive_function(val) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> f </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> some_table</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> w </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">AS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> w1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">JOIN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> w </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">AS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> w2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ON</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> w1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">f</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> w2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>Here, materialization of the <code>WITH</code> query ensures that WarehousePG evaluations <code>very_expensive_function</code> only once per table row, not twice.</p><h2 id="data-modifying-statements-in-a-with-clause" tabindex="-1"><a id="topic_zg3_bgh_5gb"></a>Data-Modifying Statements in a WITH clause <a class="header-anchor" href="#data-modifying-statements-in-a-with-clause" aria-label="Permalink to &quot;&lt;a id=&quot;topic_zg3_bgh_5gb&quot;&gt;&lt;/a&gt;Data-Modifying Statements in a WITH clause&quot;">​</a></h2><p>For a <code>SELECT</code> command, you can use the data-modifying commands <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code> in a <code>WITH</code> clause. This allows you to perform several different operations in the same query.</p><p>A data-modifying statement in a <code>WITH</code> clause is run exactly once, and always to completion, independently of whether the primary query reads all (or indeed any) of the output. This is different from the rule when using <code>SELECT</code> in a <code>WITH</code> clause, the execution of a <code>SELECT</code> continues only as long as the primary query demands its output.</p><p>This simple CTE query deletes rows from <code>products</code>. The <code>DELETE</code> in the <code>WITH</code> clause deletes the specified rows from products, returning their contents by means of its <code>RETURNING</code> clause.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>WITH deleted_rows AS (</span></span>
<span class="line"><span>    DELETE FROM products</span></span>
<span class="line"><span>    WHERE</span></span>
<span class="line"><span>        &quot;date&quot; &gt;= &#39;2010-10-01&#39; AND</span></span>
<span class="line"><span>        &quot;date&quot; &lt; &#39;2010-11-01&#39;</span></span>
<span class="line"><span>    RETURNING *</span></span>
<span class="line"><span>)</span></span>
<span class="line"><span>SELECT * FROM deleted_rows;</span></span></code></pre></div><p>Data-modifying statements in a <code>WITH</code> clause must have <code>RETURNING</code> clauses, as shown in the previous example. It is the output of the <code>RETURNING</code> clause, <em>not</em> the target table of the data-modifying statement, that forms the temporary table that can be referred to by the rest of the query. If a data-modifying statement in a <code>WITH</code> lacks a <code>RETURNING</code> clause, then it forms no temporary table and cannot be referred to in the rest of the query. WarehousePG runs such a statement nonetheless.</p><p>If the optional <code>RECURSIVE</code> keyword is enabled, recursive self-references in data-modifying statements are not allowed. In some cases it is possible to work around this limitation by referring to the output of a recursive <code>WITH</code>. For example, this query would remove all direct and indirect subparts of a product:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>WITH RECURSIVE included_parts(sub_part, part) AS (</span></span>
<span class="line"><span>    SELECT sub_part, part FROM parts WHERE part = &#39;our_product&#39;</span></span>
<span class="line"><span>  UNION ALL</span></span>
<span class="line"><span>    SELECT p.sub_part, p.part</span></span>
<span class="line"><span>    FROM included_parts pr, parts p</span></span>
<span class="line"><span>    WHERE p.part = pr.sub_part</span></span>
<span class="line"><span>  )</span></span>
<span class="line"><span>DELETE FROM parts</span></span>
<span class="line"><span>  WHERE part IN (SELECT part FROM included_parts);</span></span></code></pre></div><p>The sub-statements in a <code>WITH</code> clause are run concurrently with each other and with the main query. Therefore, when using a data-modifying statement in a <code>WITH</code>, the order in which the specified updates actually happen is unpredictable. All of the statements are run wth the same <em>snapshot</em>. The effects of the statement are not visible on the target tables. This alleviates the effects of the unpredictability of the actual order of row updates, and means thats the <code>RETURNING</code> data is the only way to communicate changes between different <code>WITH</code> sub-statements and the main query.</p><p>In this example, the outer <code>SELECT</code> returns the original prices before the action of the <code>UPDATE</code> in the <code>WITH</code> clause:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>WITH t AS (</span></span>
<span class="line"><span>    UPDATE products SET price = price * 1.05</span></span>
<span class="line"><span>    RETURNING *</span></span>
<span class="line"><span>)</span></span>
<span class="line"><span>SELECT * FROM products;</span></span></code></pre></div><p>In this example, the outer <code>SELECT</code> returns the updated data:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>WITH t AS (</span></span>
<span class="line"><span>    UPDATE products SET price = price * 1.05</span></span>
<span class="line"><span>    RETURNING *</span></span>
<span class="line"><span>)</span></span>
<span class="line"><span>SELECT * FROM t;</span></span></code></pre></div><p>Updating the same row twice in a single statement is not supported. The effects of such a statement will not be predictable. Only one of the modifications takes place, but it is not easy (and sometimes not possible) to predict which modification occurs.</p><p>Any table used as the target of a data-modifying statement in a <code>WITH</code> clause must not have a conditional rule, nor an <code>ALSO</code> rule, nor an <code>INSTEAD</code> rule that expands to multiple statements.</p><h2 id="considerations" tabindex="-1"><a id="consider"></a>Considerations <a class="header-anchor" href="#considerations" aria-label="Permalink to &quot;&lt;a id=&quot;consider&quot;&gt;&lt;/a&gt;Considerations&quot;">​</a></h2><p>When constructing <code>WITH</code> queries, keep the following in mind:</p><ul><li><p><code>SELECT FOR UPDATE</code> cannot be inlined.</p></li><li><p>WarehousePG inlines multiply-referenced CTEs only when requested (by specifying <code>NOT MATERIALIZED</code>).</p></li><li><p>Multiply-referenced CTEs cannot be inlined if they contain outer self-references.</p></li><li><p>WarehousePG does not inline when the CTE includes a volatile function.</p></li><li><p>An <code>ORDER BY</code> in the subquery or CTE does not force an ordering for the whole query.</p></li><li><p>WarehousePG always materializes a CTE term in a query. Due to this:</p><ul><li>A query that should touch a small amount of data may instead read a whole table, and possibly spill to a temporary file.</li><li><code>UPDATE</code> or <code>DELETE FROM</code> statements are not permitted in a CTE term, as it acts more like a read-only temporary table than a dynamic view.</li></ul></li><li><p>While inlining is generally a huge win, there are certain boundary cases where it is not; for example, when a non-trivial expression will be inlined in multiple places.</p></li><li><p>The GPORCA query optimizer does not support <code>[NOT] MATERIALIZED</code>.</p></li></ul>`,66)]))}const k=e(t,[["render",p]]);export{u as __pageData,k as default};
