import{_ as a,c as t,o as s,ag as o}from"./chunks/framework.Ds6Eueu6.js";const m=JSON.parse('{"title":"Choosing the Table Storage Model","description":"","frontmatter":{},"headers":[],"relativePath":"docs/7x/admin_guide/ddl/ddl-storage.md","filePath":"docs/7x/admin_guide/ddl/ddl-storage.md"}'),n={name:"docs/7x/admin_guide/ddl/ddl-storage.md"};function i(l,e,p,c,d,r){return s(),t("div",null,e[0]||(e[0]=[o(`<h1 id="choosing-the-table-storage-model" tabindex="-1">Choosing the Table Storage Model <a class="header-anchor" href="#choosing-the-table-storage-model" aria-label="Permalink to &quot;Choosing the Table Storage Model&quot;">​</a></h1><hr><p>WarehousePG supports several storage models and a mix of storage models. When you create a table, you choose how to store its data. This topic explains the options for table storage and how to choose the best storage model for your workload.</p><ul><li><a href="#topic37">Heap Storage</a></li><li><a href="#topic38">Append-Optimized Storage</a></li><li><a href="#topic39">Choosing Row or Column-Oriented Storage</a></li><li><a href="#topic40">Using Compression (Append-Optimized Tables Only)</a></li><li><a href="#topic41">Checking the Compression and Distribution of an Append-Optimized Table</a></li><li><a href="#topic55">Altering a Table</a></li><li><a href="#topic62">Dropping a Table</a></li></ul><blockquote><p><strong>Note</strong> To simplify the creation of database tables, you can specify the default values for some table storage options with the WarehousePG server configuration parameter <code>gp_default_storage_options</code>.</p></blockquote><p>For information about the parameter, see &quot;Server Configuration Parameters&quot; in the <em>WarehousePG Reference Guide</em>.</p><p><strong>Parent topic:</strong> <a href="./../ddl/ddl.html">DDL: Defining Database Objects</a></p><h2 id="heap-storage" tabindex="-1"><a id="topic37"></a>Heap Storage <a class="header-anchor" href="#heap-storage" aria-label="Permalink to &quot;&lt;a id=&quot;topic37&quot;&gt;&lt;/a&gt;Heap Storage&quot;">​</a></h2><p>By default, WarehousePG uses the same heap storage model as PostgreSQL. Heap table storage works best with OLTP-type workloads where the data is often modified after it is initially loaded. <code>UPDATE</code> and <code>DELETE</code> operations require storing row-level versioning information to ensure reliable database transaction processing. Heap tables are best suited for smaller tables, such as dimension tables, that are often updated after they are initially loaded.</p><h2 id="append-optimized-storage" tabindex="-1"><a id="topic38"></a>Append-Optimized Storage <a class="header-anchor" href="#append-optimized-storage" aria-label="Permalink to &quot;&lt;a id=&quot;topic38&quot;&gt;&lt;/a&gt;Append-Optimized Storage&quot;">​</a></h2><p>Append-optimized table storage works best with denormalized fact tables in a data warehouse environment. Denormalized fact tables are typically the largest tables in the system. Fact tables are usually loaded in batches and accessed by read-only queries. Moving large fact tables to an append-optimized storage model eliminates the storage overhead of the per-row update visibility information, saving about 20 bytes per row. This allows for a leaner and easier-to-optimize page structure. The storage model of append-optimized tables is optimized for bulk data loading. Single row <code>INSERT</code> statements are not recommended.</p><h3 id="to-create-a-heap-table" tabindex="-1"><a id="im168504"></a>To create a heap table <a class="header-anchor" href="#to-create-a-heap-table" aria-label="Permalink to &quot;&lt;a id=&quot;im168504&quot;&gt;&lt;/a&gt;To create a heap table&quot;">​</a></h3><p>Row-oriented heap tables are the default storage type.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>=&gt; CREATE TABLE foo (a int, b text) DISTRIBUTED BY (a);</span></span></code></pre></div><p>Use the <code>WITH</code> clause of the <code>CREATE TABLE</code> command to declare the table storage options. The default is to create the table as a regular row-oriented heap-storage table. For example, to create an append-optimized table with no compression:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>=&gt; CREATE TABLE bar (a int, b text) </span></span>
<span class="line"><span>    WITH (appendoptimized=true)</span></span>
<span class="line"><span>    DISTRIBUTED BY (a);</span></span></code></pre></div><blockquote><p><strong>Note</strong> You use the <code>appendoptimized=value</code> syntax to specify the append-optimized table storage type. <code>appendoptimized</code> is a thin alias for the <code>appendonly</code> legacy storage option. WarehousePG stores <code>appendonly</code> in the catalog, and displays the same when listing storage options for append-optimized tables.</p></blockquote><p><code>UPDATE</code> and <code>DELETE</code> are not allowed on append-optimized tables in a repeatable read or serizalizable transaction and will cause the transaction to end prematurely. <code>DECLARE...FOR UPDATE</code> and triggers are not supported with append-optimized tables. <code>CLUSTER</code> on append-optimized tables is only supported over B-tree indexes.</p><h2 id="choosing-row-or-column-oriented-storage" tabindex="-1"><a id="topic39"></a>Choosing Row or Column-Oriented Storage <a class="header-anchor" href="#choosing-row-or-column-oriented-storage" aria-label="Permalink to &quot;&lt;a id=&quot;topic39&quot;&gt;&lt;/a&gt;Choosing Row or Column-Oriented Storage&quot;">​</a></h2><p>WarehousePG provides a choice of storage orientation models: row, column, or a combination of both. This topic provides general guidelines for choosing the optimum storage orientation for a table. Evaluate performance using your own data and query workloads.</p><ul><li>Row-oriented storage: good for OLTP types of workloads with many iterative transactions and many columns of a single row needed all at once, so retrieving is efficient.</li><li>Column-oriented storage: good for data warehouse workloads with aggregations of data computed over a small number of columns, or for single columns that require regular updates without modifying other column data.</li></ul><p>For most general purpose or mixed workloads, row-oriented storage offers the best combination of flexibility and performance. However, there are use cases where a column-oriented storage model provides more efficient I/O and storage. Consider the following requirements when deciding on the storage orientation model for a table:</p><ul><li><p><strong>Updates of table data.</strong> If you load and update the table data frequently, choose a row-orientedheap table. Column-oriented table storage is only available on append-optimized tables.</p><p>See <a href="#topic37">Heap Storage</a> for more information.</p></li><li><p><strong>Frequent INSERTs.</strong> If rows are frequently inserted into the table, consider a row-oriented model. Column-oriented tables are not optimized for write operations, as column values for a row must be written to different places on disk.</p></li><li><p><strong>Number of columns requested in queries.</strong> If you typically request all or the majority of columns in the <code>SELECT</code> list or <code>WHERE</code> clause of your queries, consider a row-oriented model. Column-oriented tables are best suited to queries that aggregate many values of a single column where the <code>WHERE</code> or <code>HAVING</code> predicate is also on the aggregate column. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT SUM(salary)...</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT AVG(salary)... WHERE salary &gt; 10000</span></span></code></pre></div><p>Or where the <code>WHERE</code> predicate is on a single column and returns a relatively small number of rows. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT salary, dept ... WHERE state=&#39;CA&#39;</span></span></code></pre></div></li><li><p><strong>Number of columns in the table.</strong> Row-oriented storage is more efficient when many columns are required at the same time, or when the row-size of a table is relatively small. Column-oriented tables can offer better query performance on tables with many columns where you access a small subset of columns in your queries.</p></li><li><p><strong>Compression.</strong> Column data has the same data type, so storage size optimizations are available in column-oriented data that are not available in row-oriented data. For example, many compression schemes use the similarity of adjacent data to compress. However, the greater adjacent compression achieved, the more difficult random access can become, as data must be uncompressed to be read.</p></li></ul><h3 id="to-create-a-column-oriented-table" tabindex="-1"><a id="im169305"></a>To create a column-oriented table <a class="header-anchor" href="#to-create-a-column-oriented-table" aria-label="Permalink to &quot;&lt;a id=&quot;im169305&quot;&gt;&lt;/a&gt;To create a column-oriented table&quot;">​</a></h3><p>The <code>WITH</code> clause of the <code>CREATE TABLE</code> command specifies the table&#39;s storage options. The default is a row-orientedheap table. Tables that use column-oriented storage must be append-optimized tables. For example, to create a column-oriented table:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>=&gt; CREATE TABLE bar (a int, b text) </span></span>
<span class="line"><span>    WITH (appendoptimized=true, orientation=column)</span></span>
<span class="line"><span>    DISTRIBUTED BY (a);</span></span></code></pre></div><h2 id="using-compression-append-optimized-tables-only" tabindex="-1"><a id="topic40"></a>Using Compression (Append-Optimized Tables Only) <a class="header-anchor" href="#using-compression-append-optimized-tables-only" aria-label="Permalink to &quot;&lt;a id=&quot;topic40&quot;&gt;&lt;/a&gt;Using Compression \\(Append-Optimized Tables Only\\)&quot;">​</a></h2><p>There are two types of in-database compression available in the WarehousePG for append-optimized tables:</p><ul><li>Table-level compression is applied to an entire table.</li><li>Column-level compression is applied to a specific column. You can apply different column-level compression algorithms to different columns.</li></ul><p>The following table summarizes the available compression algorithms.</p><table tabindex="0"><thead><tr><th>Table Orientation</th><th>Available Compression Types</th><th>Supported Algorithms</th></tr></thead><tbody><tr><td>Row</td><td>Table</td><td><code>ZLIB</code> and <code>ZSTD</code></td></tr><tr><td>Column</td><td>Column and Table</td><td><code>RLE_TYPE</code>, <code>ZLIB</code>, and <code>ZSTD</code></td></tr></tbody></table><p>When choosing a compression type and level for append-optimized tables, consider these factors:</p><ul><li><p>CPU usage. Your segment systems must have the available CPU power to compress and uncompress the data.</p></li><li><p>Compression ratio/disk size. Minimizing disk size is one factor, but also consider the time and CPU capacity required to compress and scan data. Find the optimal settings for efficiently compressing data without causing excessively long compression times or slow scan rates.</p></li><li><p>Speed of compression. Higher compression levels can yield different compression ratios (always at the cost of speed). This varies by compression type: <code>ZLIB</code> versus <code>ZTSD</code>.</p></li><li><p>Speed of decompression/scan rate. Performance with compressed append-optimized tables depends on hardware, query tuning settings, and other factors. Perform comparison testing to determine the actual performance in your environment.</p><blockquote><p><strong>Note</strong> Do not create compressed append-optimized tables on file systems that use compression. If the file system on which your segment data directory resides is a compressed file system, your append-optimized table must not use compression.</p></blockquote></li></ul><p>Performance with compressed append-optimized tables depends on hardware, query tuning settings, and other factors. You should perform comparison testing to determine the actual performance in your environment.</p><blockquote><p><strong>Note</strong> <code>ZTSD</code> compression level can be set to values between 1 and 19. Compression level with <code>ZLIB</code> can be set to values from 1 - 9. Compression level with <code>RLE</code> can be set to values from 1 - 4.</p></blockquote><p>An <code>ENCODING</code> clause specifies compression type and level for individual columns. When an <code>ENCODING</code> clause conflicts with a <code>WITH</code> clause, the <code>ENCODING</code> clause has higher precedence than the <code>WITH</code> clause.</p><h3 id="to-create-a-compressed-table" tabindex="-1"><a id="im159764"></a>To create a compressed table <a class="header-anchor" href="#to-create-a-compressed-table" aria-label="Permalink to &quot;&lt;a id=&quot;im159764&quot;&gt;&lt;/a&gt;To create a compressed table&quot;">​</a></h3><p>The <code>WITH</code> clause of the <code>CREATE TABLE</code> command declares the table storage options. Tables that use compression must be append-optimized tables. For example, to create an append-optimized table with zlib compression at a compression level of 5:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>=&gt; CREATE TABLE foo (a int, b text) </span></span>
<span class="line"><span>   WITH (appendoptimized=true, compresstype=zlib, compresslevel=5);</span></span></code></pre></div><h2 id="checking-the-compression-and-distribution-of-an-append-optimized-table" tabindex="-1"><a id="topic41"></a>Checking the Compression and Distribution of an Append-Optimized Table <a class="header-anchor" href="#checking-the-compression-and-distribution-of-an-append-optimized-table" aria-label="Permalink to &quot;&lt;a id=&quot;topic41&quot;&gt;&lt;/a&gt;Checking the Compression and Distribution of an Append-Optimized Table&quot;">​</a></h2><p>WarehousePG provides built-in functions to check the compression ratio and the distribution of an append-optimized table. The functions take either the object ID or a table name. You can qualify the table name with a schema name.</p><table class="table" id="topic41__im161827"><caption><span class="table--title-label">Table 2. </span><span class="title">Functions for compressed append-optimized table metadata</span></caption><colgroup><col style="width:183pt;"><col style="width:98pt;"><col style="width:169pt;"></colgroup><thead class="thead"><tr class="row"><th class="entry" id="topic41__im161827__entry__1">Function</th><th class="entry" id="topic41__im161827__entry__2">Return Type</th><th class="entry" id="topic41__im161827__entry__3">Description</th></tr></thead><tbody class="tbody"><tr class="row"><td class="entry" headers="topic41__im161827__entry__1">get_ao_distribution(name)<p class="p">get_ao_distribution(oid)</p></td><td class="entry" headers="topic41__im161827__entry__2">Set of (dbid, tuplecount) rows</td><td class="entry" headers="topic41__im161827__entry__3">Shows the distribution of an append-optimized table&#39;s rows across the array. Returns a set of rows, each of which includes a segment <em class="ph i">dbid</em> and the number of tuples stored on the segment.</td></tr><tr class="row"><td class="entry" headers="topic41__im161827__entry__1">get_ao_compression_ratio(name)<p class="p">get_ao_compression_ratio(oid)</p></td><td class="entry" headers="topic41__im161827__entry__2">float8</td><td class="entry" headers="topic41__im161827__entry__3">Calculates the compression ratio for a compressed append-optimized table. If information is not available, this function returns a value of -1.</td></tr></tbody></table><p>The compression ratio is returned as a common ratio. For example, a returned value of <code>3.19</code>, or <code>3.19:1</code>, means that the uncompressed table is slightly larger than three times the size of the compressed table.</p><p>The distribution of the table is returned as a set of rows that indicate how many tuples are stored on each segment. For example, in a system with four primary segments with <em>dbid</em> values ranging from 0 - 3, the function returns four rows similar to the following:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>=# SELECT get_ao_distribution(&#39;lineitem_comp&#39;);</span></span>
<span class="line"><span> get_ao_distribution</span></span>
<span class="line"><span>---------------------</span></span>
<span class="line"><span>(0,7500721)</span></span>
<span class="line"><span>(1,7501365)</span></span>
<span class="line"><span>(2,7499978)</span></span>
<span class="line"><span>(3,7497731)</span></span>
<span class="line"><span>(4 rows)</span></span></code></pre></div><h2 id="support-for-run-length-encoding" tabindex="-1"><a id="topic42"></a>Support for Run-length Encoding <a class="header-anchor" href="#support-for-run-length-encoding" aria-label="Permalink to &quot;&lt;a id=&quot;topic42&quot;&gt;&lt;/a&gt;Support for Run-length Encoding&quot;">​</a></h2><p>WarehousePG supports Run-length Encoding (RLE) for column-level compression. RLE data compression stores repeated data as a single data value and a count. For example, in a table with two columns, a date and a description, that contains 200,000 entries containing the value <code>date1</code> and 400,000 entries containing the value <code>date2</code>, RLE compression for the date field is similar to <code>date1 200000 date2 400000</code>. RLE is not useful with files that do not have large sets of repeated data as it can greatly increase the file size.</p><p>There are four levels of RLE compression available. The levels progressively increase the compression ratio, but decrease the compression speed.</p><p>WarehousePG versions 4.2.1 and later support column-oriented RLE compression. To back up a table with RLE compression that you intend to restore to an earlier version of WarehousePG, alter the table to have no compression or a compression type supported in the earlier version before you start the backup operation.</p><p>WarehousePG combines delta compression with RLE compression for data in columns of type <code>BIGINT</code>, <code>INTEGER</code>, <code>DATE</code>, <code>TIME</code>, or <code>TIMESTAMP</code>. The delta compression algorithm is based on the change between consecutive column values and is designed to improve compression when data is loaded in sorted order or when the compression is applied to data in sorted order.</p><h2 id="adding-column-level-compression" tabindex="-1"><a id="topic43"></a>Adding Column-level Compression <a class="header-anchor" href="#adding-column-level-compression" aria-label="Permalink to &quot;&lt;a id=&quot;topic43&quot;&gt;&lt;/a&gt;Adding Column-level Compression&quot;">​</a></h2><p>You can add the following storage parameters to a column for append-optimized tables with column orientation:</p><ul><li>Compression type</li><li>Compression level</li><li>Block size for a column</li></ul><p>Add storage parameters using the <code>CREATE TABLE</code>, <code>ALTER TABLE</code>, and <code>CREATE TYPE</code> commands.</p><p>The following table details the types of storage parameters and possible values for each.</p><table class="table" id="topic43__im198636"><caption><span class="table--title-label">Table 3. </span><span class="title">Storage Parameters for Column-level Compression</span></caption><colgroup><col style="width:87pt;"><col style="width:95pt;"><col style="width:147pt;"><col style="width:167.25pt;"></colgroup><thead class="thead"><tr class="row"><th class="entry" id="topic43__im198636__entry__1">Name</th><th class="entry" id="topic43__im198636__entry__2">Definition</th><th class="entry" id="topic43__im198636__entry__3">Values</th><th class="entry" id="topic43__im198636__entry__4">Comment</th></tr></thead><tbody class="tbody"><tr class="row"><td class="entry" headers="topic43__im198636__entry__1"><code class="ph codeph">compresstype</code></td><td class="entry" headers="topic43__im198636__entry__2">Type of compression.</td><td class="entry" headers="topic43__im198636__entry__3"><code class="ph codeph">zstd: </code>Zstandard algorithm<p class="p"><code class="ph codeph">zlib: </code>deflate algorithm</p><p class="p"><code class="ph codeph">RLE_TYPE</code>: run-length encoding </p><p class="p"><code class="ph codeph">none</code>: no compression</p></td><td class="entry" headers="topic43__im198636__entry__4">Values are not case-sensitive.</td></tr><tr class="row"><td class="entry" headers="topic43__im198636__entry__1" rowspan="4"><code class="ph codeph">compresslevel</code></td><td class="entry" headers="topic43__im198636__entry__2" rowspan="4">Compression level.</td><td class="entry" headers="topic43__im198636__entry__3"><code class="ph codeph">zlib</code> compression: <code class="ph codeph">1</code>-<code class="ph codeph">9</code></td><td class="entry" headers="topic43__im198636__entry__4"><code class="ph codeph">1</code> is the fastest method with the least compression. <code class="ph codeph">1</code> is the default.<p class="p"><code class="ph codeph">9</code> is the slowest method with the most compression.</p></td></tr><tr class="row"><td class="entry" headers="topic43__im198636__entry__3"><code class="ph codeph">zstd</code> compression: <code class="ph codeph">1</code>-<code class="ph codeph">19</code></td><td class="entry" headers="topic43__im198636__entry__4"><code class="ph codeph">1</code> is the fastest method with the least compression. <code class="ph codeph">1</code> is the default.<p class="p"><code class="ph codeph">19</code> is the slowest method with the most compression.</p></td></tr><tr class="row"><td class="entry" headers="topic43__im198636__entry__3"><code class="ph codeph">RLE_TYPE</code> compression: <code class="ph codeph">1</code> – <code class="ph codeph">6</code><p class="p"><code class="ph codeph">1</code> - apply RLE only</p><p class="p"><code class="ph codeph">2</code> - apply RLE then apply zlib compression level 1</p><p class="p"><code class="ph codeph">3</code> - apply RLE then apply zlib compression level 5</p><p class="p"><code class="ph codeph">4</code> - apply RLE then apply zlib compression level 9</p><p class="p"><code class="ph codeph">5</code> - apply RLE then apply zstd compression level 1</p><p class="p"><code class="ph codeph">6</code> - apply RLE then apply zstd compression level 3</p></td><td class="entry" headers="topic43__im198636__entry__4"><code class="ph codeph">1</code> is the fastest method with the least compression.<p class="p"><code class="ph codeph">1</code> is the default method. Within each compression sub-type (RLE with zlib or RLE with zstd), higher compression levels yield higher compression ratios at the cost of speed. Since zstd outperforms zlib in terms of compression ratios and speed, we highly recommend using levels 5 or above.</p></td></tr><tr class="row"><td class="entry" headers="topic43__im198636__entry__1"><code class="ph codeph">blocksize</code></td><td class="entry" headers="topic43__im198636__entry__2">The size in bytes for each block in the table</td><td class="entry" headers="topic43__im198636__entry__3"><code class="ph codeph">8192 – 2097152</code></td><td class="entry" headers="topic43__im198636__entry__4">The value must be a multiple of 8192.</td></tr></tbody></table><p>The following is the format for adding storage parameters.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[ ENCODING ( &lt;storage_parameter [,…] ) ]</span></span></code></pre></div><p>where the word ENCODING is required and the storage parameter has three parts:</p><ul><li>The name of the parameter</li><li>An equals sign</li><li>The specification</li></ul><p>Separate multiple storage parameters with a comma. Apply a storage parameter to a single column or designate it as the default for all columns, as shown in the following <code>CREATE TABLE</code> clauses.</p><p><em>General Usage:</em></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;column_name&gt; &lt;data_type&gt; ENCODING ( &lt;storage_directive&gt; [, … ] ), …</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>COLUMN &lt;column_name&gt; ENCODING ( &lt;storage_directive&gt; [, … ] ), …</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>DEFAULT COLUMN ENCODING ( &lt;storage_directive&gt; [, … ] )</span></span></code></pre></div><p><em>Example:</em></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>C1 char ENCODING (compresstype=zstd, blocksize=65536)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>COLUMN C1 ENCODING (compresstype=zlib, compresslevel=6, blocksize=65536)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>DEFAULT COLUMN ENCODING (compresstype=zlib)</span></span></code></pre></div><h3 id="default-compression-values" tabindex="-1"><a id="topic44"></a>Default Compression Values <a class="header-anchor" href="#default-compression-values" aria-label="Permalink to &quot;&lt;a id=&quot;topic44&quot;&gt;&lt;/a&gt;Default Compression Values&quot;">​</a></h3><p>If the compression type, compression level and block size are not defined, the default is no compression, and the block size is set to the Server Configuration Parameter <code>block_size</code>.</p><h3 id="precedence-of-compression-settings" tabindex="-1"><a id="topic45"></a>Precedence of Compression Settings <a class="header-anchor" href="#precedence-of-compression-settings" aria-label="Permalink to &quot;&lt;a id=&quot;topic45&quot;&gt;&lt;/a&gt;Precedence of Compression Settings&quot;">​</a></h3><p>Column compression settings are inherited from the type level to the table level to the partition level to the sub-partition level. The lowest-level settings have priority.</p><ul><li>Column compression settings defined at the table level override any compression settings for the type.</li><li>Column compression settings specified at the table level override any compression settings for the entire table.</li><li>Column compression settings specified for partitions override any compression settings at the column or table levels.</li><li>Column compression settings specified for sub-partitions override any compression settings at the partition, column or table levels.</li><li>When an <code>ENCODING</code> clause conflicts with a <code>WITH</code> clause, the <code>ENCODING</code> clause has higher precedence than the <code>WITH</code> clause.</li></ul><blockquote><p><strong>Note</strong> The <code>INHERITS</code> clause is not allowed in a table that contains a storage parameter or a column reference storage parameter.</p></blockquote><p>Tables created using the <code>LIKE</code> clause ignore storage parameter and column reference storage parameters.</p><h3 id="optimal-location-for-column-compression-settings" tabindex="-1"><a id="topic46"></a>Optimal Location for Column Compression Settings <a class="header-anchor" href="#optimal-location-for-column-compression-settings" aria-label="Permalink to &quot;&lt;a id=&quot;topic46&quot;&gt;&lt;/a&gt;Optimal Location for Column Compression Settings&quot;">​</a></h3><p>The best practice is to set the column compression settings at the level where the data resides. See <a href="#topic52">Example 5</a>, which shows a table with a partition depth of 2. <code>RLE_TYPE</code> compression is added to a column at the sub-partition level.</p><h3 id="storage-parameters-examples" tabindex="-1"><a id="topic47"></a>Storage Parameters Examples <a class="header-anchor" href="#storage-parameters-examples" aria-label="Permalink to &quot;&lt;a id=&quot;topic47&quot;&gt;&lt;/a&gt;Storage Parameters Examples&quot;">​</a></h3><p>The following examples show the use of storage parameters in <code>CREATE TABLE</code> statements.</p><h4 id="example-1" tabindex="-1"><a id="topic48"></a>Example 1 <a class="header-anchor" href="#example-1" aria-label="Permalink to &quot;&lt;a id=&quot;topic48&quot;&gt;&lt;/a&gt;Example 1&quot;">​</a></h4><p>In this example, column <code>c1</code> is compressed using <code>zstd</code> and uses the block size defined by the system. Column <code>c2</code> is compressed with <code>zlib</code>, and uses a block size of <code>65536</code>. Column <code>c3</code> is not compressed and uses the block size defined by the system.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE TABLE T1 (c1 int ENCODING (compresstype=zstd),</span></span>
<span class="line"><span>                  c2 char ENCODING (compresstype=zlib, blocksize=65536),</span></span>
<span class="line"><span>                  c3 char)    WITH (appendoptimized=true, orientation=column);</span></span></code></pre></div><h4 id="example-2" tabindex="-1"><a id="topic49"></a>Example 2 <a class="header-anchor" href="#example-2" aria-label="Permalink to &quot;&lt;a id=&quot;topic49&quot;&gt;&lt;/a&gt;Example 2&quot;">​</a></h4><p>In this example, column <code>c1</code> is compressed using <code>zlib</code> and uses the block size defined by the system. Column <code>c2</code> is compressed with <code>zstd</code>, and uses a block size of <code>65536</code>. Column <code>c3</code> is compressed using <code>RLE_TYPE</code> and uses the block size defined by the system.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE TABLE T2 (c1 int ENCODING (compresstype=zlib),</span></span>
<span class="line"><span>                  c2 char ENCODING (compresstype=zstd, blocksize=65536),</span></span>
<span class="line"><span>                  c3 char,</span></span>
<span class="line"><span>                  COLUMN c3 ENCODING (compresstype=RLE_TYPE)</span></span>
<span class="line"><span>                  )</span></span>
<span class="line"><span>    WITH (appendoptimized=true, orientation=column);</span></span></code></pre></div><h4 id="example-3" tabindex="-1"><a id="topic50"></a>Example 3 <a class="header-anchor" href="#example-3" aria-label="Permalink to &quot;&lt;a id=&quot;topic50&quot;&gt;&lt;/a&gt;Example 3&quot;">​</a></h4><p>In this example, column <code>c1</code> is compressed using <code>zlib</code> and uses the block size defined by the system. Column <code>c2</code> is compressed with <code>zstd</code>, and uses a block size of <code>65536</code>. Column <code>c3</code> is compressed using <code>zlib</code> and uses the block size defined by the system. Note that column <code>c3</code> uses <code>zlib</code> (not <code>RLE_TYPE</code>) in the partitions, because the column storage in the partition clause has precedence over the storage parameter in the column definition for the table.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE TABLE T3 (c1 int ENCODING (compresstype=zlib),</span></span>
<span class="line"><span>                  c2 char ENCODING (compresstype=zstd, blocksize=65536),</span></span>
<span class="line"><span>                  c3 text, COLUMN c3 ENCODING (compresstype=RLE_TYPE) )</span></span>
<span class="line"><span>    WITH (appendoptimized=true, orientation=column)</span></span>
<span class="line"><span>    PARTITION BY RANGE (c3) (START (&#39;1900-01-01&#39;::DATE)          </span></span>
<span class="line"><span>                             END (&#39;2100-12-31&#39;::DATE),</span></span>
<span class="line"><span>                             COLUMN c3 ENCODING (compresstype=zlib));</span></span></code></pre></div><h4 id="example-4" tabindex="-1"><a id="topic51"></a>Example 4 <a class="header-anchor" href="#example-4" aria-label="Permalink to &quot;&lt;a id=&quot;topic51&quot;&gt;&lt;/a&gt;Example 4&quot;">​</a></h4><p>In this example, <code>CREATE TABLE</code> assigns the <code>zlib</code> <code>compresstype</code> storage parameter to <code>c1</code>. Column <code>c2</code> has no storage parameter and inherits the compression type (<code>zstd</code>) and block size (<code>65536</code>) from the <code>DEFAULT COLUMN ENCODING</code> clause.</p><p>Column <code>c3</code>&#39;s <code>ENCODING</code> clause defines its compression type, <code>RLE_TYPE</code>. The <code>ENCODING</code> clause defined for a specific column overrides the <code>DEFAULT ENCODING</code> clause, so column <code>c3</code> uses the default block size, <code>32768</code>.</p><p>Column <code>c4</code> has a compress type of <code>none</code> and uses the default block size.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE TABLE T4 (c1 int ENCODING (compresstype=zlib),</span></span>
<span class="line"><span>                  c2 char,</span></span>
<span class="line"><span>                  c3 text,</span></span>
<span class="line"><span>                  c4 smallint ENCODING (compresstype=none),</span></span>
<span class="line"><span>                  DEFAULT COLUMN ENCODING (compresstype=zstd,</span></span>
<span class="line"><span>                                             blocksize=65536),</span></span>
<span class="line"><span>                  COLUMN c3 ENCODING (compresstype=RLE_TYPE)</span></span>
<span class="line"><span>                  ) </span></span>
<span class="line"><span>   WITH (appendoptimized=true, orientation=column);</span></span></code></pre></div><h4 id="example-5" tabindex="-1"><a id="topic52"></a>Example 5 <a class="header-anchor" href="#example-5" aria-label="Permalink to &quot;&lt;a id=&quot;topic52&quot;&gt;&lt;/a&gt;Example 5&quot;">​</a></h4><p>This example creates an append-optimized, column-oriented table, T5. T5 has two partitions, <code>p1</code> and <code>p2</code>, each of which has sub-partitions. Each sub-partition has <code>ENCODING</code> clauses:</p><ul><li><p>The <code>ENCODING</code> clause for partition <code>p1</code>&#39;s sub-partition <code>sp1</code> defines column <code>i</code>&#39;s compression type as <code>zlib</code> and block size as 65536.</p></li><li><p>The <code>ENCODING</code> clauses for partition <code>p2</code>&#39;s sub-partition <code>sp1</code> defines column <code>i</code>&#39;s compression type as <code>rle_type</code> and block size is the default value. Column <code>k</code> uses the default compression and its block size is 8192.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE TABLE T5(i int, j int, k int, l int) </span></span>
<span class="line"><span>    WITH (appendoptimized=true, orientation=column)</span></span>
<span class="line"><span>    PARTITION BY range(i) SUBPARTITION BY range(j)</span></span>
<span class="line"><span>    (</span></span>
<span class="line"><span>       partition p1 start(1) end(2)</span></span>
<span class="line"><span>       ( subpartition sp1 start(1) end(2) </span></span>
<span class="line"><span>         column i encoding(compresstype=zlib, blocksize=65536)</span></span>
<span class="line"><span>       ), </span></span>
<span class="line"><span>       partition p2 start(2) end(3)</span></span>
<span class="line"><span>       ( subpartition sp1 start(1) end(2)</span></span>
<span class="line"><span>           column i encoding(compresstype=rle_type)</span></span>
<span class="line"><span>           column k encoding(blocksize=8192)</span></span>
<span class="line"><span>       )</span></span>
<span class="line"><span>    );</span></span></code></pre></div></li></ul><p>For an example showing how to add a compressed column to an existing table with the <code>ALTER TABLE</code> command, see <a href="#topic60">Adding a Compressed Column to Table</a>.</p><h3 id="adding-compression-in-a-type-command" tabindex="-1"><a id="topic53"></a>Adding Compression in a TYPE Command <a class="header-anchor" href="#adding-compression-in-a-type-command" aria-label="Permalink to &quot;&lt;a id=&quot;topic53&quot;&gt;&lt;/a&gt;Adding Compression in a TYPE Command&quot;">​</a></h3><p>When you create a new type, you can define default compression attributes for the type. For example, the following <code>CREATE TYPE</code> command defines a type named <code>int33</code> that specifies <code>zlib</code> compression.</p><p>First, you must define the input and output functions for the new type, <code>int33_in</code> and <code>int33_out</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE FUNCTION int33_in(cstring) RETURNS int33</span></span>
<span class="line"><span>  STRICT IMMUTABLE LANGUAGE internal AS &#39;int4in&#39;;</span></span>
<span class="line"><span>CREATE FUNCTION int33_out(int33) RETURNS cstring</span></span>
<span class="line"><span>  STRICT IMMUTABLE LANGUAGE internal AS &#39;int4out&#39;;</span></span></code></pre></div><p>Next, you define the type named <code>int33</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE TYPE int33 (</span></span>
<span class="line"><span>   internallength = 4,</span></span>
<span class="line"><span>   input = int33_in,</span></span>
<span class="line"><span>   output = int33_out,</span></span>
<span class="line"><span>   alignment = int4,</span></span>
<span class="line"><span>   default = 123,</span></span>
<span class="line"><span>   passedbyvalue,</span></span>
<span class="line"><span>   compresstype=&quot;zlib&quot;,</span></span>
<span class="line"><span>   blocksize=65536,</span></span>
<span class="line"><span>   compresslevel=1</span></span>
<span class="line"><span>   );</span></span></code></pre></div><p>When you specify <code>int33</code> as a column type in a <code>CREATE TABLE</code> command, the column is created with the storage parameters you specified for the type:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE TABLE t2 (c1 int33)</span></span>
<span class="line"><span>    WITH (appendoptimized=true, orientation=column);</span></span></code></pre></div><p>Table- or column- level storage attributes that you specify in a table definition override type-level storage attributes. For information about creating and adding compression attributes to a type, see <a href="./../../ref_guide/sql_commands/CREATE_TYPE.html">CREATE TYPE</a>. For information about changing compression specifications in a type, see <a href="./../../ref_guide/sql_commands/ALTER_TYPE.html">ALTER TYPE</a>.</p><h4 id="choosing-block-size" tabindex="-1"><a id="topic54"></a>Choosing Block Size <a class="header-anchor" href="#choosing-block-size" aria-label="Permalink to &quot;&lt;a id=&quot;topic54&quot;&gt;&lt;/a&gt;Choosing Block Size&quot;">​</a></h4><p>The blocksize is the size, in bytes, for each block in a table. Block sizes must be between 8192 and 2097152 bytes, and be a multiple of 8192. The default is 32768.</p><p>Specifying large block sizes can consume large amounts of memory. Block size determines buffering in the storage layer. WarehousePG maintains a buffer per partition, and per column in column-oriented tables. Tables with many partitions or columns consume large amounts of memory.</p><h2 id="altering-a-table" tabindex="-1"><a id="topic55"></a>Altering a Table <a class="header-anchor" href="#altering-a-table" aria-label="Permalink to &quot;&lt;a id=&quot;topic55&quot;&gt;&lt;/a&gt;Altering a Table&quot;">​</a></h2><p>The <code>ALTER TABLE</code> command changes the definition of a table. Use <code>ALTER TABLE</code> to change table attributes such as column definitions, distribution policy, access method, storage parameters, and partition structure (see also <a href="./ddl-partition.html">Partitioning Large Tables</a>). For example, to add a not-null constraint to a table column:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>=&gt; ALTER TABLE address ALTER COLUMN street SET NOT NULL;</span></span></code></pre></div><h3 id="altering-table-distribution" tabindex="-1"><a id="topic56"></a>Altering Table Distribution <a class="header-anchor" href="#altering-table-distribution" aria-label="Permalink to &quot;&lt;a id=&quot;topic56&quot;&gt;&lt;/a&gt;Altering Table Distribution&quot;">​</a></h3><p><code>ALTER TABLE</code> provides options to change a table&#39;s distribution policy. When the table distribution options change, the table data may be redistributed on disk, which can be resource intensive. You can also redistribute table data using the existing distribution policy.</p><h3 id="changing-the-distribution-policy" tabindex="-1"><a id="topic57"></a>Changing the Distribution Policy <a class="header-anchor" href="#changing-the-distribution-policy" aria-label="Permalink to &quot;&lt;a id=&quot;topic57&quot;&gt;&lt;/a&gt;Changing the Distribution Policy&quot;">​</a></h3><p>For partitioned tables, changes to the distribution policy apply recursively to the child partitions. This operation preserves the ownership and all other attributes of the table. For example, the following command redistributes the table sales across all segments using the customer_id column as the distribution key:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ALTER TABLE sales SET DISTRIBUTED BY (customer_id);</span></span></code></pre></div><p>When you change the hash distribution of a table, table data is automatically redistributed. Changing the distribution policy to a random distribution does not cause the data to be redistributed. For example, the following <code>ALTER TABLE</code> command has no immediate effect:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ALTER TABLE sales SET DISTRIBUTED RANDOMLY;</span></span></code></pre></div><p>Changing the distribution policy of a table to <code>DISTRIBUTED REPLICATED</code> or from <code>DISTRIBUTED REPLICATED</code> automatically redistributes the table data.</p><h3 id="redistributing-table-data" tabindex="-1"><a id="topic58"></a>Redistributing Table Data <a class="header-anchor" href="#redistributing-table-data" aria-label="Permalink to &quot;&lt;a id=&quot;topic58&quot;&gt;&lt;/a&gt;Redistributing Table Data&quot;">​</a></h3><p>To redistribute table data for tables with a random distribution policy (or when the hash distribution policy has not changed) use <code>REORGANIZE=TRUE</code>. Reorganizing data may be necessary to correct a data skew problem, or when segment resources are added to the system. For example, the following command redistributes table data across all segments using the current distribution policy, including random distribution.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ALTER TABLE sales SET WITH (REORGANIZE=TRUE);</span></span></code></pre></div><p>Changing the distribution policy of a table to <code>DISTRIBUTED REPLICATED</code> or from <code>DISTRIBUTED REPLICATED</code> always redistributes the table data, even when you use <code>REORGANIZE=FALSE</code>.</p><h3 id="altering-the-table-access-method" tabindex="-1"><a id="access_method"></a>Altering the Table Access Method <a class="header-anchor" href="#altering-the-table-access-method" aria-label="Permalink to &quot;&lt;a id=&quot;access_method&quot;&gt;&lt;/a&gt;Altering the Table Access Method&quot;">​</a></h3><p>You may alter the method for accessing a table using the <code>SET ACCESS METHOD</code> clause. Set to <code>heap</code> to alter the table to be a heap-storage table, <code>ao_row</code> to alter the table to be append-optimized with row-oriented storage (AO), or <code>ao_column</code> to alter the table to be append-optimized with column-oriented storage (AOCO).</p><p class="note"><strong>Note:</strong> Although you can specify the table&#39;s access method using <code>SET &lt;storage_parameter&gt;</code> or <code>SET WITH&lt;storage_parameter&gt;</code>, WarehousePG recommends that you use <code>SET ACCESS METHOD &lt;access_method&gt;</code> instead. </p><h3 id="altering-the-table-storage-model" tabindex="-1"><a id="topic59"></a>Altering the Table Storage Model <a class="header-anchor" href="#altering-the-table-storage-model" aria-label="Permalink to &quot;&lt;a id=&quot;topic59&quot;&gt;&lt;/a&gt;Altering the Table Storage Model&quot;">​</a></h3><p>You may dynamically update a table&#39;s storage model -- including whether the table is heap, AO or AOCO; the table&#39;s compression and blocksize settings; and the table&#39;s fillfactor; -- by setting a variety of storage parameters when you invoke <code>ALTER TABLE</code> with the <code>SET &lt;storage_parameter&gt;</code> clause. This is true for both regular tables and partitioned tables.</p><h4 id="inheritance-rules-for-altering-a-partitioned-table-s-storage-model" tabindex="-1"><a id="storage_model_partition"></a>Inheritance Rules for Altering a Partitioned Table&#39;s Storage Model <a class="header-anchor" href="#inheritance-rules-for-altering-a-partitioned-table-s-storage-model" aria-label="Permalink to &quot;&lt;a id=&quot;storage_model_partition&quot;&gt;&lt;/a&gt;Inheritance Rules for Altering a Partitioned Table&#39;s Storage Model&quot;">​</a></h4><p>The following inheritance rules apply to the storage model of a partitioned table:</p><ul><li><p>Altering the storage model at the partition root changes the storage model for all existing children and all future children.</p></li><li><p>Altering the storage model at the partition root with the <code>ONLY</code> keyword changes the storage model only for all future children.</p></li><li><p>Altering the storage model at a leaf changes the storage model only for that leaf.</p></li></ul><h4 id="adding-a-compressed-column-to-table" tabindex="-1"><a id="topic60"></a>Adding a Compressed Column to Table <a class="header-anchor" href="#adding-a-compressed-column-to-table" aria-label="Permalink to &quot;&lt;a id=&quot;topic60&quot;&gt;&lt;/a&gt;Adding a Compressed Column to Table&quot;">​</a></h4><p>Use <code>ALTER TABLE</code> command to add a compressed column to a table. All of the options and constraints for compressed columns described in <a href="#topic43">Adding Column-level Compression</a> apply to columns added with the <code>ALTER TABLE</code> command.</p><p>The following example shows how to add a column with <code>zlib</code> compression to a table, <code>T1</code>.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ALTER TABLE T1</span></span>
<span class="line"><span>      ADD COLUMN c4 int DEFAULT 0</span></span>
<span class="line"><span>      ENCODING (compresstype=zlib);</span></span></code></pre></div><h4 id="inheritance-of-compression-settings" tabindex="-1"><a id="topic61"></a>Inheritance of Compression Settings <a class="header-anchor" href="#inheritance-of-compression-settings" aria-label="Permalink to &quot;&lt;a id=&quot;topic61&quot;&gt;&lt;/a&gt;Inheritance of Compression Settings&quot;">​</a></h4><p>A partition added to a table that has sub-partitions defined with compression settings inherits the compression settings from the sub-partition. The following example shows how to create a table with sub-partition encodings, then alter it to add a partition.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE TABLE ccddl (i int, j int, k int, l int)</span></span>
<span class="line"><span>  WITH</span></span>
<span class="line"><span>    (appendoptimized = TRUE, orientation=COLUMN)</span></span>
<span class="line"><span>  PARTITION BY range(j)</span></span>
<span class="line"><span>  SUBPARTITION BY list (k)</span></span>
<span class="line"><span>  SUBPARTITION template(</span></span>
<span class="line"><span>    SUBPARTITION sp1 values(1, 2, 3, 4, 5),</span></span>
<span class="line"><span>    COLUMN i ENCODING(compresstype=ZLIB),</span></span>
<span class="line"><span>    COLUMN j ENCODING(compresstype=ZLIB),</span></span>
<span class="line"><span>    COLUMN k ENCODING(compresstype=ZLIB),</span></span>
<span class="line"><span>    COLUMN l ENCODING(compresstype=ZLIB))</span></span>
<span class="line"><span>  (PARTITION p1 START(1) END(10),</span></span>
<span class="line"><span>   PARTITION p2 START(10) END(20))</span></span>
<span class="line"><span>;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>ALTER TABLE ccddl</span></span>
<span class="line"><span>  ADD PARTITION p3 START(20) END(30)</span></span>
<span class="line"><span>;</span></span></code></pre></div><p>Running the <code>ALTER TABLE</code> command creates partitions of table <code>ccddl</code> named <code>ccddl_1_prt_p3</code> and <code>ccddl_1_prt_p3_2_prt_sp1</code>. Partition <code>ccddl_1_prt_p3</code> inherits the different compression encodings of sub-partition <code>sp1</code>.</p><h2 id="dropping-a-table" tabindex="-1"><a id="topic62"></a>Dropping a Table <a class="header-anchor" href="#dropping-a-table" aria-label="Permalink to &quot;&lt;a id=&quot;topic62&quot;&gt;&lt;/a&gt;Dropping a Table&quot;">​</a></h2><p>The<code>DROP TABLE</code>command removes tables from the database. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>DROP TABLE mytable;</span></span></code></pre></div><p>To empty a table of rows without removing the table definition, use <code>DELETE</code> or <code>TRUNCATE</code>. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>DELETE FROM mytable;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>TRUNCATE mytable;</span></span></code></pre></div><p><code>DROP TABLE</code>always removes any indexes, rules, triggers, and constraints that exist for the target table. Specify <code>CASCADE</code>to drop a table that is referenced by a view. <code>CASCADE</code> removes dependent views.</p>`,147)]))}const u=a(n,[["render",i]]);export{m as __pageData,u as default};
