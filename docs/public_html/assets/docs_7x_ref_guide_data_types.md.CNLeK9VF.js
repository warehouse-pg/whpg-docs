import{_ as e,c as d,o as a,ag as r}from"./chunks/framework.Ds6Eueu6.js";const c=JSON.parse('{"title":"Data Types","description":"","frontmatter":{},"headers":[],"relativePath":"docs/7x/ref_guide/data_types.md","filePath":"docs/7x/ref_guide/data_types.md"}'),i={name:"docs/7x/ref_guide/data_types.md"};function n(s,t,o,l,m,p){return a(),d("div",null,t[0]||(t[0]=[r('<h1 id="data-types" tabindex="-1">Data Types <a class="header-anchor" href="#data-types" aria-label="Permalink to &quot;Data Types&quot;">​</a></h1><p>WarehousePG has a rich set of native data types available to users. Users may also define new data types using the <code>CREATE TYPE</code> command. This reference shows all of the built-in data types. In addition to the types listed here, there are also some internally used data types, such as <em>oid</em> (object identifier), but those are not documented in this guide.</p><p>Additional modules that you register may also install new data types. The <code>hstore</code> module, for example, introduces a new data type and associated functions for working with key-value pairs. See <a href="./modules/hstore.html">hstore</a>. The <code>citext</code> module adds a case-insensitive text data type. See <a href="./modules/citext.html">citext</a>.</p><p>The following data types are specified by SQL: <em>bit</em>, <em>bit varying</em>, <em>boolean</em>, <em>character varying, varchar</em>, <em>character, char</em>, <em>date</em>, <em>double precision</em>, <em>integer</em>, <em>interval</em>, <em>numeric</em>, <em>decimal</em>, <em>real</em>, <em>smallint</em>, <em>time</em> (with or without time zone), and <em>timestamp</em> (with or without time zone).</p><p>Each data type has an external representation determined by its input and output functions. Many of the built-in types have obvious external formats. However, several types are either unique to PostgreSQL (and WarehousePG), such as geometric paths, or have several possibilities for formats, such as the date and time types. Some of the input and output functions are not invertible. That is, the result of an output function may lose accuracy when compared to the original input.</p><table tabindex="0"><thead><tr><th>Name</th><th>Alias</th><th>Size</th><th>Range</th><th>Description</th></tr></thead><tbody><tr><td>bigint</td><td>int8</td><td>8 bytes</td><td>-922337203​6854775808 to 922337203​6854775807</td><td>large range integer</td></tr><tr><td>bigserial</td><td>serial8</td><td>8 bytes</td><td>1 to 922337203​6854775807</td><td>large autoincrementing integer</td></tr><tr><td>bit [ (n) ]</td><td></td><td><em>n</em> bits</td><td><a href="https://www.postgresql.org/docs/12/sql-syntax.html#SQL-SYNTAX-BIT-STRINGS" target="_blank" rel="noreferrer">bit string constant</a></td><td>fixed-length bit string</td></tr><tr><td>bit varying [ (n) ]<sup>1</sup></td><td>varbit</td><td>actual number of bits</td><td><a href="https://www.postgresql.org/docs/12/sql-syntax.html#SQL-SYNTAX-BIT-STRINGS" target="_blank" rel="noreferrer">bit string constant</a></td><td>variable-length bit string</td></tr><tr><td>boolean</td><td>bool</td><td>1 byte</td><td>true/false, t/f, yes/no, y/n, 1/0</td><td>logical boolean (true/false)</td></tr><tr><td>box</td><td></td><td>32 bytes</td><td>((x1,y1),(x2,y2))</td><td>rectangular box in the plane - not allowed in distribution key columns.</td></tr><tr><td>bytea<sup>1</sup></td><td></td><td>1 byte + <em>binary string</em></td><td>sequence of <a href="https://www.postgresql.org/docs/12/datatype-binary.html#DATATYPE-BINARY-SQLESC" target="_blank" rel="noreferrer">octets</a></td><td>variable-length binary string</td></tr><tr><td>character [ (n) ]<sup>1</sup></td><td>char [ (n) ]</td><td>1 byte + <em>n</em></td><td>strings up to <em>n</em> characters in length</td><td>fixed-length, blank padded</td></tr><tr><td>character varying [ (n) ]<sup>1</sup></td><td>varchar [ (n) ]</td><td>1 byte + <em>string size</em></td><td>strings up to <em>n</em> characters in length</td><td>variable-length with limit</td></tr><tr><td>cidr</td><td></td><td>12 or 24 bytes</td><td></td><td>IPv4 and IPv6 networks</td></tr><tr><td>circle</td><td></td><td>24 bytes</td><td>&lt;(x,y),r&gt; (center and radius)</td><td>circle in the plane - not allowed in distribution key columns.</td></tr><tr><td>date</td><td></td><td>4 bytes</td><td>4713 BC - 294,277 AD</td><td>calendar date (year, month, day)</td></tr><tr><td>decimal [ (p, s) ]<sup>1</sup></td><td>numeric [ (p, s) ]</td><td>variable</td><td>no limit</td><td>user-specified precision, exact</td></tr><tr><td>double precision</td><td>float8<br><br>float</td><td>8 bytes</td><td>15 decimal digits precision</td><td>variable-precision, inexact</td></tr><tr><td>inet</td><td></td><td>12 or 24 bytes</td><td></td><td>IPv4 and IPv6 hosts and networks</td></tr><tr><td>integer</td><td>int, int4</td><td>4 bytes</td><td>-2147483648 to +2147483647</td><td>usual choice for integer</td></tr><tr><td>interval [ fields ] [ (p) ]</td><td></td><td>16 bytes</td><td>-178000000 years to 178000000 years</td><td>time span</td></tr><tr><td>json</td><td></td><td>1 byte + json size</td><td>json of any length</td><td>variable unlimited length</td></tr><tr><td>jsonb</td><td></td><td>1 byte + binary string</td><td>json of any length in a decomposed binary format</td><td>variable unlimited length</td></tr><tr><td>lseg</td><td></td><td>32 bytes</td><td>((x1,y1),(x2,y2))</td><td>line segment in the plane - not allowed in distribution key columns.</td></tr><tr><td>macaddr</td><td></td><td>6 bytes</td><td></td><td>MAC addresses</td></tr><tr><td>macaddr8</td><td></td><td>8 bytes</td><td></td><td>MAC addresses (EUI-64 format)</td></tr><tr><td>money</td><td></td><td>8 bytes</td><td>-92233720368547758.08 to +92233720368547758.07</td><td>currency amount</td></tr><tr><td>path<sup>1</sup></td><td></td><td>16+16n bytes</td><td>[(x1,y1),...]</td><td>geometric path in the plane - not allowed in distribution key columns.</td></tr><tr><td>point</td><td></td><td>16 bytes</td><td>(x,y)</td><td>geometric point in the plane - not allowed in distribution key columns.</td></tr><tr><td>polygon</td><td></td><td>40+16n bytes</td><td>((x1,y1),...)</td><td>closed geometric path in the plane - not allowed in distribution key columns.</td></tr><tr><td>real</td><td>float4</td><td>4 bytes</td><td>6 decimal digits precision</td><td>variable-precision, inexact</td></tr><tr><td>serial</td><td>serial4</td><td>4 bytes</td><td>1 to 2147483647</td><td>autoincrementing integer</td></tr><tr><td>smallint</td><td>int2</td><td>2 bytes</td><td>-32768 to +32767</td><td>small range integer</td></tr><tr><td>text<sup>1</sup></td><td></td><td>1 byte + <em>string size</em></td><td>strings of any length</td><td>variable unlimited length</td></tr><tr><td>time [ (p) ] [ without time zone ]</td><td></td><td>8 bytes</td><td>00:00:00[.000000] - 24:00:00[.000000]</td><td>time of day only</td></tr><tr><td>time [ (p) ] with time zone</td><td>timetz</td><td>12 bytes</td><td>00:00:00+1359 - 24:00:00-1359</td><td>time of day only, with time zone</td></tr><tr><td>timestamp [ (p) ] [ without time zone ]</td><td></td><td>8 bytes</td><td>4713 BC - 294,277 AD</td><td>both date and time</td></tr><tr><td>timestamp [ (p) ] with time zone</td><td>timestamptz</td><td>8 bytes</td><td>4713 BC - 294,277 AD</td><td>both date and time, with time zone</td></tr><tr><td>uuid</td><td></td><td>16 bytes</td><td></td><td>Universally Unique Identifiers according to RFC 4122, ISO/IEC 9834-8:2005</td></tr><tr><td>xml<sup>1</sup></td><td></td><td>1 byte + <em>xml size</em></td><td>xml of any length</td><td>variable unlimited length</td></tr><tr><td>txid_snapshot</td><td></td><td></td><td></td><td>user-level transaction ID snapshot</td></tr></tbody></table><ul><li><p><strong><a href="./datatype-datetime.html">Date/Time Types</a></strong></p></li><li><p><strong><a href="./datatype-pseudo.html">Pseudo-Types</a></strong></p></li><li><p><strong><a href="./datatype-textsearch.html">Text Search Data Types</a></strong></p></li><li><p><strong><a href="./datatype-range.html">Range Types</a></strong></p></li></ul><p><strong>Parent topic:</strong> <a href="./ref_guide.html">WarehousePG Reference Guide</a></p><p><a id="if139219"></a><sup>1</sup> For variable length data types, if the data is greater than or equal to 127 bytes, the storage overhead is 4 bytes instead of 1.</p>',9)]))}const y=e(i,[["render",n]]);export{c as __pageData,y as default};
