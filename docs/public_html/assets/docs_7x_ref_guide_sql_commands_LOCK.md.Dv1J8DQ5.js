import{_ as a,c as o,o as t,ag as s}from"./chunks/framework.Ds6Eueu6.js";const p=JSON.parse('{"title":"LOCK","description":"","frontmatter":{},"headers":[],"relativePath":"docs/7x/ref_guide/sql_commands/LOCK.md","filePath":"docs/7x/ref_guide/sql_commands/LOCK.md"}'),n={name:"docs/7x/ref_guide/sql_commands/LOCK.md"};function i(c,e,l,d,r,E){return t(),o("div",null,e[0]||(e[0]=[s('<h1 id="lock" tabindex="-1">LOCK <a class="header-anchor" href="#lock" aria-label="Permalink to &quot;LOCK&quot;">​</a></h1><p>Locks a table.</p><h2 id="synopsis" tabindex="-1"><a id="section2"></a>Synopsis <a class="header-anchor" href="#synopsis" aria-label="Permalink to &quot;&lt;a id=&quot;section2&quot;&gt;&lt;/a&gt;Synopsis&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LOCK [TABLE] [ONLY] name [ * ] [, ...] [IN &lt;lockmode&gt; MODE] [NOWAIT] [COORDINATOR ONLY]</span></span></code></pre></div><p>where lockmode is one of:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>    ACCESS SHARE | ROW SHARE | ROW EXCLUSIVE | SHARE UPDATE EXCLUSIVE </span></span>\n<span class="line"><span>  | SHARE | SHARE ROW EXCLUSIVE | EXCLUSIVE | ACCESS EXCLUSIVE</span></span></code></pre></div><h2 id="description" tabindex="-1"><a id="section3"></a>Description <a class="header-anchor" href="#description" aria-label="Permalink to &quot;&lt;a id=&quot;section3&quot;&gt;&lt;/a&gt;Description&quot;">​</a></h2><p><code>LOCK TABLE</code> obtains a table-level lock, waiting if necessary for any conflicting locks to be released. If <code>NOWAIT</code> is specified, <code>LOCK TABLE</code> does not wait to acquire the desired lock: if it cannot be acquired immediately, the command is stopped and an error is emitted. Once obtained, the lock is held for the remainder of the current transaction. There is no <code>UNLOCK TABLE</code> command; locks are always released at transaction end.</p><p>When acquiring locks automatically for commands that reference tables, WarehousePG always uses the least restrictive lock mode possible. <code>LOCK TABLE</code> provides for cases when you might need more restrictive locking. For example, suppose an application runs a transaction at the <code>READ COMMITTED</code> isolation level and needs to ensure that data in a table remains stable for the duration of the transaction. To achieve this you could obtain <code>SHARE</code> lock mode over the table before querying. This will prevent concurrent data changes and ensure subsequent reads of the table see a stable view of committed data, because <code>SHARE</code> lock mode conflicts with the <code>ROW EXCLUSIVE</code> lock acquired by writers, and your <code>LOCK TABLE &lt;name&gt; IN SHARE MODE</code> statement will wait until any concurrent holders of <code>ROW EXCLUSIVE</code> mode locks commit or rolls back. Thus, once you obtain the lock, there are no uncommitted writes outstanding; furthermore none can begin until you release the lock.</p><p>To achieve a similar effect when running a transaction at the <code>REPEATABLE READ</code> or <code>SERIALIZABLE</code> isolation level, you have to run the <code>LOCK TABLE</code> statement before running any <code>SELECT</code> or data modification statement. A <code>REPEATABLE READ</code> or <code>SERIALIZABLE</code> transaction&#39;s view of data will be frozen when its first <code>SELECT</code> or data modification statement begins. A <code>LOCK TABLE</code> later in the transaction will still prevent concurrent writes — but it won&#39;t ensure that what the transaction reads corresponds to the latest committed values.</p><p>If a transaction of this sort is going to change the data in the table, then it should use <code>SHARE ROW EXCLUSIVE</code> lock mode instead of <code>SHARE</code> mode. This ensures that only one transaction of this type runs at a time. Without this, a deadlock is possible: two transactions might both acquire <code>SHARE</code> mode, and then be unable to also acquire <code>ROW EXCLUSIVE</code> mode to actually perform their updates. Note that a transaction&#39;s own locks never conflict, so a transaction can acquire <code>ROW EXCLUSIVE</code> mode when it holds <code>SHARE</code> mode — but not if anyone else holds <code>SHARE</code> mode. To avoid deadlocks, make sure all transactions acquire locks on the same objects in the same order, and if multiple lock modes are involved for a single object, then transactions should always acquire the most restrictive mode first.</p><h2 id="parameters" tabindex="-1"><a id="section4"></a>Parameters <a class="header-anchor" href="#parameters" aria-label="Permalink to &quot;&lt;a id=&quot;section4&quot;&gt;&lt;/a&gt;Parameters&quot;">​</a></h2><p>name : The name (optionally schema-qualified) of an existing table to lock. If <code>ONLY</code> is specified, only that table is locked. If <code>ONLY</code> is not specified, the table and all its descendant tables (if any) are locked. Optionally, <code>*</code> can be specified after the table name to explicitly indicate that descendant tables are included.</p><p>: If multiple tables are given, tables are locked one-by-one in the order specified in the <code>LOCK TABLE</code> command.</p><p>lockmode : The lock mode specifies which locks this lock conflicts with. If no lock mode is specified, then <code>ACCESS EXCLUSIVE</code>, the most restrictive mode, is used. Lock modes are as follows:</p><pre><code>-   ACCESS SHARE — Conflicts with the `ACCESS EXCLUSIVE` lock mode only. The `SELECT` command acquires a lock of this mode on referenced tables. In general, any query that only reads a table and does not modify it will acquire this lock mode.\n-   ROW SHARE — Conflicts with the `EXCLUSIVE` and `ACCESS EXCLUSIVE` lock modes. The `SELECT FOR SHARE` command automatically acquires a lock of this mode on the target table\\(s\\) \\(in addition to `ACCESS SHARE` locks on any other tables that are referenced but not selected `FOR SHARE`\\).\n-   ROW EXCLUSIVE — Conflicts with the `SHARE`, `SHARE ROW EXCLUSIVE`, `EXCLUSIVE`, and `ACCESS EXCLUSIVE` lock modes. The commands `INSERT` and `COPY` automatically acquire this lock mode on the target table \\(in addition to `ACCESS SHARE` locks on any other referenced tables\\) See [Note](#lock_note).\n-   SHARE UPDATE EXCLUSIVE — Conflicts with the `SHARE UPDATE EXCLUSIVE`, `SHARE`, `SHARE ROW EXCLUSIVE`, `EXCLUSIVE`, and `ACCESS EXCLUSIVE` lock modes. This mode protects a table against concurrent schema changes and `VACUUM` runs. Acquired by `VACUUM` \\(without `FULL`\\) on heap tables and `ANALYZE`.\n-   SHARE — Conflicts with the `ROW EXCLUSIVE`, `SHARE UPDATE EXCLUSIVE`, `SHARE ROW EXCLUSIVE, EXCLUSIVE`, and `ACCESS EXCLUSIVE` lock modes. This mode protects a table against concurrent data changes. Acquired automatically by `CREATE INDEX`.\n-   SHARE ROW EXCLUSIVE — Conflicts with the `ROW EXCLUSIVE`, `SHARE UPDATE EXCLUSIVE`, `SHARE`, `SHARE ROW EXCLUSIVE`, `EXCLUSIVE`, and `ACCESS EXCLUSIVE` lock modes. This mode protects a table against concurrent data changes, and is self-exclusive so that only one session can hold it at a time. This lock mode is not automatically acquired by any WarehousePG command.\n-   EXCLUSIVE — Conflicts with the `ROW SHARE`, `ROW EXCLUSIVE`, `SHARE UPDATE EXCLUSIVE`, `SHARE`, `SHARE ROW EXCLUSIVE`, `EXCLUSIVE`, and `ACCESS EXCLUSIVE` lock modes. This mode allows only concurrent `ACCESS SHARE` locks, i.e., only reads from the table can proceed in parallel with a transaction holding this lock mode. This lock mode is automatically acquired for `UPDATE`, `SELECT FOR UPDATE`, and `DELETE` in WarehousePG \\(which is more restrictive locking than in regular PostgreSQL\\). See [Note](#lock_note).\n-   ACCESS EXCLUSIVE — Conflicts with locks of all modes \\(`ACCESS SHARE`, `ROW SHARE`, `ROW EXCLUSIVE`, `SHARE UPDATE EXCLUSIVE`, `SHARE`, `SHARE ROW EXCLUSIVE`, `EXCLUSIVE`, and `ACCESS EXCLUSIVE`\\). This mode guarantees that the holder is the only transaction accessing the table in any way. Acquired automatically by the `ALTER TABLE`, `DROP TABLE`, `TRUNCATE`, `REINDEX`, `CLUSTER`, and `VACUUM FULL` commands. This is the default lock mode for `LOCK TABLE` statements that do not specify a mode explicitly. This lock is also briefly acquired by `VACUUM` \\(without `FULL`\\) on append-optimized tables during processing.\n\n&gt; **Note** As the default, WarehousePG acquires an `EXCLUSIVE` lock on tables for `DELETE`, `UPDATE`, and `SELECT FOR UPDATE` operations on heap tables. When the Global Deadlock Detector is enabled, the lock mode for the operations on heap tables is `ROW EXCLUSIVE`. See [Global Deadlock Detector](../../admin_guide/dml.html#topic_gdd).\n</code></pre><p>NOWAIT : Specifies that <code>LOCK TABLE</code> should not wait for any conflicting locks to be released: if the specified lock(s) cannot be acquired immediately without waiting, the transaction is cancelled.</p><p>COORDINATOR ONLY : Specifies that when a <code>LOCK TABLE</code> command is issued, WarehousePG will lock tables on the coordinator only, rather than on the coordinator and all of the segments. This is particularly useful for metadata-only operations. <br><br>&gt; <strong>Note</strong> This option is only supported in <code>ACCESS SHARE MODE</code>.</p><h2 id="notes" tabindex="-1"><a id="section5"></a>Notes <a class="header-anchor" href="#notes" aria-label="Permalink to &quot;&lt;a id=&quot;section5&quot;&gt;&lt;/a&gt;Notes&quot;">​</a></h2><p><code>LOCK TABLE ... IN ACCESS SHARE MODE</code> requires <code>SELECT</code> privileges on the target table. All other forms of <code>LOCK</code> require table-level <code>UPDATE</code>, <code>DELETE</code>, or <code>TRUNCATE</code> privileges.</p><p><code>LOCK TABLE</code> is useless outside of a transaction block: the lock would be held only to the completion of the <code>LOCK</code> statement. Therefore, WarehousePG reports an error if <code>LOCK</code> is used outside of a transaction block. Use <code>BEGIN</code> and <code>END</code> to define a transaction block.</p><p><code>LOCK TABLE</code> only deals with table-level locks, and so the mode names involving <code>ROW</code> are all misnomers. These mode names should generally be read as indicating the intention of the user to acquire row-level locks within the locked table. Also, <code>ROW EXCLUSIVE</code> mode is a shareable table lock. Keep in mind that all the lock modes have identical semantics so far as <code>LOCK TABLE</code> is concerned, differing only in the rules about which modes conflict with which. For information on how to acquire an actual row-level lock, see the <code>FOR UPDATE/FOR SHARE</code> clause in the <a href="./SELECT.html">SELECT</a> reference documentation.</p><h2 id="examples" tabindex="-1"><a id="section6"></a>Examples <a class="header-anchor" href="#examples" aria-label="Permalink to &quot;&lt;a id=&quot;section6&quot;&gt;&lt;/a&gt;Examples&quot;">​</a></h2><p>Obtain a <code>SHARE</code> lock on the <code>films</code> table when going to perform inserts into the <code>films_user_comments</code> table:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>BEGIN WORK;</span></span>\n<span class="line"><span>LOCK TABLE films IN SHARE MODE;</span></span>\n<span class="line"><span>SELECT id FROM films</span></span>\n<span class="line"><span>    WHERE name = &#39;Star Wars: Episode I - The Phantom Menace&#39;;</span></span>\n<span class="line"><span>-- Do ROLLBACK if record was not returned</span></span>\n<span class="line"><span>INSERT INTO films_user_comments VALUES</span></span>\n<span class="line"><span>    (_id_, &#39;GREAT! I was waiting for it for so long!&#39;);</span></span>\n<span class="line"><span>COMMIT WORK;</span></span></code></pre></div><p>Take a <code>SHARE ROW EXCLUSIVE</code> lock on a table when performing a delete operation:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>BEGIN WORK;</span></span>\n<span class="line"><span>LOCK TABLE films IN SHARE ROW EXCLUSIVE MODE;</span></span>\n<span class="line"><span>DELETE FROM films_user_comments WHERE id IN</span></span>\n<span class="line"><span>    (SELECT id FROM films WHERE rating &lt; 5);</span></span>\n<span class="line"><span>DELETE FROM films WHERE rating &lt; 5;</span></span>\n<span class="line"><span>COMMIT WORK;</span></span></code></pre></div><h2 id="compatibility" tabindex="-1"><a id="section7"></a>Compatibility <a class="header-anchor" href="#compatibility" aria-label="Permalink to &quot;&lt;a id=&quot;section7&quot;&gt;&lt;/a&gt;Compatibility&quot;">​</a></h2><p>There is no <code>LOCK TABLE</code> in the SQL standard, which instead uses <code>SET TRANSACTION</code> to specify concurrency levels on transactions. WarehousePG supports that too; see <a href="./SET_TRANSACTION.html">SET TRANSACTION</a> for details.</p><p>Except for <code>ACCESS SHARE</code>, <code>ACCESS EXCLUSIVE</code>, and <code>SHARE UPDATE EXCLUSIVE</code> lock modes, the WarehousePG lock modes and the <code>LOCK TABLE</code> syntax are compatible with those present in Oracle.</p><h2 id="see-also" tabindex="-1"><a id="section8"></a>See Also <a class="header-anchor" href="#see-also" aria-label="Permalink to &quot;&lt;a id=&quot;section8&quot;&gt;&lt;/a&gt;See Also&quot;">​</a></h2><p><a href="./BEGIN.html">BEGIN</a>, <a href="./SET_TRANSACTION.html">SET TRANSACTION</a>, <a href="./SELECT.html">SELECT</a></p><p><strong>Parent topic:</strong> <a href="./../sql_commands/sql_ref.html">SQL Commands</a></p>',33)]))}const m=a(n,[["render",i]]);export{p as __pageData,m as default};
