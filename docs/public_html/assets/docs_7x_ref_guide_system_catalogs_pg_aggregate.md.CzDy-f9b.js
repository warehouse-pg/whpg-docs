import{_ as e,c as d,o as a,ag as o}from"./chunks/framework.Ds6Eueu6.js";const l=JSON.parse('{"title":"pg_aggregate","description":"","frontmatter":{},"headers":[],"relativePath":"docs/7x/ref_guide/system_catalogs/pg_aggregate.md","filePath":"docs/7x/ref_guide/system_catalogs/pg_aggregate.md"}'),r={name:"docs/7x/ref_guide/system_catalogs/pg_aggregate.md"};function n(g,t,i,c,s,f){return a(),d("div",null,t[0]||(t[0]=[o('<h1 id="pg-aggregate" tabindex="-1">pg_aggregate <a class="header-anchor" href="#pg-aggregate" aria-label="Permalink to &quot;pg_aggregate&quot;">â€‹</a></h1><p>The <code>pg_aggregate</code> table stores information about aggregate functions. An aggregate function is a function that operates on a set of values (typically one column from each row that matches a query condition) and returns a single value computed from all these values. Typical aggregate functions are <code>sum</code>, <code>count</code>, and <code>max</code>. Each entry in <code>pg_aggregate</code> is an extension of an entry in <code>pg_proc</code>. The <code>pg_proc</code> entry carries the aggregate&#39;s name, input and output data types, and other information that is similar to ordinary functions.</p><table tabindex="0"><thead><tr><th>column</th><th>type</th><th>references</th><th>description</th></tr></thead><tbody><tr><td><code>aggfnoid</code></td><td>regproc</td><td>pg_proc.oid</td><td>OID of the aggregate function</td></tr><tr><td><code>aggkind</code></td><td>char</td><td></td><td>Aggregate kind: <code>n</code> for <em>normal</em> aggregates, <code>o</code> for <em>ordered-set</em> aggregates, or <code>h</code> for <em>hypothetical-set</em> aggregates</td></tr><tr><td><code>aggnumdirectargs</code></td><td>smallint</td><td></td><td>Number of direct (non-aggregated) arguments of an ordered-set or hypothetical-set aggregate, counting a variadic array as one argument. If equal to <code>pronargs</code>, the aggregate must be variadic and the variadic array describes the aggregated arguments as well as the final direct arguments. Always zero for normal aggregates.</td></tr><tr><td><code>aggtransfn</code></td><td>regproc</td><td>pg_proc.oid</td><td>Transition function OID</td></tr><tr><td><code>aggfinalfn</code></td><td>regproc</td><td>pg_proc.oid</td><td>Final function OID (zero if none)</td></tr><tr><td><code>aggcombinefn</code></td><td>regproc</td><td>pg_proc.oid</td><td>Combine function OID (zero if none)</td></tr><tr><td><code>aggserialfn</code></td><td>regproc</td><td>pg_proc.oid</td><td>OID of the serialization function to convert transtype to <code>bytea</code> (zero if none)</td></tr><tr><td><code>aggdeserialfn</code></td><td>regproc</td><td>pg_proc.oid</td><td>OID of the deserialization function to convert <code>bytea</code> to transtype (zero if none)</td></tr><tr><td><code>aggmtransfn</code></td><td>regproc</td><td>pg_proc.oid</td><td>Forward transition function OID for moving-aggregate mode (zero if none)</td></tr><tr><td><code>aggminvtransfn</code></td><td>regproc</td><td>pg_proc.oid</td><td>Inverse transition function OID for moving-aggregate mode (zero if none)</td></tr><tr><td><code>aggmfinalfn</code></td><td>regproc</td><td>pg_proc.oid</td><td>Final function OID for moving-aggregate mode (zero if none)</td></tr><tr><td><code>aggfinalextra</code></td><td>bool</td><td></td><td>True to pass extra dummy arguments to <code>aggfinalfn</code></td></tr><tr><td><code>aggmfinalextra</code></td><td>bool</td><td></td><td>True to pass extra dummy arguments to <code>aggmfinalfn</code></td></tr><tr><td><code>aggfinalmodify</code></td><td>char</td><td></td><td>Indicates whether <code>aggfinalfn</code> modifies the transition state</td></tr><tr><td><code>aggmfinalmodify</code></td><td>char</td><td></td><td>Indicates whether <code>aggmfinalfn</code> modifies the transition state</td></tr><tr><td><code>aggsortop</code></td><td>oid</td><td>pg_operator.oid</td><td>Associated sort operator OID (zero if none)</td></tr><tr><td><code>aggtranstype</code></td><td>oid</td><td>pg_type.oid</td><td>Data type of the aggregate function&#39;s internal transition (state) data</td></tr><tr><td><code>aggtransspace</code></td><td>integer</td><td></td><td>Approximate average size (in bytes) of the transition state data, or zero to use a default estimate</td></tr><tr><td><code>aggmtranstype</code></td><td>oid</td><td>pg_type.oid</td><td>Data type of the aggregate function&#39;s internal transition (state) data for moving-aggregate mode (zero if none)</td></tr><tr><td><code>aggmtransspace</code></td><td>integer</td><td></td><td>Approximate average size (in bytes) of the transition state data for moving-aggregate mode, or zero to use a default estimate</td></tr><tr><td><code>agginitval</code></td><td>text</td><td></td><td>The initial value of the transition state. This is a text field containing the initial value in its external string representation. If this field is NULL, the transition state value starts out NULL.</td></tr><tr><td><code>aggminitval</code></td><td>text</td><td></td><td>The initial value of the transition state for moving- aggregate mode. This is a text field containing the initial value in its external string representation. If this field is NULL, the transition state value starts out NULL.</td></tr><tr><td><code>aggrepsafeexec</code></td><td>bool</td><td></td><td>True to specify that the aggregate can be safely executed on replicated slices. An order-agnostic aggregate would be considered safe in this context.</td></tr></tbody></table><p><strong>Parent topic:</strong> <a href="./../system_catalogs/catalog_ref-html.html">System Catalogs Definitions</a></p>',4)]))}const m=e(r,[["render",n]]);export{l as __pageData,m as default};
