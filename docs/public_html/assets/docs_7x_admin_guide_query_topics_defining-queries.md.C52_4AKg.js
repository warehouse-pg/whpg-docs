import{_ as a,c as s,o as n,ag as t}from"./chunks/framework.Ds6Eueu6.js";const h=JSON.parse('{"title":"Defining Queries","description":"","frontmatter":{},"headers":[],"relativePath":"docs/7x/admin_guide/query/topics/defining-queries.md","filePath":"docs/7x/admin_guide/query/topics/defining-queries.md"}'),o={name:"docs/7x/admin_guide/query/topics/defining-queries.md"};function i(p,e,l,c,r,d){return n(),s("div",null,e[0]||(e[0]=[t(`<h1 id="defining-queries" tabindex="-1">Defining Queries <a class="header-anchor" href="#defining-queries" aria-label="Permalink to &quot;Defining Queries&quot;">​</a></h1><hr><p>WarehousePG is based on the PostgreSQL implementation of the SQL standard.</p><p>This topic describes how to construct SQL queries in WarehousePG.</p><ul><li><a href="#topic3">SQL Lexicon</a></li><li><a href="#topic4">SQL Value Expressions</a></li></ul><p><strong>Parent topic:</strong> <a href="./../../query/topics/query.html">SQL: Querying Data</a></p><h2 id="sql-lexicon" tabindex="-1"><a id="topic3"></a>SQL Lexicon <a class="header-anchor" href="#sql-lexicon" aria-label="Permalink to &quot;&lt;a id=&quot;topic3&quot;&gt;&lt;/a&gt;SQL Lexicon&quot;">​</a></h2><p>SQL is a standard language for accessing databases. The language consists of elements that enable data storage, retrieval, analysis, viewing, manipulation, and so on. You use SQL commands to construct queries and commands that the WarehousePG engine understands. SQL queries consist of a sequence of commands. Commands consist of a sequence of valid tokens in correct syntax order, terminated by a semicolon (<code>;</code>).</p><p>For more information about SQL commands, see <a href="./../../../ref_guide/sql_commands/sql_ref.html">SQL Command Reference</a>.</p><p>WarehousePG uses PostgreSQL&#39;s structure and syntax, with some exceptions. For more information about SQL rules and concepts in PostgreSQL, see &quot;SQL Syntax&quot; in the PostgreSQL documentation.</p><h2 id="sql-value-expressions" tabindex="-1"><a id="topic4"></a>SQL Value Expressions <a class="header-anchor" href="#sql-value-expressions" aria-label="Permalink to &quot;&lt;a id=&quot;topic4&quot;&gt;&lt;/a&gt;SQL Value Expressions&quot;">​</a></h2><p>SQL value expressions consist of one or more values, symbols, operators, SQL functions, and data. The expressions compare data or perform calculations and return a value as the result. Calculations include logical, arithmetic, and set operations.</p><p>The following are value expressions:</p><ul><li>An aggregate expression</li><li>An array constructor</li><li>A column reference</li><li>A constant or literal value</li><li>A correlated subquery</li><li>A field selection expression</li><li>A function call</li><li>A new column value in an <code>INSERT</code>or <code>UPDATE</code></li><li>An operator invocation column reference</li><li>A positional parameter reference, in the body of a function definition or prepared statement</li><li>A row constructor</li><li>A scalar subquery</li><li>A search condition in a <code>WHERE</code> clause</li><li>A target list of a <code>SELECT</code> command</li><li>A type cast</li><li>A value expression in parentheses, useful to group sub-expressions and override precedence</li><li>A window expression</li></ul><p>SQL constructs such as functions and operators are expressions but do not follow any general syntax rules. For more information about these constructs, see <a href="./functions-operators.html">Using Functions and Operators</a>.</p><h3 id="column-references" tabindex="-1"><a id="topic5"></a>Column References <a class="header-anchor" href="#column-references" aria-label="Permalink to &quot;&lt;a id=&quot;topic5&quot;&gt;&lt;/a&gt;Column References&quot;">​</a></h3><p>A column reference has the form:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;correlation&gt;.&lt;columnname&gt;</span></span></code></pre></div><p>Here, <code>&lt;correlation&gt;</code> is the name of a table (possibly qualified with a schema name) or an alias for a table defined with a <code>FROM</code> clause or one of the keywords <code>NEW</code> or <code>OLD</code>. <code>NEW</code> and <code>OLD</code> can appear only in rewrite rules, but you can use other correlation names in any SQL statement. If the column name is unique across all tables in the query, you can omit the <code>&lt;correlation&gt;</code> part of the column reference.</p><h3 id="positional-parameters" tabindex="-1"><a id="topic6"></a>Positional Parameters <a class="header-anchor" href="#positional-parameters" aria-label="Permalink to &quot;&lt;a id=&quot;topic6&quot;&gt;&lt;/a&gt;Positional Parameters&quot;">​</a></h3><p>Positional parameters are arguments to SQL statements or functions that you reference by their positions in a series of arguments. For example, <code>$1</code> refers to the first argument, <code>$2</code> to the second argument, and so on. The values of positional parameters are set from arguments external to the SQL statement or supplied when SQL functions are invoked. Some client libraries support specifying data values separately from the SQL command, in which case parameters refer to the out-of-line data values. A parameter reference has the form:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$number</span></span></code></pre></div><p>For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE FUNCTION dept(text) RETURNS dept</span></span>
<span class="line"><span>    AS $$ SELECT * FROM dept WHERE name = $1 $$</span></span>
<span class="line"><span>    LANGUAGE SQL;</span></span></code></pre></div><p>Here, the <code>$1</code> references the value of the first function argument whenever the function is invoked.</p><h3 id="subscripts" tabindex="-1"><a id="topic7"></a>Subscripts <a class="header-anchor" href="#subscripts" aria-label="Permalink to &quot;&lt;a id=&quot;topic7&quot;&gt;&lt;/a&gt;Subscripts&quot;">​</a></h3><p>If an expression yields a value of an array type, you can extract a specific element of the array value as follows:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;expression&gt;[&lt;subscript&gt;]</span></span></code></pre></div><p>You can extract multiple adjacent elements, called an array slice, as follows (including the brackets):</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;expression&gt;[&lt;lower_subscript&gt;:&lt;upper_subscript&gt;]</span></span></code></pre></div><p>Each subscript is an expression and yields an integer value.</p><p>Array expressions usually must be in parentheses, but you can omit the parentheses when the expression to be subscripted is a column reference or positional parameter. You can concatenate multiple subscripts when the original array is multidimensional. For example (including the parentheses):</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>mytable.arraycolumn[4]</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>mytable.two_d_column[17][34]</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$1[10:42]</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(arrayfunction(a,b))[42]</span></span></code></pre></div><h3 id="field-selection" tabindex="-1"><a id="topic8"></a>Field Selection <a class="header-anchor" href="#field-selection" aria-label="Permalink to &quot;&lt;a id=&quot;topic8&quot;&gt;&lt;/a&gt;Field Selection&quot;">​</a></h3><p>If an expression yields a value of a composite type (row type), you can extract a specific field of the row as follows:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;expression&gt;.&lt;fieldname&gt;</span></span></code></pre></div><p>The row expression usually must be in parentheses, but you can omit these parentheses when the expression to be selected from is a table reference or positional parameter. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>mytable.mycolumn</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$1.somecolumn</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(rowfunction(a,b)).col3</span></span></code></pre></div><p>A qualified column reference is a special case of field selection syntax.</p><h3 id="operator-invocations" tabindex="-1"><a id="topic9"></a>Operator Invocations <a class="header-anchor" href="#operator-invocations" aria-label="Permalink to &quot;&lt;a id=&quot;topic9&quot;&gt;&lt;/a&gt;Operator Invocations&quot;">​</a></h3><p>Operator invocations have the following possible syntaxes:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;expression operator expression&gt;(binary infix operator)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;operator expression&gt;(unary prefix operator)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;expression operator&gt;(unary postfix operator)</span></span></code></pre></div><p>Where <code>operator</code> is an operator token, one of the key words <code>AND</code>, <code>OR</code>, or <code>NOT</code>, or qualified operator name in the form:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>OPERATOR(&lt;schema&gt;.&lt;operatorname&gt;)</span></span></code></pre></div><p>Available operators and whether they are unary or binary depends on the operators that the system or user defines. For more information about built-in operators, see <a href="./functions-operators.html">Built-in Functions and Operators</a>.</p><h3 id="function-calls" tabindex="-1"><a id="topic10"></a>Function Calls <a class="header-anchor" href="#function-calls" aria-label="Permalink to &quot;&lt;a id=&quot;topic10&quot;&gt;&lt;/a&gt;Function Calls&quot;">​</a></h3><p>The syntax for a function call is the name of a function (possibly qualified with a schema name), followed by its argument list enclosed in parentheses:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>function ([expression [, expression ... ]])</span></span></code></pre></div><p>For example, the following function call computes the square root of 2:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>sqrt(2)</span></span></code></pre></div><p>See <a href="./../../../ref_guide/function-summary.html">Summary of Built-in Functions</a> for lists of the built-in functions by category. You can add custom functions, too.</p><h3 id="aggregate-expressions" tabindex="-1"><a id="topic11"></a>Aggregate Expressions <a class="header-anchor" href="#aggregate-expressions" aria-label="Permalink to &quot;&lt;a id=&quot;topic11&quot;&gt;&lt;/a&gt;Aggregate Expressions&quot;">​</a></h3><p>An aggregate expression applies an aggregate function across the rows that a query selects. An aggregate function performs a calculation on a set of values and returns a single value, such as the sum or average of the set of values. The syntax of an aggregate expression is one of the following:</p><ul><li><code>aggregate_name(expression [ , ... ] ) [ FILTER ( WHERE filter_clause ) ]</code> — operates across all input rows for which the expected result value is non-null. <code>ALL</code> is the default.</li><li><code>aggregate_name(ALL expression [ , ... ] ) [ FILTER ( WHERE filter_clause ) ]</code> — operates identically to the first form because <code>ALL</code> is the default.</li><li><code>aggregate_name(DISTINCT expression [ , ... ] ) [ FILTER ( WHERE filter_clause ) ]</code> — operates across all distinct non-null values of input rows.</li><li><code>aggregate_name(*) [ FILTER ( WHERE filter_clause ) ]</code> — operates on all rows with values both null and non-null. Generally, this form is most useful for the <code>count(*)</code> aggregate function.</li></ul><p>Where <code>aggregate_name</code> is a previously defined aggregate (possibly schema-qualified) and <code>expression</code> is any value expression that does not contain an aggregate expression.</p><p>For example, <code>count(*)</code> yields the total number of input rows, <code>count(f1)</code> yields the number of input rows in which <code>f1</code> is non-null, and<code>count(distinct f1)</code> yields the number of distinct non-null values of <code>f1</code>.</p><p>If <code>FILTER</code> is specified, then only the input rows for which the <code>filter_clause</code> evaluates to true are fed to the aggregate function; other rows are discarded. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT</span></span>
<span class="line"><span>    count(*) AS unfiltered,</span></span>
<span class="line"><span>    count(*) FILTER (WHERE i &lt; 5) AS filtered</span></span>
<span class="line"><span>FROM generate_series(1,10) AS s(i);</span></span>
<span class="line"><span> unfiltered | filtered</span></span>
<span class="line"><span>------------+----------</span></span>
<span class="line"><span>         10 |        4</span></span>
<span class="line"><span>(1 row)</span></span></code></pre></div><p>For predefined aggregate functions, see <a href="./functions-operators.html#topic29">Built-in Functions and Operators</a>. You can also add custom aggregate functions.</p><p>WarehousePG provides the <code>MEDIAN</code> aggregate function, which returns the fiftieth percentile of the <code>PERCENTILE_CONT</code> result and special aggregate expressions for inverse distribution functions as follows:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>PERCENTILE_CONT(&lt;percentage&gt;) WITHIN GROUP (ORDER BY &lt;expression&gt;)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>PERCENTILE_DISC(&lt;percentage&gt;) WITHIN GROUP (ORDER BY &lt;expression&gt;)</span></span></code></pre></div><p>Currently you can use only these two expressions with the keyword <code>WITHIN GROUP</code>.</p><h4 id="limitations-of-aggregate-expressions" tabindex="-1"><a id="topic12"></a>Limitations of Aggregate Expressions <a class="header-anchor" href="#limitations-of-aggregate-expressions" aria-label="Permalink to &quot;&lt;a id=&quot;topic12&quot;&gt;&lt;/a&gt;Limitations of Aggregate Expressions&quot;">​</a></h4><p>The following are current limitations of the aggregate expressions:</p><ul><li>WarehousePG does not support the following keywords: <code>ALL</code>, <code>DISTINCT</code>, and <code>OVER</code>. See <a href="./functions-operators.html#topic31__in2073121">Table 5</a> for more details.</li><li>An aggregate expression can appear only in the result list or <code>HAVING</code> clause of a <code>SELECT</code> command. It is forbidden in other clauses, such as <code>WHERE</code>, because those clauses are logically evaluated before the results of aggregates form. This restriction applies to the query level to which the aggregate belongs.</li><li>When an aggregate expression appears in a subquery, the aggregate is normally evaluated over the rows of the subquery. If the aggregate&#39;s arguments (and <code>filter_clause</code> if any) contain only outer-level variables, the aggregate belongs to the nearest such outer level and evaluates over the rows of that query. The aggregate expression as a whole is then an outer reference for the subquery in which it appears, and the aggregate expression acts as a constant over any one evaluation of that subquery. The restriction about appearing only in the result list or <code>HAVING</code> clause applies with respect to the query level at which the aggregate appears. See <a href="#topic15">Scalar Subqueries</a> and <a href="./functions-operators.html#topic29__in204913">Table 3</a>.</li><li>WarehousePG does not support specifying an aggregate function as an argument to another aggregate function.</li><li>WarehousePG does not support specifying a window function as an argument to an aggregate function.</li></ul><h3 id="window-expressions" tabindex="-1"><a id="topic13"></a>Window Expressions <a class="header-anchor" href="#window-expressions" aria-label="Permalink to &quot;&lt;a id=&quot;topic13&quot;&gt;&lt;/a&gt;Window Expressions&quot;">​</a></h3><p>Window expressions allow application developers to more easily compose complex online analytical processing (OLAP) queries using standard SQL commands. For example, with window expressions, users can calculate moving averages or sums over various intervals, reset aggregations and ranks as selected column values change, and express complex ratios in simple terms.</p><p>A window expression represents the application of a <code>&lt;window function&gt;</code> to a <code>&lt;window frame&gt;</code>, which is defined with an <code>OVER()</code> clause. This is comparable to the type of calculation that can be done with an aggregate function and a <code>GROUP BY</code> clause. Unlike aggregate functions, which return a single result value for each group of rows, window functions return a result value for every row, but that value is calculated with respect to the set of rows in the window frame to which the row belongs. The <code>OVER()</code> clause allows dividing the rows into <em>partitions</em> and then further restricting the window frame by specifying which rows preceding or following the current row within its partition to include in the calculation.</p><p>WarehousePG does not support specifying a window function as an argument to another window function.</p><p>The syntax of a window expression is:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;window_function&gt; ( [&lt;expression&gt; [, ...]] ) [ FILTER ( WHERE &lt;filter_clause&gt; ) ] OVER ( &lt;window_specification&gt; )</span></span></code></pre></div><p>Where <code>&lt;window_function&gt;</code> is one of the functions listed in <a href="./functions-operators.html#topic30__in164369">Table 4</a> or a user-defined window function, <code>&lt;expression&gt;</code> is any value expression that does not contain a window expression, and <code>&lt;window_specification&gt;</code> is:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[&lt;window_name&gt;]</span></span>
<span class="line"><span>[PARTITION BY &lt;expression&gt; [, ...]]</span></span>
<span class="line"><span>[[ORDER BY &lt;expression&gt; [ASC | DESC | USING operator] [NULLS {FIRST | LAST}] [, ...]</span></span>
<span class="line"><span>[ &lt;frame_clause&gt; ]</span></span></code></pre></div><p>The optional <code>&lt;frame_clause&gt;</code> can be one of the following:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>{ RANGE | ROWS | GROUPS } &lt;frame_start&gt; [ &lt;frame_exclusion&gt; ]</span></span>
<span class="line"><span>{ RANGE | ROWS | GROUPS } BETWEEN &lt;frame_start&gt; AND &lt;frame_end&gt; [ &lt;frame_exclusion&gt; ]</span></span></code></pre></div><p>Where <code>&lt;frame_start&gt;</code> and <code>&lt;frame_end&gt;</code> can be one of the following:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>UNBOUNDED PRECEDING</span></span>
<span class="line"><span>&lt;offset&gt; PRECEDING</span></span>
<span class="line"><span>CURRENT ROW</span></span>
<span class="line"><span>&lt;offset&gt; FOLLOWING</span></span>
<span class="line"><span>UNBOUNDED FOLLOWING</span></span></code></pre></div><p>and <code>&lt;frame_exclusion&gt;</code> can be one of the following:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>EXCLUDE CURRENT ROW</span></span>
<span class="line"><span>EXCLUDE GROUP</span></span>
<span class="line"><span>EXCLUDE TIES</span></span>
<span class="line"><span>EXCLUDE NO OTHERS</span></span></code></pre></div><p>A window expression can appear only in the select list of a <code>SELECT</code> command. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT count(*) OVER(PARTITION BY customer_id), * FROM sales;</span></span></code></pre></div><p>If <code>FILTER</code> is specified, then only the input rows for which the <code>&lt;filter_clause&gt;</code> evaluates to true are fed to the window function; other rows are discarded. In a window expression, a <code>FILTER</code> clause can be used only with a <code>&lt;window_function&gt;</code> that is an aggregate function.</p><p>In a window expression, the expression must contain an <code>OVER</code> clause. The <code>OVER</code> clause specifies the window frame—the rows to be processed by the window function. This syntactically distinguishes the function from a regular or aggregate function.</p><p>In a window aggregate function that is used in a window expression, WarehousePG does not support a <code>DISTINCT</code> clause with multiple input expressions.</p><p>A window specification has the following characteristics:</p><ul><li>The <code>PARTITION BY</code> clause defines the window partitions to which the window function is applied. If omitted, the entire result set is treated as one partition.</li><li>The <code>ORDER BY</code> clause defines the expression(s) for sorting rows within a window partition. The <code>ORDER BY</code> clause of a window specification is separate and distinct from the <code>ORDER BY</code> clause of a regular query expression. The <code>ORDER BY</code> clause is required for the window functions that calculate rankings, as it identifies the measure(s) for the ranking values. For OLAP aggregations, the <code>ORDER BY</code> clause is required to use window frames (the <code>ROWS</code>, <code>RANGE</code> or <code>GROUPS</code> clause).</li></ul><blockquote><p><strong>Note</strong> Columns of data types without a coherent ordering, such as <code>time</code>, are not good candidates for use in the <code>ORDER BY</code> clause of a window specification. <code>Time</code>, with or without a specified time zone, lacks a coherent ordering because addition and subtraction do not have the expected effects. For example, the following is not generally true: <code>x::time &lt; x::time + &#39;2 hour&#39;::interval</code></p></blockquote><ul><li><p>The <code>&lt;frame_clause&gt;</code> specifies the set of rows constituting the <code>&lt;window frame&gt;</code>, which is a subset of the current partition, for those window functions that act on the frame instead of the whole partition. The set of rows in the frame can vary depending on which row is the current row. The frame can be specified in <code>RANGE</code>, <code>ROWS</code> or <code>GROUPS</code> mode; in each case, it runs from the <code>&lt;frame_start&gt;</code> to the <code>&lt;frame_end&gt;</code>. If <code>&lt;frame_end&gt;</code> is omitted, the end defaults to <code>CURRENT ROW</code>.</p></li><li><p>A <code>&lt;frame_start&gt;</code> of <code>UNBOUNDED PRECEDING</code> means that the frame starts with the first row of the partition, and similarly a <code>&lt;frame_end&gt;</code> of <code>UNBOUNDED FOLLOWING</code> means that the frame ends with the last row of the partition.</p></li><li><p>In <code>RANGE</code> or <code>GROUPS</code> mode, a <code>&lt;frame_start&gt;</code> of <code>CURRENT ROW</code> means the frame starts with the current row&#39;s first peer row (a row that the window&#39;s <code>ORDER BY</code> clause sorts as equivalent to the current row), while a <code>&lt;frame_end&gt;</code> of <code>CURRENT ROW</code> means the frame ends with the current row&#39;s last peer row. In <code>ROWS</code> mode, <code>CURRENT ROW</code> simply means the current row.</p></li><li><p>In the <code>&lt;offset&gt; PRECEDING</code> and <code>&lt;offset&gt; FOLLOWING</code> frame options, the <code>&lt;offset&gt;</code> must be an expression not containing any variables, aggregate functions, or window functions. The meaning of the <code>&lt;offset&gt;</code> depends on the frame mode:</p><ul><li><p>In <code>ROWS</code> mode, the <code>&lt;offset&gt;</code> must yield a non-null, non-negative integer, and the option means that the frame starts or ends the specified number of rows before or after the current row.</p></li><li><p>In <code>GROUPS</code> mode, the <code>&lt;offset&gt;</code> again must yield a non-null, non-negative integer, and the option means that the frame starts or ends the specified number of peer groups before or after the current row&#39;s peer group, where a peer group is a set of rows that are equivalent in the <code>ORDER BY</code> ordering. (There must be an <code>ORDER BY</code> clause in the window definition to use <code>GROUPS</code> mode).</p></li><li><p>In <code>RANGE</code> mode, these options require that the <code>ORDER BY</code> clause specifies exactly one column. The <code>&lt;offset&gt;</code> specifies the maximum difference between the value of that column in the current row and its value in preceding or following rows of the frame. The data type of the <code>&lt;offset&gt;</code> expression varies depending on the data type of the ordering column. For numeric ordering columns it is typically of the same type as the ordering column, but for datetime ordering columns it is an <code>interval</code>. For example, if the ordering column is of type <code>date</code> or <code>timestamp</code>, one could write <code>RANGE BETWEEN &#39;1 day&#39; PRECEDING AND &#39;10 days&#39; FOLLOWING</code>. The <code>&lt;offset&gt;</code> is still required to be non-null and non-negative, though the meaning of “non-negative” depends on its data type.</p></li></ul><p>In any case, the distance to the end of the frame is limited by the distance to the end of the partition, so that for rows near the partition ends the frame might contain fewer rows than elsewhere.</p></li><li><p>Notice that in both <code>ROWS</code> and <code>GROUPS</code> mode, <code>0 PRECEDING</code> and <code>0 FOLLOWING</code> are equivalent to <code>CURRENT ROW</code>. This normally holds in <code>RANGE</code> mode as well, for an appropriate data-type-specific meaning of “zero”.</p></li><li><p>The <code>&lt;frame_exclusion&gt;</code> option allows rows around the current row to be excluded from the frame, even if they would be included according to the frame start and frame end options. <code>EXCLUDE CURRENT ROW</code> excludes the current row from the frame. <code>EXCLUDE GROUP</code> excludes the current row and its ordering peers from the frame. <code>EXCLUDE TIES</code> excludes any peers of the current row from the frame, but not the current row itself. <code>EXCLUDE NO OTHERS</code> simply specifies explicitly the default behavior of not excluding the current row or its peers.</p></li><li><p>The default framing option is <code>RANGE UNBOUNDED PRECEDING</code>, which is the same as <code>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>. With <code>ORDER BY</code>, this sets the frame to be all rows from the partition start up through the current row&#39;s last <code>ORDER BY</code> peer. Without <code>ORDER BY</code>, this means all rows of the partition are included in the window frame, since all rows become peers of the current row.</p></li><li><p>Restrictions are that <code>&lt;frame_start&gt;</code> cannot be <code>UNBOUNDED FOLLOWING</code>, <code>&lt;frame_end&gt;</code> cannot be <code>UNBOUNDED PRECEDING</code>, and the <code>&lt;frame_end&gt;</code> choice cannot appear earlier in the above list than the <code>&lt;frame_start&gt;</code> choice. for example <code>RANGE BETWEEN CURRENT ROW AND value PRECEDING</code> is not allowed.</p></li></ul><h4 id="window-examples" tabindex="-1"><a id="topic_qck_12r_2gb"></a>Window Examples <a class="header-anchor" href="#window-examples" aria-label="Permalink to &quot;&lt;a id=&quot;topic_qck_12r_2gb&quot;&gt;&lt;/a&gt;Window Examples&quot;">​</a></h4><p>The following examples demonstrate using window functions with partitions and window frames.</p><h5 id="example-1-–-aggregate-window-function-over-a-partition" tabindex="-1"><a id="ex1"></a>Example 1 – Aggregate Window Function Over a Partition <a class="header-anchor" href="#example-1-–-aggregate-window-function-over-a-partition" aria-label="Permalink to &quot;&lt;a id=&quot;ex1&quot;&gt;&lt;/a&gt;Example 1 – Aggregate Window Function Over a Partition&quot;">​</a></h5><p>The <code>PARTITION BY</code> list in the <code>OVER</code> clause divides the rows into groups, or partitions, that have the same values as the specified expressions.</p><p>This example compares employees&#39; salaries with the average salaries for their departments:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT depname, empno, salary, avg(salary) OVER(PARTITION BY depname)</span></span>
<span class="line"><span>FROM empsalary;</span></span>
<span class="line"><span>  depname  | empno | salary |          avg          </span></span>
<span class="line"><span>-----------+-------+--------+-----------------------</span></span>
<span class="line"><span> develop   |     9 |   4500 | 5020.0000000000000000</span></span>
<span class="line"><span> develop   |    10 |   5200 | 5020.0000000000000000</span></span>
<span class="line"><span> develop   |    11 |   5200 | 5020.0000000000000000</span></span>
<span class="line"><span> develop   |     7 |   4200 | 5020.0000000000000000</span></span>
<span class="line"><span> develop   |     8 |   6000 | 5020.0000000000000000</span></span>
<span class="line"><span> personnel |     5 |   3500 | 3700.0000000000000000</span></span>
<span class="line"><span> personnel |     2 |   3900 | 3700.0000000000000000</span></span>
<span class="line"><span> sales     |     1 |   5000 | 4866.6666666666666667</span></span>
<span class="line"><span> sales     |     3 |   4800 | 4866.6666666666666667</span></span>
<span class="line"><span> sales     |     4 |   4800 | 4866.6666666666666667</span></span>
<span class="line"><span>(10 rows)</span></span></code></pre></div><p>The first three output columns come from the table <code>empsalary</code>, and there is one output row for each row in the table. The fourth column is the average calculated on all rows that have the same <code>depname</code> value as the current row. Rows that share the same <code>depname</code> value constitute a partition, and there are three partitions in this example. The <code>avg</code> function is the same as the regular <code>avg</code> aggregate function, but the <code>OVER</code> clause causes it to be applied as a window function.</p><p>You can also put the window specification in a <code>WINDOW</code> clause and reference it in the select list. This example is equivalent to the previous query:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT depname, empno, salary, avg(salary) OVER(mywindow)</span></span>
<span class="line"><span>FROM empsalary</span></span>
<span class="line"><span>WINDOW mywindow AS (PARTITION BY depname);</span></span></code></pre></div><p>Defining a named window is useful when the select list has multiple window functions using the same window specification.</p><h5 id="example-2-–-ranking-window-function-with-an-order-by-clause" tabindex="-1"><a id="ex2"></a>Example 2 – Ranking Window Function With an ORDER BY Clause <a class="header-anchor" href="#example-2-–-ranking-window-function-with-an-order-by-clause" aria-label="Permalink to &quot;&lt;a id=&quot;ex2&quot;&gt;&lt;/a&gt;Example 2 – Ranking Window Function With an ORDER BY Clause&quot;">​</a></h5><p>An <code>ORDER BY</code> clause within the <code>OVER</code> clause controls the order in which rows are processed by window functions. The <code>ORDER BY</code> list for the window function does not have to match the output order of the query. This example uses the <code>rank()</code> window function to rank employees&#39; salaries within their departments:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT depname, empno, salary,</span></span>
<span class="line"><span>    rank() OVER (PARTITION BY depname ORDER BY salary DESC)</span></span>
<span class="line"><span>FROM empsalary;</span></span>
<span class="line"><span>  depname  | empno | salary | rank </span></span>
<span class="line"><span>-----------+-------+--------+------</span></span>
<span class="line"><span> develop   |     8 |   6000 |    1</span></span>
<span class="line"><span> develop   |    11 |   5200 |    2</span></span>
<span class="line"><span> develop   |    10 |   5200 |    2</span></span>
<span class="line"><span> develop   |     9 |   4500 |    4</span></span>
<span class="line"><span> develop   |     7 |   4200 |    5</span></span>
<span class="line"><span> personnel |     2 |   3900 |    1</span></span>
<span class="line"><span> personnel |     5 |   3500 |    2</span></span>
<span class="line"><span> sales     |     1 |   5000 |    1</span></span>
<span class="line"><span> sales     |     4 |   4800 |    2</span></span>
<span class="line"><span> sales     |     3 |   4800 |    2</span></span>
<span class="line"><span>(10 rows)</span></span></code></pre></div><h5 id="example-3-–-aggregate-function-over-a-row-window-frame" tabindex="-1"><a id="ex3"></a>Example 3 – Aggregate Function over a Row Window Frame <a class="header-anchor" href="#example-3-–-aggregate-function-over-a-row-window-frame" aria-label="Permalink to &quot;&lt;a id=&quot;ex3&quot;&gt;&lt;/a&gt;Example 3 – Aggregate Function over a Row Window Frame&quot;">​</a></h5><p>A <code>RANGE</code>, <code>ROWS</code> or <code>GROUPS</code> clause defines the window frame—a set of rows within a partition—that the window function includes in the calculation. <code>ROWS</code> specifies a physical set of rows to process, for example all rows from the beginning of the partition to the current row.</p><p>This example calculates a running total of employee&#39;s salaries by department using the <code>sum()</code> function to total rows from the start of the partition to the current row:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT depname, empno, salary,</span></span>
<span class="line"><span>    sum(salary) OVER (PARTITION BY depname ORDER BY salary</span></span>
<span class="line"><span>        ROWS between UNBOUNDED PRECEDING AND CURRENT ROW)</span></span>
<span class="line"><span>FROM empsalary ORDER BY depname, sum;</span></span>
<span class="line"><span>  depname  | empno | salary |  sum  </span></span>
<span class="line"><span>-----------+-------+--------+-------</span></span>
<span class="line"><span> develop   |     7 |   4200 |  4200</span></span>
<span class="line"><span> develop   |     9 |   4500 |  8700</span></span>
<span class="line"><span> develop   |    11 |   5200 | 13900</span></span>
<span class="line"><span> develop   |    10 |   5200 | 19100</span></span>
<span class="line"><span> develop   |     8 |   6000 | 25100</span></span>
<span class="line"><span> personnel |     5 |   3500 |  3500</span></span>
<span class="line"><span> personnel |     2 |   3900 |  7400</span></span>
<span class="line"><span> sales     |     4 |   4800 |  4800</span></span>
<span class="line"><span> sales     |     3 |   4800 |  9600</span></span>
<span class="line"><span> sales     |     1 |   5000 | 14600</span></span>
<span class="line"><span>(10 rows)</span></span></code></pre></div><h5 id="example-4-–-aggregate-function-for-a-range-or-groups-window-frame" tabindex="-1"><a id="ex4"></a>Example 4 – Aggregate Function for a Range or Groups Window Frame <a class="header-anchor" href="#example-4-–-aggregate-function-for-a-range-or-groups-window-frame" aria-label="Permalink to &quot;&lt;a id=&quot;ex4&quot;&gt;&lt;/a&gt;Example 4 – Aggregate Function for a Range or Groups Window Frame&quot;">​</a></h5><p><code>RANGE</code> and <code>GROUPS</code> modes specify logical values based on values of the <code>ORDER BY</code> expression in the <code>OVER</code> clause. This example demonstrates the difference between <code>ROWS</code> and <code>RANGE</code> or <code>GROUPS</code>. The frame contains all rows with salary values less than or equal to the current row. Unlike the previous example, for employees with the same salary, the sum is the same and includes the salaries of all of those employees.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT depname, empno, salary,</span></span>
<span class="line"><span>    sum(salary) OVER (PARTITION BY depname ORDER BY salary</span></span>
<span class="line"><span>        RANGE between UNBOUNDED PRECEDING AND CURRENT ROW)</span></span>
<span class="line"><span>FROM empsalary ORDER BY depname, sum;</span></span>
<span class="line"><span>  depname  | empno | salary |  sum  </span></span>
<span class="line"><span>-----------+-------+--------+-------</span></span>
<span class="line"><span> develop   |     7 |   4200 |  4200</span></span>
<span class="line"><span> develop   |     9 |   4500 |  8700</span></span>
<span class="line"><span> develop   |    11 |   5200 | 19100</span></span>
<span class="line"><span> develop   |    10 |   5200 | 19100</span></span>
<span class="line"><span> develop   |     8 |   6000 | 25100</span></span>
<span class="line"><span> personnel |     5 |   3500 |  3500</span></span>
<span class="line"><span> personnel |     2 |   3900 |  7400</span></span>
<span class="line"><span> sales     |     4 |   4800 |  9600</span></span>
<span class="line"><span> sales     |     3 |   4800 |  9600</span></span>
<span class="line"><span> sales     |     1 |   5000 | 14600</span></span>
<span class="line"><span>(10 rows)</span></span></code></pre></div><p>In this example, since the <code>&lt;frame_start&gt;</code> and <code>&lt;frame_end&gt;</code> are not using an <code>&lt;offset&gt;</code>, <code>RANGE</code> and <code>GROUPS</code> mode provide identical results:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT depname, empno, salary,</span></span>
<span class="line"><span>    sum(salary) OVER (PARTITION BY depname ORDER BY salary</span></span>
<span class="line"><span>        GROUPS between UNBOUNDED PRECEDING AND CURRENT ROW)</span></span>
<span class="line"><span>FROM empsalary ORDER BY depname, sum;</span></span>
<span class="line"><span>  depname  | empno | salary |  sum</span></span>
<span class="line"><span>-----------+-------+--------+-------</span></span>
<span class="line"><span> develop   |     7 |   4200 |  4200</span></span>
<span class="line"><span> develop   |     9 |   4500 |  8700</span></span>
<span class="line"><span> develop   |    11 |   5200 | 19100</span></span>
<span class="line"><span> develop   |    10 |   5200 | 19100</span></span>
<span class="line"><span> develop   |     8 |   6000 | 25100</span></span>
<span class="line"><span> personnel |     5 |   3500 |  3500</span></span>
<span class="line"><span> personnel |     2 |   3900 |  7400</span></span>
<span class="line"><span> sales     |     4 |   4800 |  9600</span></span>
<span class="line"><span> sales     |     3 |   4800 |  9600</span></span>
<span class="line"><span> sales     |     1 |   5000 | 14600</span></span>
<span class="line"><span>(10 rows)</span></span></code></pre></div><h5 id="example-5-–-aggregate-function-for-a-range-and-a-groups-window-frame" tabindex="-1"><a id="ex4"></a>Example 5 – Aggregate Function for a Range and a Groups Window Frame <a class="header-anchor" href="#example-5-–-aggregate-function-for-a-range-and-a-groups-window-frame" aria-label="Permalink to &quot;&lt;a id=&quot;ex4&quot;&gt;&lt;/a&gt;Example 5 – Aggregate Function for a Range and a Groups Window Frame&quot;">​</a></h5><p>This example demonstrates the difference between <code>RANGE</code> and <code>GROUPS</code>. The table <code>sales</code> lists the sales a company&#39;s two shops during a period of four days.</p><p>When using <code>GROUPS</code> mode, the value of <code>&lt;offset&gt;</code> indicates the number of peer groups before the current row&#39;s peer group. The different peer groups are set by the <code>ORDER BY</code> clause, in this case the date. Since the query does not specify a value for <code>&lt;frame_end&gt;</code>, the end defaults to <code>CURRENT ROW</code>.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT date, shop, total, sum(total) OVER (PARTITION BY shop ORDER BY date asc GROUPS 2 PRECEDING) </span></span>
<span class="line"><span>FROM sales ORDER BY shop, date;</span></span>
<span class="line"><span>    date    |  shop  |  total  |   sum    </span></span>
<span class="line"><span>------------+--------+---------+----------</span></span>
<span class="line"><span> 2022-01-07 | Shop 1 | 3000.00 |  3000.00</span></span>
<span class="line"><span> 2022-01-08 | Shop 1 | 1000.00 |  4000.00</span></span>
<span class="line"><span> 2022-01-09 | Shop 1 | 5000.00 | 11000.00</span></span>
<span class="line"><span> 2022-01-09 | Shop 1 | 2000.00 | 11000.00</span></span>
<span class="line"><span> 2022-01-07 | Shop 2 | 4000.00 | 10000.00</span></span>
<span class="line"><span> 2022-01-07 | Shop 2 | 6000.00 | 10000.00</span></span>
<span class="line"><span> 2022-01-09 | Shop 2 | 7000.00 | 21000.00</span></span>
<span class="line"><span> 2022-01-09 | Shop 2 | 4000.00 | 21000.00</span></span>
<span class="line"><span> 2022-01-10 | Shop 2 | 2000.00 | 23000.00</span></span>
<span class="line"><span>(9 rows)</span></span></code></pre></div><p>In order to get the equivalent result when using the <code>RANGE</code> mode, the <code>&lt;frame_clause&gt;</code> must specify an <code>&lt;offset&gt;</code> using the same data type as the ordering column, in this case <code>date</code>. Using the numberic value <code>2</code> will return an error.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT date, shop, total, sum(total) OVER (PARTITION BY shop ORDER BY date asc RANGE &#39;2 days&#39; PRECEDING) </span></span>
<span class="line"><span>FROM sales ORDER BY shop, date;</span></span>
<span class="line"><span>    date    |  shop  |  total  |   sum    </span></span>
<span class="line"><span>------------+--------+---------+----------</span></span>
<span class="line"><span> 2022-01-07 | Shop 1 | 3000.00 |  3000.00</span></span>
<span class="line"><span> 2022-01-08 | Shop 1 | 1000.00 |  4000.00</span></span>
<span class="line"><span> 2022-01-09 | Shop 1 | 5000.00 | 11000.00</span></span>
<span class="line"><span> 2022-01-09 | Shop 1 | 2000.00 | 11000.00</span></span>
<span class="line"><span> 2022-01-07 | Shop 2 | 4000.00 | 10000.00</span></span>
<span class="line"><span> 2022-01-07 | Shop 2 | 6000.00 | 10000.00</span></span>
<span class="line"><span> 2022-01-09 | Shop 2 | 7000.00 | 21000.00</span></span>
<span class="line"><span> 2022-01-09 | Shop 2 | 4000.00 | 21000.00</span></span>
<span class="line"><span> 2022-01-10 | Shop 2 | 2000.00 | 13000.00</span></span>
<span class="line"><span>(9 rows)</span></span></code></pre></div><p>Note that the above outputs differ in the last row because <code>RANGE</code> mode uses the entries from the previous two days and there is no entry for <code>2022-01-08</code> for Shop 2, but <code>GROUPS</code> mode uses the previous two peer groups, which are <code>2022-01-07</code> and <code>2022-01-09</code>.</p><h3 id="type-casts" tabindex="-1"><a id="topic14"></a>Type Casts <a class="header-anchor" href="#type-casts" aria-label="Permalink to &quot;&lt;a id=&quot;topic14&quot;&gt;&lt;/a&gt;Type Casts&quot;">​</a></h3><p>A type cast specifies a conversion from one data type to another. A cast applied to a value expression of a known type is a run-time type conversion. The cast succeeds only if a suitable type conversion is defined. This differs from the use of casts with constants. A cast applied to a string literal represents the initial assignment of a type to a literal constant value, so it succeeds for any type if the contents of the string literal are acceptable input syntax for the data type.</p><p>WarehousePG supports three types of casts applied to a value expression:</p><ul><li><p><em>Explicit cast</em> - WarehousePG applies a cast when you explicitly specify a cast between two data types. WarehousePG accepts two equivalent syntaxes for explicit type casts:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CAST ( expression AS type )</span></span>
<span class="line"><span>expression::type</span></span></code></pre></div><p>The <code>CAST</code> syntax conforms to SQL; the syntax using <code>::</code> is historical PostgreSQL usage.</p></li><li><p><em>Assignment cast</em> - WarehousePG implicitly invokes a cast in assignment contexts, when assigning a value to a column of the target data type. For example, a <a href="./../../../ref_guide/sql_commands/CREATE_CAST.html">CREATE CAST</a> command with the <code>AS ASSIGNMENT</code> clause creates a cast that is applied implicitly in the assignment context. This example assignment cast assumes that <code>tbl1.f1</code> is a column of type <code>text</code>. The <code>INSERT</code> command is allowed because the value is implicitly cast from the <code>integer</code> to <code>text</code> type.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>INSERT INTO tbl1 (f1) VALUES (42);</span></span></code></pre></div></li><li><p><em>Implicit cast</em> - WarehousePG implicitly invokes a cast in assignment or expression contexts. For example, a <code>CREATE CAST</code> command with the <code>AS IMPLICIT</code> clause creates an implicit cast, a cast that is applied implicitly in both the assignment and expression context. This example implicit cast assumes that <code>tbl1.c1</code> is a column of type <code>int</code>. For the calculation in the predicate, the value of <code>c1</code> is implicitly cast from <code>int</code> to a <code>decimal</code> type.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT * FROM tbl1 WHERE tbl1.c2 = (4.3 + tbl1.c1) ;</span></span></code></pre></div></li></ul><p>You can usually omit an explicit type cast if there is no ambiguity about the type a value expression must produce (for example, when it is assigned to a table column); the system automatically applies a type cast. WarehousePG implicitly applies casts only to casts defined with a cast context of assignment or explicit in the system catalogs. Other casts must be invoked with explicit casting syntax to prevent unexpected conversions from being applied without the user&#39;s knowledge.</p><p>You can display cast information with the <code>psql</code> meta-command <code>\\dC</code>. Cast information is stored in the catalog table <code>pg_cast</code>, and type information is stored in the catalog table <code>pg_type</code>.</p><h3 id="scalar-subqueries" tabindex="-1"><a id="topic15"></a>Scalar Subqueries <a class="header-anchor" href="#scalar-subqueries" aria-label="Permalink to &quot;&lt;a id=&quot;topic15&quot;&gt;&lt;/a&gt;Scalar Subqueries&quot;">​</a></h3><p>A scalar subquery is a <code>SELECT</code> query in parentheses that returns exactly one row with one column. Do not use a <code>SELECT</code> query that returns multiple rows or columns as a scalar subquery. The query runs and uses the returned value in the surrounding value expression. A correlated scalar subquery contains references to the outer query block.</p><h3 id="correlated-subqueries" tabindex="-1"><a id="topic16"></a>Correlated Subqueries <a class="header-anchor" href="#correlated-subqueries" aria-label="Permalink to &quot;&lt;a id=&quot;topic16&quot;&gt;&lt;/a&gt;Correlated Subqueries&quot;">​</a></h3><p>A correlated subquery (CSQ) is a <code>SELECT</code> query with a <code>WHERE</code> clause or target list that contains references to the parent outer clause. CSQs efficiently express results in terms of results of another query. WarehousePG supports correlated subqueries that provide compatibility with many existing applications. A CSQ is a scalar or table subquery, depending on whether it returns one or multiple rows. WarehousePG does not support correlated subqueries with skip-level correlations.</p><h3 id="correlated-subquery-examples" tabindex="-1"><a id="topic17"></a>Correlated Subquery Examples <a class="header-anchor" href="#correlated-subquery-examples" aria-label="Permalink to &quot;&lt;a id=&quot;topic17&quot;&gt;&lt;/a&gt;Correlated Subquery Examples&quot;">​</a></h3><h4 id="example-1-–-scalar-correlated-subquery" tabindex="-1"><a id="topic18"></a>Example 1 – Scalar correlated subquery <a class="header-anchor" href="#example-1-–-scalar-correlated-subquery" aria-label="Permalink to &quot;&lt;a id=&quot;topic18&quot;&gt;&lt;/a&gt;Example 1 – Scalar correlated subquery&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT * FROM t1 WHERE t1.x </span></span>
<span class="line"><span>            &gt; (SELECT MAX(t2.x) FROM t2 WHERE t2.y = t1.y);</span></span></code></pre></div><h4 id="example-2-–-correlated-exists-subquery" tabindex="-1"><a id="topic19"></a>Example 2 – Correlated EXISTS subquery <a class="header-anchor" href="#example-2-–-correlated-exists-subquery" aria-label="Permalink to &quot;&lt;a id=&quot;topic19&quot;&gt;&lt;/a&gt;Example 2 – Correlated EXISTS subquery&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT * FROM t1 WHERE </span></span>
<span class="line"><span>EXISTS (SELECT 1 FROM t2 WHERE t2.x = t1.x);</span></span></code></pre></div><p>WarehousePG uses one of the following methods to run CSQs:</p><ul><li>Unnest the CSQ into join operations – This method is most efficient, and it is how WarehousePG runs most CSQs, including queries from the TPC-H benchmark.</li><li>Run the CSQ on every row of the outer query – This method is relatively inefficient, and it is how WarehousePG runs queries that contain CSQs in the <code>SELECT</code> list or are connected by <code>OR</code> conditions.</li></ul><p>The following examples illustrate how to rewrite some of these types of queries to improve performance.</p><h4 id="example-3-csq-in-the-select-list" tabindex="-1"><a id="topic20"></a>Example 3 - CSQ in the Select List <a class="header-anchor" href="#example-3-csq-in-the-select-list" aria-label="Permalink to &quot;&lt;a id=&quot;topic20&quot;&gt;&lt;/a&gt;Example 3 - CSQ in the Select List&quot;">​</a></h4><p><em>Original Query</em></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT T1.a,</span></span>
<span class="line"><span>      (SELECT COUNT(DISTINCT T2.z) FROM t2 WHERE t1.x = t2.y) dt2 </span></span>
<span class="line"><span>FROM t1;</span></span></code></pre></div><p>Rewrite this query to perform an inner join with <code>t1</code> first and then perform a left join with <code>t1</code> again. The rewrite applies for only an equijoin in the correlated condition.</p><p><em>Rewritten Query</em></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT t1.a, dt2 FROM t1 </span></span>
<span class="line"><span>       LEFT JOIN </span></span>
<span class="line"><span>        (SELECT t2.y AS csq_y, COUNT(DISTINCT t2.z) AS dt2 </span></span>
<span class="line"><span>              FROM t1, t2 WHERE t1.x = t2.y </span></span>
<span class="line"><span>              GROUP BY t1.x) </span></span>
<span class="line"><span>       ON (t1.x = csq_y);</span></span></code></pre></div><h3 id="example-4-csqs-connected-by-or-clauses" tabindex="-1"><a id="topic21"></a>Example 4 - CSQs connected by OR Clauses <a class="header-anchor" href="#example-4-csqs-connected-by-or-clauses" aria-label="Permalink to &quot;&lt;a id=&quot;topic21&quot;&gt;&lt;/a&gt;Example 4 - CSQs connected by OR Clauses&quot;">​</a></h3><p><em>Original Query</em></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT * FROM t1 </span></span>
<span class="line"><span>WHERE </span></span>
<span class="line"><span>x &gt; (SELECT COUNT(*) FROM t2 WHERE t1.x = t2.x) </span></span>
<span class="line"><span>OR x &lt; (SELECT COUNT(*) FROM t3 WHERE t1.y = t3.y)</span></span></code></pre></div><p>Rewrite this query to separate it into two parts with a union on the <code>OR</code> conditions.</p><p><em>Rewritten Query</em></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT * FROM t1 </span></span>
<span class="line"><span>WHERE x &gt; (SELECT count(*) FROM t2 WHERE t1.x = t2.x) </span></span>
<span class="line"><span>UNION </span></span>
<span class="line"><span>SELECT * FROM t1 </span></span>
<span class="line"><span>WHERE x &lt; (SELECT count(*) FROM t3 WHERE t1.y = t3.y)</span></span></code></pre></div><p>To view the query plan, use <code>EXPLAIN SELECT</code> or <code>EXPLAIN ANALYZE SELECT</code>. Subplan nodes in the query plan indicate that the query will run on every row of the outer query, and the query is a candidate for rewriting. For more information about these statements, see <a href="./query-profiling.html">Query Profiling</a>.</p><h3 id="array-constructors" tabindex="-1"><a id="topic23"></a>Array Constructors <a class="header-anchor" href="#array-constructors" aria-label="Permalink to &quot;&lt;a id=&quot;topic23&quot;&gt;&lt;/a&gt;Array Constructors&quot;">​</a></h3><p>An array constructor is an expression that builds an array value from values for its member elements. A simple array constructor consists of the key word <code>ARRAY</code>, a left square bracket <code>[</code>, one or more expressions separated by commas for the array element values, and a right square bracket <code>]</code>. For example,</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT ARRAY[1,2,3+4];</span></span>
<span class="line"><span>  array</span></span>
<span class="line"><span>---------</span></span>
<span class="line"><span> {1,2,7}</span></span></code></pre></div><p>The array element type is the common type of its member expressions, determined using the same rules as for <code>UNION</code> or <code>CASE</code> constructs.</p><p>You can build multidimensional array values by nesting array constructors. In the inner constructors, you can omit the keyword <code>ARRAY</code>. For example, the following two <code>SELECT</code> statements produce the same result:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];</span></span>
<span class="line"><span>SELECT ARRAY[[1,2],[3,4]];</span></span>
<span class="line"><span>     array</span></span>
<span class="line"><span>---------------</span></span>
<span class="line"><span> {{1,2},{3,4}}</span></span></code></pre></div><p>Since multidimensional arrays must be rectangular, inner constructors at the same level must produce sub-arrays of identical dimensions.</p><p>Multidimensional array constructor elements are not limited to a sub-<code>ARRAY</code> construct; they are anything that produces an array of the proper kind. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE TABLE arr(f1 int[], f2 int[]);</span></span>
<span class="line"><span>INSERT INTO arr VALUES (ARRAY[[1,2],[3,4]], </span></span>
<span class="line"><span>ARRAY[[5,6],[7,8]]);</span></span>
<span class="line"><span>SELECT ARRAY[f1, f2, &#39;{{9,10},{11,12}}&#39;::int[]] FROM arr;</span></span>
<span class="line"><span>                     array</span></span>
<span class="line"><span>------------------------------------------------</span></span>
<span class="line"><span> {{{1,2},{3,4}},{{5,6},{7,8}},{{9,10},{11,12}}}</span></span></code></pre></div><p>You can construct an array from the results of a subquery. Write the array constructor with the keyword <code>ARRAY</code> followed by a subquery in parentheses. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE &#39;bytea%&#39;);</span></span>
<span class="line"><span>                          ?column?</span></span>
<span class="line"><span>-----------------------------------------------------------</span></span>
<span class="line"><span> {2011,1954,1948,1952,1951,1244,1950,2005,1949,1953,2006,31}</span></span></code></pre></div><p>The subquery must return a single column. The resulting one-dimensional array has an element for each row in the subquery result, with an element type matching that of the subquery&#39;s output column. The subscripts of an array value built with <code>ARRAY</code> always begin with <code>1</code>.</p><h3 id="row-constructors" tabindex="-1"><a id="topic24"></a>Row Constructors <a class="header-anchor" href="#row-constructors" aria-label="Permalink to &quot;&lt;a id=&quot;topic24&quot;&gt;&lt;/a&gt;Row Constructors&quot;">​</a></h3><p>A row constructor is an expression that builds a row value (also called a composite value) from values for its member fields. For example,</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT ROW(1,2.5,&#39;this is a test&#39;);</span></span></code></pre></div><p>Row constructors have the syntax <code>rowvalue.*</code>, which expands to a list of the elements of the row value, as when you use the syntax <code>.*</code> at the top level of a <code>SELECT</code> list. For example, if table <code>t</code> has columns <code>f1</code> and <code>f2</code>, the following queries are the same:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT ROW(t.*, 42) FROM t;</span></span>
<span class="line"><span>SELECT ROW(t.f1, t.f2, 42) FROM t;</span></span></code></pre></div><p>By default, the value created by a <code>ROW</code> expression has an anonymous record type. If necessary, it can be cast to a named composite type — either the row type of a table, or a composite type created with <code>CREATE TYPE AS</code>. To avoid ambiguity, you can explicitly cast the value if necessary. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE TABLE mytable(f1 int, f2 float, f3 text);</span></span>
<span class="line"><span>CREATE FUNCTION getf1(mytable) RETURNS int AS &#39;SELECT $1.f1&#39; </span></span>
<span class="line"><span>LANGUAGE SQL;</span></span></code></pre></div><p>In the following query, you do not need to cast the value because there is only one <code>getf1()</code> function and therefore no ambiguity:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT getf1(ROW(1,2.5,&#39;this is a test&#39;));</span></span>
<span class="line"><span> getf1</span></span>
<span class="line"><span>-------</span></span>
<span class="line"><span>     1</span></span>
<span class="line"><span>CREATE TYPE myrowtype AS (f1 int, f2 text, f3 numeric);</span></span>
<span class="line"><span>CREATE FUNCTION getf1(myrowtype) RETURNS int AS &#39;SELECT </span></span>
<span class="line"><span>$1.f1&#39; LANGUAGE SQL;</span></span></code></pre></div><p>Now we need a cast to indicate which function to call:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT getf1(ROW(1,2.5,&#39;this is a test&#39;));</span></span>
<span class="line"><span>ERROR:  function getf1(record) is not unique</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT getf1(ROW(1,2.5,&#39;this is a test&#39;)::mytable);</span></span>
<span class="line"><span> getf1</span></span>
<span class="line"><span>-------</span></span>
<span class="line"><span>     1</span></span>
<span class="line"><span>SELECT getf1(CAST(ROW(11,&#39;this is a test&#39;,2.5) AS </span></span>
<span class="line"><span>myrowtype));</span></span>
<span class="line"><span> getf1</span></span>
<span class="line"><span>-------</span></span>
<span class="line"><span>    11</span></span></code></pre></div><p>You can use row constructors to build composite values to be stored in a composite-type table column or to be passed to a function that accepts a composite parameter.</p><h3 id="expression-evaluation-rules" tabindex="-1"><a id="topic25"></a>Expression Evaluation Rules <a class="header-anchor" href="#expression-evaluation-rules" aria-label="Permalink to &quot;&lt;a id=&quot;topic25&quot;&gt;&lt;/a&gt;Expression Evaluation Rules&quot;">​</a></h3><p>The order of evaluation of subexpressions is undefined. The inputs of an operator or function are not necessarily evaluated left-to-right or in any other fixed order.</p><p>If you can determine the result of an expression by evaluating only some parts of the expression, then other subexpressions might not be evaluated at all. For example, in the following expression:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT true OR somefunc();</span></span></code></pre></div><p><code>somefunc()</code> would probably not be called at all. The same is true in the following expression:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT somefunc() OR true;</span></span></code></pre></div><p>This is not the same as the left-to-right evaluation order that Boolean operators enforce in some programming languages.</p><p>Do not use functions with side effects as part of complex expressions, especially in <code>WHERE</code> and <code>HAVING</code> clauses, because those clauses are extensively reprocessed when developing an execution plan. Boolean expressions (<code>AND</code>/<code>OR</code>/<code>NOT</code> combinations) in those clauses can be reorganized in any manner that Boolean algebra laws allow.</p><p>Use a <code>CASE</code> construct to force evaluation order. The following example is an untrustworthy way to avoid division by zero in a <code>WHERE</code> clause:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT ... WHERE x &lt;&gt; 0 AND y/x &gt; 1.5;</span></span></code></pre></div><p>The following example shows a trustworthy evaluation order:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT ... WHERE CASE WHEN x &lt;&gt; 0 THEN y/x &gt; 1.5 ELSE false </span></span>
<span class="line"><span>END;</span></span></code></pre></div><p>This <code>CASE</code> construct usage defeats optimization attempts; use it only when necessary.</p>`,194)]))}const g=a(o,[["render",i]]);export{h as __pageData,g as default};
