import{_ as t,c as r,o as a,ag as o}from"./chunks/framework.Ds6Eueu6.js";const h=JSON.parse('{"title":"Managing Resources","description":"","frontmatter":{},"headers":[],"relativePath":"docs/7x/admin_guide/wlmgmt.md","filePath":"docs/7x/admin_guide/wlmgmt.md"}'),s={name:"docs/7x/admin_guide/wlmgmt.md"};function n(d,e,i,u,c,m){return a(),r("div",null,e[0]||(e[0]=[o('<h1 id="managing-resources" tabindex="-1">Managing Resources <a class="header-anchor" href="#managing-resources" aria-label="Permalink to &quot;Managing Resources&quot;">â€‹</a></h1><hr><p>WarehousePG provides features to help you prioritize and allocate resources to queries according to business requirements and to prevent queries from starting when resources are unavailable.</p><p>You can use resource management features to limit the number of concurrent queries, the amount of memory used to run a query, and the relative amount of CPU devoted to processing a query. WarehousePG provides two schemes to manage resources: <a href="./workload_mgmt.html">Resource Queues</a> and <a href="./workload_mgmt_resgroups.html">Resource Groups</a>.</p><p>Either the resource queue or the resource group management scheme can be active in WarehousePG; both schemes cannot be active at the same time. Set the server configuration parameter <a href="./../ref_guide/config_params/guc-list.html.html#gp_resource_manager">gp_resource_manager</a> to enable the preferred scheme in the WarehousePG cluster.</p><p>The following table summarizes some of the differences between resource queues and resource groups.</p><table tabindex="0"><thead><tr><th>Metric</th><th>Resource Queues</th><th>Resource Groups</th></tr></thead><tbody><tr><td>Concurrency</td><td>Defines the number of query slots available at a time</td><td>Defines the number of transaction slots available at a time</td></tr><tr><td>CPU</td><td>Specify query priority</td><td>Specify percentage of CPU resources or the specific number of CPU cores; uses Linux Control Groups</td></tr><tr><td>Memory</td><td>Managed at the queue and operator level; users can over-subscribe</td><td>Managed at the transaction level, with enhanced allocation and tracking; users can over-subscribe</td></tr><tr><td>Users</td><td>Limits are applied only to non-admin users</td><td>Limits are applied to <code>SUPERUSER</code>, non-admin users, and system processes of non-user classes</td></tr><tr><td>Disk I/O</td><td>None</td><td>Limit the maximum read/write disk I/O throughput, and maximum read/write I/O operations per second</td></tr><tr><td>Queueing</td><td>Queue when no slot available or not enough available memory</td><td>Queue only when no slot is available</td></tr><tr><td>Query Failure</td><td>Query may fail immediately if the allocated memory for the query surpasses the available system memory and spill limits</td><td>Query may fail if the allocated memory for the query surpasses the available system memory and spill limits</td></tr><tr><td>Limit Bypass</td><td>Limits are not enforced for <code>SUPERUSER</code> roles and certain operators and functions</td><td>Limits are not enforced on <code>SET</code>, <code>RESET</code>, and <code>SHOW</code> commands. Additionally, certain queries may be configured to bypass the concurrency limit</td></tr><tr><td>External Components</td><td>None</td><td>Manage PL/Container CPU resources</td></tr></tbody></table><p><strong>Parent topic:</strong> <a href="./performance.thml.html">Managing Performance</a></p>',8)]))}const p=t(s,[["render",n]]);export{h as __pageData,p as default};
