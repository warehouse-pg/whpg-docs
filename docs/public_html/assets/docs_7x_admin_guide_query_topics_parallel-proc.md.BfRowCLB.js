import{_ as t,c as a,o as s,ag as o}from"./chunks/framework.Ds6Eueu6.js";const n="/assets/parallel_plan.CeZv931Q.jpg",r="/assets/targeted_dispatch.DD6mRu6I.jpg",i="/assets/slice_plan.jU64mmfx.jpg",l="/assets/gangs.Bb04npb-.jpg",q=JSON.parse('{"title":"About WarehousePG Query Processing","description":"","frontmatter":{},"headers":[],"relativePath":"docs/7x/admin_guide/query/topics/parallel-proc.md","filePath":"docs/7x/admin_guide/query/topics/parallel-proc.md"}'),p={name:"docs/7x/admin_guide/query/topics/parallel-proc.md"};function c(d,e,u,h,m,g){return s(),a("div",null,e[0]||(e[0]=[o('<h1 id="about-warehousepg-query-processing" tabindex="-1">About WarehousePG Query Processing <a class="header-anchor" href="#about-warehousepg-query-processing" aria-label="Permalink to &quot;About WarehousePG Query Processing&quot;">​</a></h1><hr><p>This topic provides an overview of how WarehousePG processes queries. Understanding this process can be useful when writing and tuning queries.</p><p>Users issue queries to WarehousePG as they would to any database management system. They connect to the database instance on the WarehousePG coordinator host using a client application such as <code>psql</code> and submit SQL statements.</p><p><strong>Parent topic:</strong> <a href="./../../query/topics/query.html">SQL: Querying Data</a></p><h2 id="understanding-query-planning-and-dispatch" tabindex="-1"><a id="topic2"></a>Understanding Query Planning and Dispatch <a class="header-anchor" href="#understanding-query-planning-and-dispatch" aria-label="Permalink to &quot;&lt;a id=&quot;topic2&quot;&gt;&lt;/a&gt;Understanding Query Planning and Dispatch&quot;">​</a></h2><p>The coordinator receives, parses, and optimizes the query. The resulting query plan is either parallel or targeted. The coordinator dispatches parallel query plans to all segments.</p><p><img src="'+n+'" alt="Dispatching the Parallel Query Plan" title="Dispatching the Parallel Query Plan"></p><p>The coordinator dispatches targeted query plans to a single segment. Each segment is responsible for running local database operations on its own set of data. Most database operations—such as table scans, joins, aggregations, and sorts—run across all segments in parallel. Each operation is performed on a segment database independent of the data stored in the other segment databases.</p><p><img src="'+r+`" alt="Dispatching a Targeted Query Plan" title="Dispatching a Targeted Query Plan"></p><p>Certain queries may access only data on a single segment, such as single-row <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, or <code>SELECT</code> operations or queries that filter on the table distribution key column(s). In queries such as these, the query plan is not dispatched to all segments, but is targeted at the segment that contains the affected or relevant row(s).</p><h2 id="understanding-warehousepg-query-plans" tabindex="-1"><a id="topic3"></a>Understanding WarehousePG Query Plans <a class="header-anchor" href="#understanding-warehousepg-query-plans" aria-label="Permalink to &quot;&lt;a id=&quot;topic3&quot;&gt;&lt;/a&gt;Understanding WarehousePG Query Plans&quot;">​</a></h2><p>A query plan is the set of operations WarehousePG will perform to produce the answer to a query. Each <em>node</em> or step in the plan represents a database operation such as a table scan, join, aggregation, or sort. Plans are read and run from bottom to top.</p><p>In addition to common database operations such as table scans, joins, and so on, WarehousePG has an additional operation type called <em>motion</em>. A motion operation involves moving tuples between the segments during query processing. Note that not every query requires a motion. For example, a targeted query plan does not require data to move across the interconnect.</p><p>To achieve maximum parallelism during query runtime, WarehousePG divides the work of the query plan into <em>slices</em>. A slice is a portion of the plan that segments can work on independently. A query plan is sliced wherever a <em>motion</em> operation occurs in the plan, with one slice on each side of the motion.</p><p>For example, consider the following simple query involving a join between two tables:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT customer, amount</span></span>
<span class="line"><span>FROM sales JOIN customer USING (cust_id)</span></span>
<span class="line"><span>WHERE dateCol = &#39;04-30-2016&#39;;</span></span></code></pre></div><p>The following figure shows the query plan. Each segment receives a copy of the query plan and works on it in parallel.</p><p><img src="`+i+'" alt="Query Slice Plan" title="Query Slice Plan"></p><p>The query plan for this example has a <em>redistribute motion</em> that moves tuples between the segments to complete the join. The redistribute motion is necessary because the customer table is distributed across the segments by <code>cust_id</code>, but the sales table is distributed across the segments by <code>sale_id</code>. To perform the join, the <code>sales</code> tuples must be redistributed by <code>cust_id</code>. The plan is sliced on either side of the redistribute motion, creating <em>slice 1</em> and <em>slice 2</em>.</p><p>This query plan has another type of motion operation called a <em>gather motion</em>. A gather motion is when the segments send results back up to the coordinator for presentation to the client. Because a query plan is always sliced wherever a motion occurs, this plan also has an implicit slice at the very top of the plan (<em>slice 3</em>). Not all query plans involve a gather motion. For example, a <code>CREATE TABLE x AS SELECT...</code> statement would not have a gather motion because tuples are sent to the newly created table, not to the coordinator.</p><h2 id="understanding-parallel-query-execution" tabindex="-1"><a id="topic4"></a>Understanding Parallel Query Execution <a class="header-anchor" href="#understanding-parallel-query-execution" aria-label="Permalink to &quot;&lt;a id=&quot;topic4&quot;&gt;&lt;/a&gt;Understanding Parallel Query Execution&quot;">​</a></h2><p>WarehousePG creates a number of database processes to handle the work of a query. On the coordinator, the query worker process is called the <em>query dispatcher</em> (QD). The QD is responsible for creating and dispatching the query plan. It also accumulates and presents the final results. On the segments, a query worker process is called a <em>query executor</em> (QE). A QE is responsible for completing its portion of work and communicating its intermediate results to the other worker processes.</p><p>There is at least one worker process assigned to each <em>slice</em> of the query plan. A worker process works on its assigned portion of the query plan independently. During query runtime, each segment will have a number of processes working on the query in parallel.</p><p>Related processes that are working on the same slice of the query plan but on different segments are called <em>gangs</em>. As a portion of work is completed, tuples flow up the query plan from one gang of processes to the next. This inter-process communication between the segments is referred to as the <em>interconnect</em> component of WarehousePG.</p><p>The following figure shows the query worker processes on the coordinator and two segment instances for previous query plan.</p><p><img src="'+l+'" alt="Query Worker Processes" title="Query Worker Processes"></p>',27)]))}const b=t(p,[["render",c]]);export{q as __pageData,b as default};
