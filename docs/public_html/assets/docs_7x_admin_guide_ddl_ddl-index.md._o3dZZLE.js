import{_ as a,c as t,o as s,ag as n}from"./chunks/framework.Ds6Eueu6.js";const u=JSON.parse('{"title":"Using Indexes in WarehousePG","description":"","frontmatter":{},"headers":[],"relativePath":"docs/7x/admin_guide/ddl/ddl-index.md","filePath":"docs/7x/admin_guide/ddl/ddl-index.md"}'),i={name:"docs/7x/admin_guide/ddl/ddl-index.md"};function o(r,e,l,d,p,c){return s(),t("div",null,e[0]||(e[0]=[n(`<h1 id="using-indexes-in-warehousepg" tabindex="-1">Using Indexes in WarehousePG <a class="header-anchor" href="#using-indexes-in-warehousepg" aria-label="Permalink to &quot;Using Indexes in WarehousePG&quot;">​</a></h1><hr><p>In most traditional databases, indexes can greatly improve data access times. However, in a distributed database such as WarehousePG, indexes should be used more sparingly. WarehousePG performs very fast sequential scans; indexes use a random seek pattern to locate records on disk. WarehousePG data is distributed across the segments, so each segment scans a smaller portion of the overall data to get the result. With table partitioning, the total data to scan may be even smaller. Because business intelligence (BI) query workloads generally return very large data sets, using indexes is not efficient.</p><p>First try your query workload without adding indexes. Indexes are more likely to improve performance for OLTP workloads, where the query is returning a single record or a small subset of data. Indexes can also improve performance on compressed append-optimized tables for queries that return a targeted set of rows, as the optimizer can use an index access method rather than a full table scan when appropriate. For compressed data, an index access method means only the necessary rows are uncompressed.</p><p>WarehousePG automatically creates <code>PRIMARY KEY</code> constraints for tables with primary keys. To create an index on a partitioned table, create an index on the partitioned table that you created. The index is propagated to all the child tables created by WarehousePG. Creating an index on a table that is created by WarehousePG for use by a partitioned table is not supported.</p><p>Note that a <code>UNIQUE CONSTRAINT</code> (such as a <code>PRIMARY KEY CONSTRAINT</code>) implicitly creates a <code>UNIQUE INDEX</code> that must include all the columns of the distribution key and any partitioning key. The <code>UNIQUE CONSTRAINT</code> is enforced across the entire table, including all table partitions (if any).</p><p>Indexes add some database overhead — they use storage space and must be maintained when the table is updated. Ensure that the query workload uses the indexes that you create, and check that the indexes you add improve query performance (as compared to a sequential scan of the table). To determine whether indexes are being used, examine the query <code>EXPLAIN</code> plans. See <a href="./../query/topics/query-profiling.html">Query Profiling</a>.</p><p>Consider the following points when you create indexes.</p><ul><li><strong>Your Query Workload.</strong> Indexes improve performance for workloads where queries return a single record or a very small data set, such as OLTP workloads.</li><li>Compressed Tables. Indexes can improve performance on compressed append-optimized tables for queries that return a targeted set of rows. For compressed data, an index access method means only the necessary rows are uncompressed.</li><li><strong>Avoid indexes on frequently updated columns.</strong> Creating an index on a column that is frequently updated increases the number of writes required when the column is updated.</li><li><strong>Create selective B-tree indexes.</strong> Index selectivity is a ratio of the number of distinct values a column has divided by the number of rows in a table. For example, if a table has 1000 rows and a column has 800 distinct values, the selectivity of the index is 0.8, which is considered good. Unique indexes always have a selectivity ratio of 1.0, which is the best possible. WarehousePG allows unique indexes only on distribution key columns.</li><li><strong>Use Bitmap indexes for low selectivity columns.</strong> The WarehousePG Bitmap index type is not available in regular PostgreSQL. See <a href="#topic93">About Bitmap Indexes</a>.</li><li><strong>Index columns used in joins.</strong> An index on a column used for frequent joins (such as a foreign key column) can improve join performance by enabling more join methods for the query optimizer to use.</li><li><strong>Index columns frequently used in predicates.</strong> Columns that are frequently referenced in <code>WHERE</code> clauses are good candidates for indexes.</li><li><strong>Avoid overlapping indexes.</strong> Indexes that have the same leading column are redundant.</li><li><strong>Drop indexes for bulk loads.</strong> For mass loads of data into a table, consider dropping the indexes and re-creating them after the load completes. This is often faster than updating the indexes.</li><li><strong>Consider a clustered index.</strong> Clustering an index means that the records are physically ordered on disk according to the index. If the records you need are distributed randomly on disk, the database has to seek across the disk to fetch the records requested. If the records are stored close together, the fetching operation is more efficient. For example, a clustered index on a date column where the data is ordered sequentially by date. A query against a specific date range results in an ordered fetch from the disk, which leverages fast sequential access.</li></ul><p><strong>Parent topic:</strong> <a href="./../ddl/ddl.html">DDL: Defining Database Objects</a></p><h2 id="to-cluster-an-index-in-warehousepg" tabindex="-1"><a id="im151772"></a>To cluster an index in WarehousePG <a class="header-anchor" href="#to-cluster-an-index-in-warehousepg" aria-label="Permalink to &quot;&lt;a id=&quot;im151772&quot;&gt;&lt;/a&gt;To cluster an index in WarehousePG&quot;">​</a></h2><p>Using the <code>CLUSTER</code> command to physically reorder a table based on an index can take a long time with very large tables. To achieve the same results much faster, you can manually reorder the data on disk by creating an intermediate table and loading the data in the desired order. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE TABLE new_table (LIKE old_table) </span></span>
<span class="line"><span>       AS SELECT * FROM old_table ORDER BY myixcolumn;</span></span>
<span class="line"><span>DROP old_table;</span></span>
<span class="line"><span>ALTER TABLE new_table RENAME TO old_table;</span></span>
<span class="line"><span>CREATE INDEX myixcolumn_ix ON old_table;</span></span>
<span class="line"><span>VACUUM ANALYZE old_table;</span></span></code></pre></div><h2 id="index-types" tabindex="-1"><a id="topic92"></a>Index Types <a class="header-anchor" href="#index-types" aria-label="Permalink to &quot;&lt;a id=&quot;topic92&quot;&gt;&lt;/a&gt;Index Types&quot;">​</a></h2><p>WarehousePG supports the Postgres index types B-tree, hash, GiST, SP-GiST, GIN, and <a href="./ddl-brin.html">BRIN</a>. Each index type uses a different algorithm that is best suited to different types of queries. B-tree indexes fit the most common situations and are the default index type. See <a href="https://www.postgresql.org/docs/12/indexes-types.html" target="_blank" rel="noreferrer">Index Types</a> in the PostgreSQL documentation for a description of these types.</p><blockquote><p><strong>Note</strong> WarehousePG allows unique indexes only if the columns of the index key are the same as (or a superset of) the WarehousePG distribution key. On a partitioned table, a unique index cannot be enforced across all child tables; a unique index is supported only within a child partition.</p></blockquote><h3 id="about-bitmap-indexes" tabindex="-1"><a id="topic93"></a>About Bitmap Indexes <a class="header-anchor" href="#about-bitmap-indexes" aria-label="Permalink to &quot;&lt;a id=&quot;topic93&quot;&gt;&lt;/a&gt;About Bitmap Indexes&quot;">​</a></h3><p>WarehousePG provides the Bitmap index type. Bitmap indexes are best suited to data warehousing applications and decision support systems with large amounts of data, many ad hoc queries, and few data modification (DML) transactions.</p><p>An index provides pointers to the rows in a table that contain a given key value. A regular index stores a list of tuple IDs for each key corresponding to the rows with that key value. Bitmap indexes store a bitmap for each key value. Regular indexes can be several times larger than the data in the table, but bitmap indexes provide the same functionality as a regular index and use a fraction of the size of the indexed data.</p><p>Each bit in the bitmap corresponds to a possible tuple ID. If the bit is set, the row with the corresponding tuple ID contains the key value. A mapping function converts the bit position to a tuple ID. Bitmaps are compressed for storage. If the number of distinct key values is small, bitmap indexes are much smaller, compress better, and save considerable space compared with a regular index. The size of a bitmap index is proportional to the number of rows in the table times the number of distinct values in the indexed column.</p><p>Bitmap indexes are most effective for queries that contain multiple conditions in the <code>WHERE</code> clause. Rows that satisfy some, but not all, conditions are filtered out before the table is accessed. This improves response time, often dramatically.</p><h4 id="when-to-use-bitmap-indexes" tabindex="-1"><a id="topic94"></a>When to Use Bitmap Indexes <a class="header-anchor" href="#when-to-use-bitmap-indexes" aria-label="Permalink to &quot;&lt;a id=&quot;topic94&quot;&gt;&lt;/a&gt;When to Use Bitmap Indexes&quot;">​</a></h4><p>Bitmap indexes are best suited to data warehousing applications where users query the data rather than update it. Bitmap indexes perform best for columns that have between 100 and 100,000 distinct values and when the indexed column is often queried in conjunction with other indexed columns. Columns with fewer than 100 distinct values, such as a gender column with two distinct values (male and female), usually do not benefit much from any type of index. On a column with more than 100,000 distinct values, the performance and space efficiency of a bitmap index decline.</p><p>Bitmap indexes can improve query performance for ad hoc queries. <code>AND</code> and <code>OR</code> conditions in the <code>WHERE</code> clause of a query can be resolved quickly by performing the corresponding Boolean operations directly on the bitmaps before converting the resulting bitmap to tuple ids. If the resulting number of rows is small, the query can be answered quickly without resorting to a full table scan.</p><h4 id="when-not-to-use-bitmap-indexes" tabindex="-1"><a id="topic95"></a>When Not to Use Bitmap Indexes <a class="header-anchor" href="#when-not-to-use-bitmap-indexes" aria-label="Permalink to &quot;&lt;a id=&quot;topic95&quot;&gt;&lt;/a&gt;When Not to Use Bitmap Indexes&quot;">​</a></h4><p>Do not use bitmap indexes for unique columns or columns with high cardinality data, such as customer names or phone numbers. The performance gains and disk space advantages of bitmap indexes start to diminish on columns with 100,000 or more unique values, regardless of the number of rows in the table.</p><p>Bitmap indexes are not suitable for OLTP applications with large numbers of concurrent transactions modifying the data.</p><p>Use bitmap indexes sparingly. Test and compare query performance with and without an index. Add an index only if query performance improves with indexed columns.</p><h2 id="creating-an-index" tabindex="-1"><a id="topic96"></a>Creating an Index <a class="header-anchor" href="#creating-an-index" aria-label="Permalink to &quot;&lt;a id=&quot;topic96&quot;&gt;&lt;/a&gt;Creating an Index&quot;">​</a></h2><p>The <code>CREATE INDEX</code> command defines an index on a table. A B-tree index is the default index type. For example, to create a B-tree index on the column <em>gender</em> in the table <em>employee</em>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE INDEX gender_idx ON employee (gender);</span></span></code></pre></div><p>To create a bitmap index on the column <em>title</em> in the table <em>films</em>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE INDEX title_bmp_idx ON films USING bitmap (title);</span></span></code></pre></div><h3 id="indexes-on-expressions" tabindex="-1"><a id="topic_tfz_3vz_4fb"></a>Indexes on Expressions <a class="header-anchor" href="#indexes-on-expressions" aria-label="Permalink to &quot;&lt;a id=&quot;topic_tfz_3vz_4fb&quot;&gt;&lt;/a&gt;Indexes on Expressions&quot;">​</a></h3><p>An index column need not be just a column of the underlying table, but can be a function or scalar expression computed from one or more columns of the table. This feature is useful to obtain fast access to tables based on the results of computations.</p><p>Index expressions are relatively expensive to maintain, because the derived expressions must be computed for each row upon insertion and whenever it is updated. However, the index expressions are not recomputed during an indexed search, since they are already stored in the index. In both of the following examples, the system sees the query as just <code>WHERE indexedcolumn = &#39;constant&#39;</code> and so the speed of the search is equivalent to any other simple index query. Thus, indexes on expressions are useful when retrieval speed is more important than insertion and update speed.</p><p>The first example is a common way to do case-insensitive comparisons with the <code>lower</code> function:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT * FROM test1 WHERE lower(col1) = &#39;value&#39;;</span></span></code></pre></div><p>This query can use an index if one has been defined on the result of the <code>lower(col1)</code> function:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE INDEX test1_lower_col1_idx ON test1 (lower(col1));</span></span></code></pre></div><p>This example assumes the following type of query is performed often.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT * FROM people WHERE (first_name || &#39; &#39; || last_name) = &#39;John Smith&#39;;</span></span></code></pre></div><p>The query might benefit from the following index.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE INDEX people_names ON people ((first_name || &#39; &#39; || last_name));</span></span></code></pre></div><p>The syntax of the <code>CREATE INDEX</code> command normally requires writing parentheses around index expressions, as shown in the second example. The parentheses can be omitted when the expression is just a function call, as in the first example.</p><h2 id="examining-index-usage" tabindex="-1"><a id="topic97"></a>Examining Index Usage <a class="header-anchor" href="#examining-index-usage" aria-label="Permalink to &quot;&lt;a id=&quot;topic97&quot;&gt;&lt;/a&gt;Examining Index Usage&quot;">​</a></h2><p>WarehousePG indexes do not require maintenance and tuning. You can check which indexes are used by the real-life query workload. Use the <code>EXPLAIN</code> command to examine index usage for a query.</p><p>The query plan shows the steps or <em>plan nodes</em> that the database will take to answer a query and time estimates for each plan node. To examine the use of indexes, look for the following query plan node types in your <code>EXPLAIN</code> output:</p><ul><li><strong>Index Scan</strong> - A scan of an index.</li><li><strong>Bitmap Heap Scan</strong> - Retrieves all</li><li>from the bitmap generated by BitmapAnd, BitmapOr, or BitmapIndexScan and accesses the heap to retrieve the relevant rows.</li><li><strong>Bitmap Index Scan</strong> - Compute a bitmap by OR-ing all bitmaps that satisfy the query predicates from the underlying index.</li><li><strong>BitmapAnd</strong> or <strong>BitmapOr</strong> - Takes the bitmaps generated from multiple BitmapIndexScan nodes, ANDs or ORs them together, and generates a new bitmap as its output.</li></ul><p>You have to experiment to determine the indexes to create. Consider the following points.</p><ul><li>Run <code>ANALYZE</code> after you create or update an index. <code>ANALYZE</code> collects table statistics. The query optimizer uses table statistics to estimate the number of rows returned by a query and to assign realistic costs to each possible query plan.</li><li>Use real data for experimentation. Using test data for setting up indexes tells you what indexes you need for the test data, but that is all.</li><li>Do not use very small test data sets as the results can be unrealistic or skewed.</li><li>Be careful when developing test data. Values that are similar, completely random, or inserted in sorted order will skew the statistics away from the distribution that real data would have.</li><li>You can force the use of indexes for testing purposes by using run-time parameters to turn off specific plan types. For example, turn off sequential scans (<code>enable_seqscan</code>) and nested-loop joins (<code>enable_nestloop</code>), the most basic plans, to force the system to use a different plan. Time your query with and without indexes and use the <code>EXPLAIN ANALYZE</code> command to compare the results.</li></ul><h2 id="managing-indexes" tabindex="-1"><a id="topic98"></a>Managing Indexes <a class="header-anchor" href="#managing-indexes" aria-label="Permalink to &quot;&lt;a id=&quot;topic98&quot;&gt;&lt;/a&gt;Managing Indexes&quot;">​</a></h2><p>Use the <code>REINDEX</code> command to rebuild a poorly-performing index. <code>REINDEX</code> rebuilds an index using the data stored in the index&#39;s table, replacing the old copy of the index.</p><h3 id="to-rebuild-all-indexes-on-a-table" tabindex="-1"><a id="im143476"></a>To rebuild all indexes on a table <a class="header-anchor" href="#to-rebuild-all-indexes-on-a-table" aria-label="Permalink to &quot;&lt;a id=&quot;im143476&quot;&gt;&lt;/a&gt;To rebuild all indexes on a table&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>REINDEX my_table;</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>REINDEX my_index;</span></span></code></pre></div><h2 id="dropping-an-index" tabindex="-1"><a id="topic99"></a>Dropping an Index <a class="header-anchor" href="#dropping-an-index" aria-label="Permalink to &quot;&lt;a id=&quot;topic99&quot;&gt;&lt;/a&gt;Dropping an Index&quot;">​</a></h2><p>The <code>DROP INDEX</code> command removes an index. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>DROP INDEX title_idx;</span></span></code></pre></div><p>When loading data, it can be faster to drop all indexes, load, then recreate the indexes.</p><h2 id="about-indexes-on-expressions" tabindex="-1"><a id="scan_cover"></a>About Indexes on Expressions <a class="header-anchor" href="#about-indexes-on-expressions" aria-label="Permalink to &quot;&lt;a id=&quot;scan_cover&quot;&gt;&lt;/a&gt;About Indexes on Expressions&quot;">​</a></h2><p>An index column need not be just a column of the underlying table, but can be a function or scalar expression computed from one or more columns of the table. This is useful to obtain fast access to a table based on the results of computations.</p><p>For example, a common way to do case-insensitive comparisons is to use the <code>lower()</code> function:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT * FROM test1 WHERE lower(col1) = &#39;value&#39;;</span></span></code></pre></div><p>This query can use an index if one has been defined on the result of the <code>lower(col1)</code> function:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE INDEX test1_lower_col1_idx ON test1 (lower(col1));</span></span></code></pre></div><p>If you declare this index <code>UNIQUE</code>, it prevents creation of rows whose <code>col1</code> values differ only in case, as well as rows whose <code>col1</code> values are actually identical. So, you can use indexes on expressions to enforce constraints that are not definable as simple unique constraints.</p><p>As another example, if you often invoke queries like:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT * FROM people WHERE (first_name || &#39; &#39; || last_name) = &#39;John Smith&#39;;</span></span></code></pre></div><p>then it might be worth creating an index like this:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE INDEX people_names ON people ((first_name || &#39; &#39; || last_name));</span></span></code></pre></div><p>The syntax of the <code>CREATE INDEX</code> command normally requires writing parentheses around index expressions, as shown in the second example. You can omit the parentheses when the expression is just a function call, as in the first example.</p><p>Index expressions are relatively expensive to maintain, because WarehousePG must compute the derived expression(s) for each row insertion and non-HOT update. However, WarehousePG does not recompute the index expressions during an indexed search, since they are already stored in the index. In both examples above, WarehousePG views the query as just <code>WHERE indexedcolumn = &#39;constant&#39;</code> and so the speed of the search is equivalent to any other simple index query. Indexes on expressions are useful when retrieval speed is more important than insertion and update speed.</p><h2 id="about-partial-indexes" tabindex="-1"><a id="partial_index"></a>About Partial Indexes <a class="header-anchor" href="#about-partial-indexes" aria-label="Permalink to &quot;&lt;a id=&quot;partial_index&quot;&gt;&lt;/a&gt;About Partial Indexes&quot;">​</a></h2><p>A <em>partial index</em> is an index built over a subset of a table; the subset is defined by a conditional expression (called the predicate of the partial index). The index contains entries only for those table rows that satisfy the predicate. There are several situations in which a partial index is particularly useful.</p><p>One common reason for using a partial index is to avoid indexing common values. Since a query searching for a common value (one that accounts for more than a few percent of all the table rows) will not use the index anyway, there is no point in keeping those rows in the index at all. This reduces the size of the index, which will speed up those queries that do use the index. It will also speed up many table update operations because the index does not need to be updated in all cases.</p><h3 id="example-setting-up-a-partial-index-to-exclude-common-values" tabindex="-1"><a id="partial_index_ex1"></a>Example: Setting up a Partial Index to Exclude Common Values <a class="header-anchor" href="#example-setting-up-a-partial-index-to-exclude-common-values" aria-label="Permalink to &quot;&lt;a id=&quot;partial_index_ex1&quot;&gt;&lt;/a&gt;Example: Setting up a Partial Index to Exclude Common Values&quot;">​</a></h3><p>Suppose you are storing web server access logs in a database. Most accesses originate from the IP address range of your organization but some are from elsewhere (say, employees on dial-up connections). If your searches by IP are primarily for outside accesses, you probably do not need to index the IP range that corresponds to your organization&#39;s subnet.</p><p>Assume a table defined as such:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE TABLE access_log (</span></span>
<span class="line"><span>    url varchar,</span></span>
<span class="line"><span>    client_ip inet,</span></span>
<span class="line"><span>    ...</span></span>
<span class="line"><span>);</span></span></code></pre></div><p>To create a partial index that suits the example scenario, use the following command:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE INDEX access_log_client_ip_ix ON access_log (client_ip)</span></span>
<span class="line"><span>WHERE NOT (client_ip &gt; inet &#39;192.168.100.0&#39; AND</span></span>
<span class="line"><span>           client_ip &lt; inet &#39;192.168.100.255&#39;);</span></span></code></pre></div><p>A typical query that can use this index follows:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT *</span></span>
<span class="line"><span>FROM access_log</span></span>
<span class="line"><span>WHERE url = &#39;/index.html&#39; AND client_ip = inet &#39;212.78.10.32&#39;;</span></span></code></pre></div><p>Here the query&#39;s IP address is covered by the partial index. The following query cannot use the partial index, as it uses an IP address that is excluded from the index:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT *</span></span>
<span class="line"><span>FROM access_log</span></span>
<span class="line"><span>WHERE url = &#39;/index.html&#39; AND client_ip = inet &#39;192.168.100.23&#39;;</span></span></code></pre></div><p>Observe that this kind of partial index requires that the common values be predetermined, so such partial indexes are best used for data distributions that do not change. Such indexes can be recreated occasionally to adjust for new data distributions, adding to the maintenance effort.</p><h3 id="example-setting-up-a-partial-index-to-exclude-uninteresting-values" tabindex="-1"><a id="partial_index_ex2"></a>Example: Setting up a Partial Index to Exclude Uninteresting Values <a class="header-anchor" href="#example-setting-up-a-partial-index-to-exclude-uninteresting-values" aria-label="Permalink to &quot;&lt;a id=&quot;partial_index_ex2&quot;&gt;&lt;/a&gt;Example: Setting up a Partial Index to Exclude Uninteresting Values&quot;">​</a></h3><p>Another use for a partial index is to exclude values from the index that the typical query workload is not interested in. This results in the same advantages as listed above, but it prevents the &quot;uninteresting&quot; values from being accessed via that index, even if an index scan might be profitable in that case. Setting up partial indexes for this kind of scenario requires a lot of care and experimentation.</p><p>If you have a table that contains both billed and unbilled orders, where the unbilled orders take up a small fraction of the total table and yet those are the most-accessed rows, you can improve performance by creating an index on just the unbilled rows. The following command creates the index:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE INDEX orders_unbilled_index ON orders (order_nr)</span></span>
<span class="line"><span>    WHERE billed is not true;</span></span></code></pre></div><p>A query to use this index follows:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT * FROM orders WHERE billed is not true AND order_nr &lt; 10000;</span></span></code></pre></div><p>However, you can also use the index in a query that does not involve <code>order_nr</code> at all, for example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT * FROM orders WHERE billed is not true AND amount &gt; 5000.00;</span></span></code></pre></div><p>This is not as efficient as a partial index on the <code>amount</code> column, since WarehousePG must scan the entire index. Yet, if there are relatively few unbilled orders, using this partial index just to find the unbilled orders could be a win.</p><p>Note that the following query cannot use this index:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT * FROM orders WHERE order_nr = 3501;</span></span></code></pre></div><p>The order <code>3501</code> might be among the billed or unbilled orders.</p><p>This example also illustrates that the indexed column and the column used in the predicate do not need to match. WarehousePG supports partial indexes with arbitrary predicates, so long as only columns of the table being indexed are involved. Keep in mind that the predicate must match the conditions used in the queries that are supposed to benefit from the index. To be precise, you can use a partial index in a query only if WarehousePG can recognize that the <code>WHERE</code> condition of the query mathematically implies the predicate of the index. WarehousePG cannot recognize mathematically equivalent expressions that are written in different forms. WarehousePG can recognize simple inequality implications, for example &quot;x &lt; 1&quot; implies &quot;x &lt; 2&quot;; otherwise the predicate condition must exactly match part of the query&#39;s <code>WHERE</code> condition or the index will not be recognized as usable. Matching takes place at query planning time, not at run time. As a result, parameterized query clauses do not work with a partial index. For example a prepared query with a parameter might specify &quot;x &lt; ?&quot; which will never imply &quot;x &lt; 2&quot; for all possible values of the parameter.</p><h3 id="example-setting-up-a-partial-unique-index" tabindex="-1"><a id="partial_index_ex3"></a>Example: Setting up a Partial Unique Index <a class="header-anchor" href="#example-setting-up-a-partial-unique-index" aria-label="Permalink to &quot;&lt;a id=&quot;partial_index_ex3&quot;&gt;&lt;/a&gt;Example: Setting up a Partial Unique Index&quot;">​</a></h3><p>A third possible use for partial indexes does not require the index to be used in queries at all. The idea here is to create a unique index over a subset of a table. This enforces uniqueness among the rows that satisfy the index predicate, without constraining those that do not.</p><p>Suppose that you have a table describing test outcomes. You want to ensure that there is only one &quot;successful&quot; entry for a given subject and target combination, but there might be any number of &quot;unsuccessful&quot; entries. Here is one way to satisfy those conditions:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE TABLE tests (</span></span>
<span class="line"><span>    subject text,</span></span>
<span class="line"><span>    target text,</span></span>
<span class="line"><span>    success boolean,</span></span>
<span class="line"><span>    ...</span></span>
<span class="line"><span>);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>CREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)</span></span>
<span class="line"><span>    WHERE success;</span></span></code></pre></div><p>This is a particularly efficient approach when there are few successful tests and many unsuccessful ones. It is also possible to allow only one null in a column by creating a unique partial index with an <code>IS NULL</code> restriction.</p><p>Finally, a partial index can also be used to override WarehousePG&#39;s query plan choices. Also, data sets with peculiar distributions might cause the system to use an index when it really should not. In that case the index can be set up so that it is not available for the offending query. Normally, WarehousePG makes reasonable choices about index usage (it avoids them when retrieving common values, so the earlier example really only saves index size, it is not required to avoid index usage), and grossly incorrect plan choices are cause for a bug report.</p><h3 id="example-do-not-use-partial-indexes-as-a-substitute-for-partitioning" tabindex="-1"><a id="partial_index_ex4"></a>Example: Do Not Use Partial Indexes as a Substitute for Partitioning <a class="header-anchor" href="#example-do-not-use-partial-indexes-as-a-substitute-for-partitioning" aria-label="Permalink to &quot;&lt;a id=&quot;partial_index_ex4&quot;&gt;&lt;/a&gt;Example: Do Not Use Partial Indexes as a Substitute for Partitioning&quot;">​</a></h3><p>Keep in mind that setting up a partial index indicates that you know at least as much as the query planner knows, in particular you know when an index might be profitable. Forming this knowledge requires experience and understanding of how indexes in WarehousePG work. In most cases, the advantage of a partial index over a regular index will be minimal. There are cases where they are quite counterproductive.</p><p>Suppose you create a large set of non-overlapping partial indexes, for example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE INDEX mytable_cat_1 ON mytable (data) WHERE category = 1;</span></span>
<span class="line"><span>CREATE INDEX mytable_cat_2 ON mytable (data) WHERE category = 2;</span></span>
<span class="line"><span>CREATE INDEX mytable_cat_3 ON mytable (data) WHERE category = 3;</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>CREATE INDEX mytable_cat_N ON mytable (data) WHERE category = N;</span></span></code></pre></div><p>This is a bad idea! Almost certainly, you are better off with a single non-partial index, declared like:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE INDEX mytable_cat_data ON mytable (category, data);</span></span></code></pre></div><p>While a search in this larger index might have to descend through a couple more tree levels than a search in a smaller index, that&#39;s almost certainly going to be cheaper than the planner effort needed to select the appropriate one of the partial indexes. The core of the problem is that WarehousePG does not understand the relationship among the partial indexes, and tests each one to see if it is applicable to the current query.</p><p>If your table is large enough that a single index really is a bad idea, you should look into using partitioning instead. With that mechanism, WarehousePG does understand that the tables and indexes are non-overlapping, so far better performance is possible.</p><h2 id="understanding-index-only-scans-and-covering-indexes" tabindex="-1"><a id="scan_cover"></a>Understanding Index-Only Scans and Covering Indexes <a class="header-anchor" href="#understanding-index-only-scans-and-covering-indexes" aria-label="Permalink to &quot;&lt;a id=&quot;scan_cover&quot;&gt;&lt;/a&gt;Understanding Index-Only Scans and Covering Indexes&quot;">​</a></h2><blockquote><p><strong>Note</strong> WarehousePG selects index-only and covering index scan options for a query plan only for new tables that you create in WarehousePG 7. WarehousePG does not select these plan types for tables that you have upgraded from WarehousePG 6.</p></blockquote><p>All indexes in WarehousePG are secondary indexes, meaning that each index is stored separately from the table&#39;s main data area (which is called the table&#39;s heap). In an ordinary index scan, each row retrieval requires fetching data from both the index and the heap. While the index entries that match a given indexable <code>WHERE</code> condition are often close together in the index, the table rows they reference might reside anywhere in the heap. The heap-access portion of an index scan can involve a lot of random access into the heap, which can be slow, particularly on traditional rotating media. Bitmap scans try to alleviate this cost by doing the heap accesses in sorted order, but that only goes so far.</p><p>WarehousePG supports index-only scans to address the performance issue. Index-only scans can answer queries from an index alone without any heap access. WarehousePG returns values directly out of each index entry instead of consulting the associated heap entry. There are two fundamental restrictions on when WarehousePG can use this method:</p><ol><li><p>The index type must support index-only scans. B-tree indexes always do. GiST and SP-GiST indexes support index-only scans for some operator classes but not others. Other index types have no support. The underlying requirement is that the index must physically store, or else be able to reconstruct, the original data value for each index entry. As a counterexample, GIN indexes cannot support index-only scans because each index entry typically holds only part of the original data value.</p></li><li><p>The query must reference only columns stored in the index. For example, given an index on columns <code>x</code> and <code>y</code> of a table that also has a column <code>z</code>, these queries could use index-only scans:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT x, y FROM tab WHERE x = &#39;key&#39;;</span></span>
<span class="line"><span>SELECT x FROM tab WHERE x = &#39;key&#39; AND y &lt; 42;</span></span></code></pre></div><p>but these queries could not:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT x, z FROM tab WHERE x = &#39;key&#39;;</span></span>
<span class="line"><span>SELECT x FROM tab WHERE x = &#39;key&#39; AND z &lt; 42;</span></span></code></pre></div><p>(Expression indexes and partial indexes complicate this rule, as discussed below.)</p></li></ol><p>If these two fundamental requirements are met, then all the data values required by the query are available from the index, so an index-only scan is physically possible. But there is an additional requirement for any table scan in WarehousePG: it must verify that each retrieved row be &quot;visible&quot; to the query&#39;s MVCC snapshot. Because visibility information is not stored in index entries, only in heap entries, it might seem that every row retrieval would require a heap access anyway. And this is indeed the case, if the table row has been modified recently. However, for seldom-changing data there is a way around this problem. WarehousePG tracks, for each page in a table&#39;s heap, whether all rows stored in that page are old enough to be visible to all current and future transactions. This information is stored in a bit in the table&#39;s visibility map. An index-only scan, after finding a candidate index entry, checks the visibility map bit for the corresponding heap page. If it is set, the row is known visible and so WarehousePG can return the data with no further work. If it is not set, WarehousePG must visit the heap entry to find out whether it is visible, so no performance advantage is gained over a standard index scan. Even in the successful case, this approach trades visibility map accesses for heap accesses; but since the visibility map is four orders of magnitude smaller than the heap it describes, far less physical I/O is required to access it. In most situations the visibility map remains cached in memory all the time.</p><p>To summarize, while an index-only scan is possible given the two fundamental requirements, it will be a win only if a significant fraction of the table&#39;s heap pages have their all-visible map bits set. Because tables in which a large fraction of the rows are unchanging are common enough, this type of scan is very useful in practice.</p><p>To make effective use of the index-only scan feature, you may choose to create a covering index, which is an index specifically designed to include the columns required by a particular type of query that you run frequently. Since queries typically need to retrieve more columns than just the ones they search on, WarehousePG allows you to create an index in which some columns are just &quot;payload&quot; and are not part of the search key. You signal this by adding an <code>INCLUDE</code> clause that lists the extra columns. For example, if you commonly run queries like:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT y FROM tab WHERE x = &#39;key&#39;;</span></span></code></pre></div><p>the traditional approach to speeding up such queries would be to create an index on <code>x</code> only. However, an index defined as:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE INDEX tab_x_y ON tab(x) INCLUDE (y);</span></span></code></pre></div><p>could handle these queries as index-only scans, because <code>y</code> can be obtained from the index without visiting the heap.</p><p>Because column <code>y</code> is not part of the index&#39;s search key, it does not have to be of a data type that the index can handle; it is merely stored in the index and is not interpreted by the index machinery. Also, if the index is a unique index, that is:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE UNIQUE INDEX tab_x_y ON tab(x) INCLUDE (y);</span></span></code></pre></div><p>the uniqueness condition applies to just column <code>x</code>, not to the combination of <code>x</code> and <code>y</code>. (An <code>INCLUDE</code> clause can also be written in <code>UNIQUE</code> and <code>PRIMARY KEY</code> constraints, providing alternative syntax for setting up an index like this.)</p><p>Be conservative about adding non-key payload columns to an index, especially wide columns. If an index tuple exceeds the maximum size allowed for the index type, data insertion fails. Because non-key columns duplicate data from the index&#39;s table and bloat the size of the index, they can potentially slow searches. And remember that there is little point in including payload columns in an index unless the table changes slowly enough that an index-only scan is likely to not need to access the heap. If the heap tuple must be visited anyway, it costs nothing more to get the column&#39;s value from there. Other restrictions are that expressions are not currently supported as included columns, and that only B-tree and GiST indexes currently support included columns.</p><p>Before WarehousePG supported the INCLUDE feature, covering indexes were created by including the payload columns as ordinary index columns, for example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE INDEX tab_x_y ON tab(x, y);</span></span></code></pre></div><p>even though they had no intention of ever using <code>y</code> as part of a <code>WHERE</code> clause. This works fine as long as the extra columns are trailing columns. However, this method doesn&#39;t support the case where you want the index to enforce uniqueness on the key column(s).</p><p>Suffix truncation always removes non-key columns from upper B-Tree levels. As payload columns, they are never used to guide index scans. The truncation process also removes one or more trailing key column(s) when the remaining prefix of key column(s) happens to be sufficient to describe tuples on the lowest B-Tree level. In practice, covering indexes without an <code>INCLUDE</code> clause often avoid storing columns that are effectively payload in the upper levels. However, explicitly defining payload columns as non-key columns reliably keeps the tuples in upper levels small.</p><p>In principle, index-only scans can be used with expression indexes. For example, given an index on <code>f(x)</code> where <code>x</code> is a table column, it should be possible to execute</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT f(x) FROM tab WHERE f(x) &lt; 1;</span></span></code></pre></div><p>as an index-only scan; and this is very attractive if <code>f()</code> is an expensive-to-compute function. However, WarehousePG&#39;s planner is currently not very smart about such cases. It considers a query to be potentially executable by index-only scan only when all columns required by the query are available from the index. In this example, <code>x</code> is not needed except in the context <code>f(x)</code>, but the planner does not notice that and concludes that an index-only scan is not possible. If an index-only scan seems sufficiently worthwhile, you can work around this by adding <code>x</code> as an included column, for example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE INDEX tab_f_x ON tab (f(x)) INCLUDE (x);</span></span></code></pre></div><p>An additional caveat, if the goal is to avoid recalculating <code>f(x)</code>, is that the planner won&#39;t necessarily match uses of <code>f(x)</code> that aren&#39;t in indexable <code>WHERE</code> clauses to the index column. It will usually get this right in simple queries such as shown above, but not in queries that involve joins.</p><p>Partial indexes also have interesting interactions with index-only scans. Consider the following partial index:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)</span></span>
<span class="line"><span>    WHERE success;</span></span></code></pre></div><p>In principle, WarehousePG could perform an index-only scan on this index to satisfy a query like:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT target FROM tests WHERE subject = &#39;some-subject&#39; AND success;</span></span></code></pre></div><p>But there is a problem: the <code>WHERE</code> clause refers to success which is not available as a result column of the index. Nonetheless, an index-only scan is possible because the plan does not need to recheck that part of the <code>WHERE</code> clause at run time: all entries found in the index necessarily have <code>success = true</code> so this need not be explicitly checked in the plan. WarehousePG version 7 recognizes such cases and generates index-only scans, but older versions do not.</p>`,144)]))}const m=a(i,[["render",o]]);export{u as __pageData,m as default};
