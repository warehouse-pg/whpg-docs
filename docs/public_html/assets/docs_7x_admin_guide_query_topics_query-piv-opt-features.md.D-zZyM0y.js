import{_ as s,c as n,o as e,ag as t}from"./chunks/framework.Ds6Eueu6.js";const u=JSON.parse('{"title":"GPORCA Features and Enhancements","description":"","frontmatter":{},"headers":[],"relativePath":"docs/7x/admin_guide/query/topics/query-piv-opt-features.md","filePath":"docs/7x/admin_guide/query/topics/query-piv-opt-features.md"}'),p={name:"docs/7x/admin_guide/query/topics/query-piv-opt-features.md"};function i(l,a,o,r,c,d){return e(),n("div",null,a[0]||(a[0]=[t(`<h1 id="gporca-features-and-enhancements" tabindex="-1">GPORCA Features and Enhancements <a class="header-anchor" href="#gporca-features-and-enhancements" aria-label="Permalink to &quot;GPORCA Features and Enhancements&quot;">​</a></h1><hr><p>GPORCA, the WarehousePG next generation query optimizer, includes enhancements for specific types of queries and operations:</p><ul><li><a href="#topic_dwy_zml_gr">Queries Against Partitioned Tables</a></li><li><a href="#topic_vph_wml_gr">Queries that Contain Subqueries</a></li><li><a href="#topic_c3v_rml_gr">Queries that Contain Common Table Expressions</a></li><li><a href="#topic_plx_mml_gr">DML Operation Enhancements with GPORCA</a></li></ul><p>GPORCA also includes these optimization enhancements:</p><ul><li>Improved join ordering</li><li>Join-Aggregate reordering</li><li>Sort order optimization</li><li>Data skew estimates included in query optimization</li></ul><p><strong>Parent topic:</strong> <a href="./../../query/topics/query-piv-optimizer.html">About GPORCA</a></p><h2 id="queries-against-partitioned-tables" tabindex="-1"><a id="topic_dwy_zml_gr"></a>Queries Against Partitioned Tables <a class="header-anchor" href="#queries-against-partitioned-tables" aria-label="Permalink to &quot;&lt;a id=&quot;topic_dwy_zml_gr&quot;&gt;&lt;/a&gt;Queries Against Partitioned Tables&quot;">​</a></h2><p>GPORCA includes these enhancements for queries against partitioned tables:</p><ul><li><p>Partition elimination is improved.</p></li><li><p>Query plan can contain the Partition selector operator.</p></li><li><p>Partitions are not enumerated in EXPLAIN plans.</p><p>For queries that involve static partition selection where the partitioning key is compared to a constant, GPORCA lists the number of partitions to be scanned in the <code>EXPLAIN</code> output under the Partition Selector operator. This example Partition Selector operator shows the filter and number of partitions selected:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Partition Selector for Part_Table (dynamic scan id: 1) </span></span>
<span class="line"><span>       Filter: a &gt; 10</span></span>
<span class="line"><span>       Partitions selected:  1 (out of 3)</span></span></code></pre></div><p>For queries that involve dynamic partition selection where the partitioning key is compared to a variable, the number of partitions that are scanned will be known only during query execution. The partitions selected are not shown in the <code>EXPLAIN</code> output.</p></li><li><p>Plan size is independent of number of partitions.</p></li><li><p>Out of memory errors caused by number of partitions are reduced.</p></li></ul><p>This example CREATE TABLE command creates a range partitioned table.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CREATE TABLE sales(order_id int, item_id int, amount numeric(15,2), </span></span>
<span class="line"><span>      date date, yr_qtr int)</span></span>
<span class="line"><span>   PARTITION BY RANGE (yr_qtr) (start (201501) INCLUSIVE end (201504) INCLUSIVE, </span></span>
<span class="line"><span>   start (201601) INCLUSIVE end (201604) INCLUSIVE,</span></span>
<span class="line"><span>   start (201701) INCLUSIVE end (201704) INCLUSIVE,     </span></span>
<span class="line"><span>   start (201801) INCLUSIVE end (201804) INCLUSIVE,</span></span>
<span class="line"><span>   start (201901) INCLUSIVE end (201904) INCLUSIVE,</span></span>
<span class="line"><span>   start (202001) INCLUSIVE end (202004) INCLUSIVE);</span></span></code></pre></div><p>GPORCA improves on these types of queries against partitioned tables:</p><ul><li><p>Full table scan. Partitions are not enumerated in plans.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT * FROM sales;</span></span></code></pre></div></li><li><p>Query with a constant filter predicate. Partition elimination is performed.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT * FROM sales WHERE yr_qtr = 201501;</span></span></code></pre></div></li><li><p>Range selection. Partition elimination is performed.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT * FROM sales WHERE yr_qtr BETWEEN 201601 AND 201704 ;</span></span></code></pre></div></li><li><p>Joins involving partitioned tables. In this example, the partitioned dimension table <em>date_dim</em> is joined with fact table <em>catalog_sales</em>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT * FROM catalog_sales</span></span>
<span class="line"><span>   WHERE date_id IN (SELECT id FROM date_dim WHERE month=12);</span></span></code></pre></div></li></ul><h2 id="queries-that-contain-subqueries" tabindex="-1"><a id="topic_vph_wml_gr"></a>Queries that Contain Subqueries <a class="header-anchor" href="#queries-that-contain-subqueries" aria-label="Permalink to &quot;&lt;a id=&quot;topic_vph_wml_gr&quot;&gt;&lt;/a&gt;Queries that Contain Subqueries&quot;">​</a></h2><p>GPORCA handles subqueries more efficiently. A subquery is query that is nested inside an outer query block. In the following query, the SELECT in the WHERE clause is a subquery.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT * FROM part</span></span>
<span class="line"><span>  WHERE price &gt; (SELECT avg(price) FROM part);</span></span></code></pre></div><p>GPORCA also handles queries that contain a correlated subquery (CSQ) more efficiently. A correlated subquery is a subquery that uses values from the outer query. In the following query, the <code>price</code> column is used in both the outer query and the subquery.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT * FROM part p1 WHERE price &gt; (SELECT avg(price) FROM part p2 WHERE p2.brand = p1.brand);</span></span></code></pre></div><p>GPORCA generates more efficient plans for the following types of subqueries:</p><ul><li><p>CSQ in the SELECT list.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT *,</span></span>
<span class="line"><span> (SELECT min(price) FROM part p2 WHERE p1.brand = p2.brand)</span></span>
<span class="line"><span> AS foo</span></span>
<span class="line"><span>FROM part p1;</span></span></code></pre></div></li><li><p>CSQ in disjunctive (OR) filters.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT FROM part p1 WHERE p_size &gt; 40 OR </span></span>
<span class="line"><span>      p_retailprice &gt; </span></span>
<span class="line"><span>      (SELECT avg(p_retailprice) </span></span>
<span class="line"><span>          FROM part p2 </span></span>
<span class="line"><span>          WHERE p2.p_brand = p1.p_brand)</span></span></code></pre></div></li><li><p>Nested CSQ with skip level correlations</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT * FROM part p1 WHERE p1.p_partkey </span></span>
<span class="line"><span>IN (SELECT p_partkey FROM part p2 WHERE p2.p_retailprice = </span></span>
<span class="line"><span>     (SELECT min(p_retailprice)</span></span>
<span class="line"><span>       FROM part p3 </span></span>
<span class="line"><span>       WHERE p3.p_brand = p1.p_brand)</span></span>
<span class="line"><span>);</span></span></code></pre></div><blockquote><p><strong>Note</strong> Nested CSQ with skip level correlations are not supported by the Postgres-based planner.</p></blockquote></li><li><p>CSQ with aggregate and inequality. This example contains a CSQ with an inequality.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT * FROM part p1 WHERE p1.p_retailprice =</span></span>
<span class="line"><span> (SELECT min(p_retailprice) FROM part p2 WHERE p2.p_brand &lt;&gt; p1.p_brand);</span></span></code></pre></div></li><li><p>CSQ that must return one row.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SELECT p_partkey, </span></span>
<span class="line"><span>  (SELECT p_retailprice FROM part p2 WHERE p2.p_brand = p1.p_brand )</span></span>
<span class="line"><span>FROM part p1;</span></span></code></pre></div></li></ul><h2 id="queries-that-contain-common-table-expressions" tabindex="-1"><a id="topic_c3v_rml_gr"></a>Queries that Contain Common Table Expressions <a class="header-anchor" href="#queries-that-contain-common-table-expressions" aria-label="Permalink to &quot;&lt;a id=&quot;topic_c3v_rml_gr&quot;&gt;&lt;/a&gt;Queries that Contain Common Table Expressions&quot;">​</a></h2><p>GPORCA handles queries that contain the WITH clause. The WITH clause, also known as a common table expression (CTE), generates temporary tables that exist only for the query. This example query contains a CTE.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>WITH v AS (SELECT a, sum(b) as s FROM T where c &lt; 10 GROUP BY a)</span></span>
<span class="line"><span>  SELECT *FROM  v AS v1 ,  v AS v2</span></span>
<span class="line"><span>  WHERE v1.a &lt;&gt; v2.a AND v1.s &lt; v2.s;</span></span></code></pre></div><p>As part of query optimization, GPORCA can push down predicates into a CTE. For example query, GPORCA pushes the equality predicates to the CTE.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>WITH v AS (SELECT a, sum(b) as s FROM T GROUP BY a)</span></span>
<span class="line"><span>  SELECT *</span></span>
<span class="line"><span>  FROM v as v1, v as v2, v as v3</span></span>
<span class="line"><span>  WHERE v1.a &lt; v2.a</span></span>
<span class="line"><span>    AND v1.s &lt; v3.s</span></span>
<span class="line"><span>    AND v1.a = 10</span></span>
<span class="line"><span>    AND v2.a = 20</span></span>
<span class="line"><span>    AND v3.a = 30;</span></span></code></pre></div><p>GPORCA can handle these types of CTEs:</p><ul><li><p>CTE that defines one or multiple tables. In this query, the CTE defines two tables.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>WITH cte1 AS (SELECT a, sum(b) as s FROM T </span></span>
<span class="line"><span>               where c &lt; 10 GROUP BY a),</span></span>
<span class="line"><span>      cte2 AS (SELECT a, s FROM cte1 where s &gt; 1000)</span></span>
<span class="line"><span>  SELECT *</span></span>
<span class="line"><span>  FROM cte1 as v1, cte2 as v2, cte2 as v3</span></span>
<span class="line"><span>  WHERE v1.a &lt; v2.a AND v1.s &lt; v3.s;</span></span></code></pre></div></li><li><p>Nested CTEs.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>WITH v AS (WITH w AS (SELECT a, b FROM foo </span></span>
<span class="line"><span>                      WHERE b &lt; 5) </span></span>
<span class="line"><span>           SELECT w1.a, w2.b </span></span>
<span class="line"><span>           FROM w AS w1, w AS w2 </span></span>
<span class="line"><span>           WHERE w1.a = w2.a AND w1.a &gt; 2)</span></span>
<span class="line"><span>  SELECT v1.a, v2.a, v2.b</span></span>
<span class="line"><span>  FROM v as v1, v as v2</span></span>
<span class="line"><span>  WHERE v1.a &lt; v2.a;</span></span></code></pre></div></li></ul><h2 id="dml-operation-enhancements-with-gporca" tabindex="-1"><a id="topic_plx_mml_gr"></a>DML Operation Enhancements with GPORCA <a class="header-anchor" href="#dml-operation-enhancements-with-gporca" aria-label="Permalink to &quot;&lt;a id=&quot;topic_plx_mml_gr&quot;&gt;&lt;/a&gt;DML Operation Enhancements with GPORCA&quot;">​</a></h2><p>GPORCA contains enhancements for DML operations such as INSERT, UPDATE, and DELETE.</p><ul><li><p>A DML node in a query plan is a query plan operator.</p><ul><li>Can appear anywhere in the plan, as a regular node (top slice only for now)</li><li>Can have consumers</li></ul></li><li><p>UPDATE operations use the query plan operator Split and supports these operations:</p><ul><li>UPDATE operations on the table distribution key columns.</li><li>UPDATE operations on the table on the partition key column. This example plan shows the Split operator.</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>QUERY PLAN</span></span>
<span class="line"><span>--------------------------------------------------------------</span></span>
<span class="line"><span>Update  (cost=0.00..5.46 rows=1 width=1)</span></span>
<span class="line"><span>   -&gt;  Redistribute Motion 2:2  (slice1; segments: 2)</span></span>
<span class="line"><span>         Hash Key: a</span></span>
<span class="line"><span>         -&gt;  Result  (cost=0.00..3.23 rows=1 width=48)</span></span>
<span class="line"><span>               -&gt;  Split  (cost=0.00..2.13 rows=1 width=40)</span></span>
<span class="line"><span>                     -&gt;  Result  (cost=0.00..1.05 rows=1 width=40)</span></span>
<span class="line"><span>                           -&gt;  Seq Scan on dmltest</span></span></code></pre></div></li><li><p>New query plan operator Assert is used for constraints checking.</p><p>This example plan shows the Assert operator.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>QUERY PLAN</span></span>
<span class="line"><span>------------------------------------------------------------</span></span>
<span class="line"><span> Insert  (cost=0.00..4.61 rows=3 width=8)</span></span>
<span class="line"><span>   -&gt;  Assert  (cost=0.00..3.37 rows=3 width=24)</span></span>
<span class="line"><span>         Assert Cond: (dmlsource.a &gt; 2) IS DISTINCT FROM </span></span>
<span class="line"><span>false</span></span>
<span class="line"><span>         -&gt;  Assert  (cost=0.00..2.25 rows=3 width=24)</span></span>
<span class="line"><span>               Assert Cond: NOT dmlsource.b IS NULL</span></span>
<span class="line"><span>               -&gt;  Result  (cost=0.00..1.14 rows=3 width=24)</span></span>
<span class="line"><span>                     -&gt;  Seq Scan on dmlsource</span></span></code></pre></div></li></ul>`,31)]))}const g=s(p,[["render",i]]);export{u as __pageData,g as default};
